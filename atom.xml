<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>00&#39;s Adventure</title>
  
  <subtitle>Why join the navy if you can be a pirate</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://uegeek.com/"/>
  <updated>2019-01-05T14:45:52.382Z</updated>
  <id>http://uegeek.com/</id>
  
  <author>
    <name>kidult00</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2018，敬自由和迷失</title>
    <link href="http://uegeek.com/181230-freedom-and-lost-2018.html"/>
    <id>http://uegeek.com/181230-freedom-and-lost-2018.html</id>
    <published>2019-01-05T14:44:15.000Z</published>
    <updated>2019-01-05T14:45:52.382Z</updated>
    
    <content type="html"><![CDATA[<p>今年是特别的一年，特别到在写年终总结的时候，如此不情愿为它画上句点。</p><p>整整一年，在远未实现财务自由的时候，就贸然送给自己一个长假。嗯，是奢侈的，是幸运的。</p><p>回顾这其实挺丧的一年，也还是收获不少：</p><ul><li>自由职业状态存活 1 年，完成设计项目若干，开了工作室</li><li>规划职业逃跑路线，努力更新知识体系和技术栈</li><li>做了 Max/MSP, Ableton Live, Arduino, TouchDesigner, Unreal Engine 等五门课的助教</li><li>HackYourself 和 ArtxCode 共发原创 72 篇约 17 万字；第一次做 TEDx speaker，外加线下分享会 3 次</li><li>继续单身，继续喜欢着一个人</li><li>读书 68 本，出游 3 次，看展和 Live 若干，没有宅出病</li><li>P2P 收益平稳，股市和币圈资产严重缩水……</li></ul><p>如果说去年的主题大概是认识自己、理解人心，那么今年的主题就更明确了：</p><blockquote><p>自由和迷失</p></blockquote><p>谁不向往自由呀，可是只有跟自由狭路相逢短兵相接时，才有机会近距离领教它的无情和凛冽。如果你对「生命中不能承受之轻」是怎样一种状态，感到好奇和困惑，那么给自己一年的自由，你会深刻理解它。</p><p>自由的代价很高昂。这几乎是一场甜蜜的、没有硝烟的战斗。</p><h2 id="自由即无序"><a href="#自由即无序" class="headerlink" title="自由即无序"></a>自由即无序</h2><p>产生这个想法的那一刻，大概是今年最佳的 「Aha moment」。</p><p>如果你愿意，现在就可以开始设想，如果自己自由了，接下来会发生什么。试着问自己，在每个周一早上醒来的时候，能否明确告诉自己，接下来要做什么。</p><p>“做什么不好呢？吃饭睡觉打豆豆，看剧发呆卖个萌。”</p><blockquote><p>然后呢？</p></blockquote><p>如果足够诚实，试着连续问自己 10 个「然后呢？」，就会看到我们在这简单的三个字面前，其实不堪一击。</p><blockquote><p>个人在新制度中发挥积极独立的作用，获得了积极意义上的自由。但他同时摆脱了曾给他安全感和归属感的纽带。由于人失去他在封闭社会里的固定位置，所以也找不到生活的意义所在。</p></blockquote><p>弗洛姆在「逃避自由」中写道。人为了逃避真正的自由，是什么事都干得出的。</p><p>自由意味着可以往任何方向去。没有既定的目的地，没有雀跃的欲求，没有明确的路径，甚至不再有对错、爱恨、意义、仪式、惯例和默契。一切坚固的东西都烟消云散了。</p><p>生命大概是一种反热力学第二定律的存在，是在万事万物趋于无序、死寂的洪流中，一个孤独的分支。布朗运动多自由啊！可是生命没有止步于无意义的死寂，生命就是生命所追求的终极秩序。</p><p>自由的代价，是要承受生命趋于无序时的惊慌失措。这可是一种跟死亡同源的恐慌啊！</p><p>人难以忍受自由之轻，因为它太重了。</p><h2 id="自由即责任"><a href="#自由即责任" class="headerlink" title="自由即责任"></a>自由即责任</h2><p>一个生命的基本意图，是维持生存状态，也就是维持对生命而言有序和有意义的状态。</p><p>如果我们获得了自由，同时也就不得不面对生命趋于耗散这个事实，于是就需要投入更多资源去维系生命的秩序。</p><p>自由好像确实只能以更大的自律来成就。这种自律，不是用命令、坚持、毅力堆砌成的行为规范，而是身处注意力摄魂怪无处不在的信息社会，如何葆有一种自觉、自洽又开放的知行准则，用这套准则推动个人的成长。</p><p>在不自由时，我们还可以轻而易举地遁逃到假想的自由空间。可是一旦身处自由的腹地，却发现无处可逃。这里是目标的真空，是自我的无限投射。从此不能再怨公司怨老板怨大环境，也不能再找没时间没力气没必要之类的借口。</p><p>不过，自由首先不是要负起责任，而是区分责任。</p><p>反思过去的诸多苦恼，发现很多困局都源于对自我责任缺乏清晰的界定，要么没有承担自己应付的责任，要么默许甚至期望别人担负属于自己的责任，要么去干涉、争抢原本属于他人的责任。这条界限的把握，是自我关系和人际关系的永恒难题。好在，在自由的议题下，我们有机会回归责任的本质，有两条准则会慢慢浮现：</p><blockquote><p>我不需要为任何一个人负责</p><p>我要对自己负起全部的责任</p></blockquote><p>什么？不需要为任何人负责？那工作怎么办？家庭怎么办？</p><p>只对自己负责。完不完成工作，怎样完成工作，怎样算负责，这个责任牵涉到哪些需要考虑的因素等等，界定这些本身就是自己责任的一部分。我们为自己定义的「负责」而负责，如果这种定义适应不良，造成了后果，那就由自己去承担这些后果，去决定要不要调整观念和行动。</p><p>不再为了老板负责、为了工资负责、为了所爱的人负责、为了事情本身负责、为了他人或社会文化强加在身的权利义务以及「应该不应该」负责，而是为自己那一整套为人处事的理念和行为结果负责。</p><p>去承担该承担的，去挣得应有的自由。</p><h2 id="自由即重建"><a href="#自由即重建" class="headerlink" title="自由即重建"></a>自由即重建</h2><p>自由的光鲜之下，逃不过一场可弱可强的自我崩塌。</p><p>自由带来了真空，而它吸引来的都是一些送命题：</p><blockquote><p>我想干什么？为什么要干这个？</p><p>我想成为什么样的人？</p><p>我存在的价值是什么？</p><p>当拿掉一个人的职位，抹去他的职业经历，他会是怎样一个人？</p><p>我要如何认识自己？别人会如何认识我？</p></blockquote><p>真空渴望被填补。</p><p>如果没有自发自觉的欲求，又没有主动探索和实现这些欲求的勇气，就需要别人来教导我们怎样去生活，怎么去行动和选择，要跟同事朋友交流什么，甚至是在朋友圈展示什么，根据运势今天又该穿什么。</p><p>我们所有的迷茫、不满、委屈，看似都来自于某个混乱的困局或气场不合的人，但是夜深人静扪心自问，问题的泉眼最终还是会指向自己：我到底想过一种什么样的生活，想获得什么样的成果，想成为什么样的人？</p><p>如果不去寻找这条串起人生意义的线索，而且每天反复提醒自己为何而战、开始去动手建设，那么真空一下子就会被千奇百怪的模因、价值观、媒体内容、口号、论战、广告、行动召唤、账单等等所填满。</p><p>坍塌不全是坏事。灾后总是要重建的。我们也终于有机会在碎成一片一片的瓦砾中，清除残余，重新建起带有自己印记的一砖一瓦。</p><p>这不是一件容易的事，我们可能已经把这个责任/权利让渡出去太久了。</p><p>还好，我还有需要挣的钱，有想探索的领域，有愿意珍惜和守护的人。慢慢的，它们汇聚成理想生活的图景，而我要做的，是放开与过去的纠缠，全身心地投入到这幅图景的建设当中。</p><h2 id="无关紧要是幸福的起点"><a href="#无关紧要是幸福的起点" class="headerlink" title="无关紧要是幸福的起点"></a>无关紧要是幸福的起点</h2><p>今年在自由里面迷失得太久了。这种迷失似乎是过去多年种种困惑的一个缩影，也是我始终难以交出答卷的人生课题。</p><p>我们早已生活在一个道理远比行动多的时代，卖道理已经成为产业，蔚为壮观。每当我们遇到难题，总是忍不住想去抓住一些「道理」来帮自己化险为夷。可是，道听途说的道理跟段子没有太大区别。想过一种富有意义的生活，靠的是从万千道理中，提炼出一种关于「我何以成为我」的信仰，并且亲测、调整再亲测，看看这种信仰能否经受行动和时间洪流的重重考验。</p><p>在与自由日夜斗争的这一年，有更多的机会、时间和耐心，来跟自己的自卑、自恋、幻想、贪欲、嫉妒、无助们对谈。出乎意料地，最大的收获不是进入一种向往的生活状态，而是慢慢习得一种「与我无关」的心态。这种心态，帮助我提高关于「自我」的分辨率，逐渐回撤那些投入在既与我无关、我也无法影响的人事物上的资源，重新投放在我可以也应该掌控的事情上面。</p><p>到底什么与我有关，到底什么真正要紧。</p><p>我相信，「与我无关」是专注的开始，是幸福的起点，也恰好就是人与人之间相互尊重的本源。</p><p>愿你我在来年，都能珍惜对的人，好好经营对的事情，将自己生命的印记，印刻在那些值得浪费的当下。</p><p>新年快乐。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今年是特别的一年，特别到在写年终总结的时候，如此不情愿为它画上句点。&lt;/p&gt;
&lt;p&gt;整整一年，在远未实现财务自由的时候，就贸然送给自己一个长假。嗯，是奢侈的，是幸运的。&lt;/p&gt;
&lt;p&gt;回顾这其实挺丧的一年，也还是收获不少：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自由职业状态存活 1 年
      
    
    </summary>
    
      <category term="HackYourself" scheme="http://uegeek.com/categories/HackYourself/"/>
    
    
      <category term="HackYourself" scheme="http://uegeek.com/tags/HackYourself/"/>
    
      <category term="2018" scheme="http://uegeek.com/tags/2018/"/>
    
      <category term="自由职业" scheme="http://uegeek.com/tags/%E8%87%AA%E7%94%B1%E8%81%8C%E4%B8%9A/"/>
    
      <category term="自由" scheme="http://uegeek.com/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="幸福" scheme="http://uegeek.com/tags/%E5%B9%B8%E7%A6%8F/"/>
    
      <category term="成长" scheme="http://uegeek.com/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作10-响应式智能体和智能架构</title>
    <link href="http://uegeek.com/181213-generative-art-creativity-10.html"/>
    <id>http://uegeek.com/181213-generative-art-creativity-10.html</id>
    <published>2018-12-13T11:45:46.000Z</published>
    <updated>2018-12-13T11:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></li><li><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></li><li><a href="https://www.uegeek.com/181021-generative-art-creativity-03.html" target="_blank" rel="noopener">生成式艺术和算法创作03-混沌和分形</a></li><li><a href="https://www.uegeek.com/181023-generative-art-creativity-04.html" target="_blank" rel="noopener">生成式艺术和算法创作04-规则系统</a></li><li><a href="https://www.uegeek.com/181107-generative-art-creativity-05.html" target="_blank" rel="noopener">生成式艺术和算法创作05-Tessellation</a></li><li><a href="https://www.uegeek.com/181120-generative-art-creativity-06.html" target="_blank" rel="noopener">生成式艺术和算法创作06-形状语法</a></li><li><a href="https://www.uegeek.com/181123-generative-art-creativity-07.html" target="_blank" rel="noopener">生成式艺术和算法创作07-向自然致敬的 L-system</a></li><li><a href="https://www.uegeek.com/181130-generative-art-creativity-08.html" target="_blank" rel="noopener">生成式艺术和算法创作08-马尔可夫模型</a></li><li><a href="https://www.uegeek.com/181208-generative-art-creativity-09.html" target="_blank" rel="noopener">生成式艺术和算法创作09-人工智能体</a></li></ul><p>上一篇我们了解了<a href="https://www.uegeek.com/181208-generative-art-creativity-09.html" target="_blank" rel="noopener">人工智能体的概念和在创作领域的应用</a>。今天我们来看看其中一种重要的智能体：响应式智能体。</p><h2 id="Langton’s-ant"><a href="#Langton’s-ant" class="headerlink" title="Langton’s ant"></a>Langton’s ant</h2><p>兰顿蚂蚁（Langton’s ant）是元胞自动机的例子。它由 Christopher Langton 在 1986 年提出，它由黑白格子和一只「蚂蚁」构成，是一个二维图灵机。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/09/LangtonsAntAnimated.gif" alt=""></p><p>Animation of first 200 steps of Langton’s ant</p><p>兰顿蚂蚁的算法:</p><ul><li>第1步：向前迈出一步</li><li>步骤2：如果当前单元格为白色，将其变为黑色并向右旋转 90°</li><li>步骤3：如果当前单元格为黑色，则将其变为白色并向左转 90°</li></ul><p>兰顿蚂蚁拥有非常简单的逻辑和复杂的表现。在 2000 年，兰顿蚂蚁的图灵完备性被证明。兰顿蚂蚁的想法后来被推广，比如使用多种颜色。</p><p><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/1bd77e59d60852dd135b541fa41b4492713c461b/3-Figure6-1.png" alt=""></p><p>兰顿蚂蚁其实就是一种响应式的架构。它有以下优点：</p><ul><li>简单</li><li>计算易处理</li><li>稳健性</li><li>模型优雅</li></ul><p>而缺点则包括：</p><ul><li>仅使用局部知识推动行动，无法将非局部或长期信息考虑在内</li><li>缺乏清晰的工程设计方法，难以调试</li><li>丧失透明度和可读性，与人类的互动很困难</li></ul><h2 id="智能体架构"><a href="#智能体架构" class="headerlink" title="智能体架构"></a>智能体架构</h2><p>典型的认知智能体由一系列过程组成。</p><p><img src="http://img.viz.mobi/robot%20layered%20control%20system.png" alt="cognitive agent arch"></p><p>智能体通过感应器感知世界。由一个感知模块提供信息给建模模块，更新世界的表征。然后由一个向智能体提供目标和关于世界的信念的规划模块，决定执行什么动作。最后，有一个马达控制模块执行动作，向促动器发送命令。</p><p>Rodney Brooks 提出的这个架构是任务完成行为的层次结构，较低层代表更原始的行为。 每种行为都是一种相当简单的规则结构，每种行为都与其他行为竞争，以控制智能体 。</p><p>Rodney Brooks 也提出过另外一种架构——不是基于一系列链接在一起的模块，而是在行为层次上彼此平行放置：</p><p><img src="http://img.viz.mobi/robot%20layered%20control%20system2.png" alt="reactive agents"></p><p>在子层级中，可以使用更灵活的结构：</p><p><img src="http://img.viz.mobi/subsumption%20architecture-modified.png" alt="subsumption arch"></p><p>Rodney Brooks 根据这些架构设计了机器人 Ghengis：</p><p><img src="http://www.ai.mit.edu/projects/genghis/genghis.jpg" alt=""></p><h2 id="混合架构"><a href="#混合架构" class="headerlink" title="混合架构"></a>混合架构</h2><p>混合架构设计中的关键问题，是各个子组件（响应组件和协商组件）之间交互的元控制。</p><p>多层架构：</p><p><img src="/Users/kidult00/Downloads/Courses/Kadenze/generative-art-and-computational-creativity-i/5-reactive-agents-and-multiagent-systems/layered%20hybrid%20arch.png" alt="layered hybrid arch"></p><p>水平结构的例子：</p><p><img src="/Users/kidult00/Downloads/Courses/Kadenze/generative-art-and-computational-creativity-i/5-reactive-agents-and-multiagent-systems/layering%20arch.png" alt="layering arch"></p><p>Touring Machines: Autonomous Agents with Attitudes (book, by Innes A. Ferguson, Publisher: IEEE Computer Society Press, Published Date: 01/10/2017)</p><p>垂直架构的例子：</p><p><img src="/Users/kidult00/Downloads/Courses/Kadenze/generative-art-and-computational-creativity-i/5-reactive-agents-and-multiagent-systems/InteRRaP.png" alt="InteRRaP"></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Intelligent_agent" target="_blank" rel="noopener">Intelligent agent - Wikiwand</a></li><li>Rodney Brooks, A Robust Layered Control System for a Mobile Robot, AI Memo report, 1985</li><li><a href="https://www.wikiwand.com/en/Langton%27s_ant" target="_blank" rel="noopener">Langton’s ant - Wikiwand</a></li><li><a href="https://www.kadenze.com/courses/generative-art-and-computational-creativity-i" target="_blank" rel="noopener">Generative Art and Computational Creativity | Kadenze</a></li><li><a href="https://www.kadenze.com/courses/generative-art-and-computational-creativity-i/sessions/cognitive-agents-and-multiagent-systems" target="_blank" rel="noopener">Cognitive Agents And Multiagent Systems | Kadenze</a></li></ul><p>Robot art</p><p>CYSP1, Nicolas Schoffer, 1953</p><p><img src="https://www.olats.org/schoffer/archives/img/cysprd1.jpg" alt=""></p><p>Nenage, Norman White, 1974, multi-robot</p><p><img src="http://dada.compart-bremen.de/imageUploads/medium/11WhiteMenage74.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="AI" scheme="http://uegeek.com/tags/AI/"/>
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="Agent" scheme="http://uegeek.com/tags/Agent/"/>
    
      <category term="智能体" scheme="http://uegeek.com/tags/%E6%99%BA%E8%83%BD%E4%BD%93/"/>
    
      <category term="认知智能体" scheme="http://uegeek.com/tags/%E8%AE%A4%E7%9F%A5%E6%99%BA%E8%83%BD%E4%BD%93/"/>
    
      <category term="BDI" scheme="http://uegeek.com/tags/BDI/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作09-人工智能体</title>
    <link href="http://uegeek.com/181208-generative-art-creativity-09.html"/>
    <id>http://uegeek.com/181208-generative-art-creativity-09.html</id>
    <published>2018-12-08T11:43:54.000Z</published>
    <updated>2018-12-08T11:55:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></li><li><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></li><li><a href="https://www.uegeek.com/181021-generative-art-creativity-03.html" target="_blank" rel="noopener">生成式艺术和算法创作03-混沌和分形</a></li><li><a href="https://www.uegeek.com/181023-generative-art-creativity-04.html" target="_blank" rel="noopener">生成式艺术和算法创作04-规则系统</a></li><li><a href="https://www.uegeek.com/181107-generative-art-creativity-05.html" target="_blank" rel="noopener">生成式艺术和算法创作05-Tessellation</a></li><li><a href="https://www.uegeek.com/181120-generative-art-creativity-06.html" target="_blank" rel="noopener">生成式艺术和算法创作06-形状语法</a></li><li><a href="https://www.uegeek.com/181123-generative-art-creativity-07.html" target="_blank" rel="noopener">生成式艺术和算法创作07-向自然致敬的 L-system</a></li><li><a href="https://www.uegeek.com/181130-generative-art-creativity-08.html" target="_blank" rel="noopener">生成式艺术和算法创作08-马尔可夫模型</a></li></ul><h2 id="人工智能体"><a href="#人工智能体" class="headerlink" title="人工智能体"></a>人工智能体</h2><p>我们常看到 OOP - 面向对象的编程，对象是 Object。这篇文章则是关于智能体（agent）的综述。智能体和对象有什么区别呢？智能体是主动的，对象则不是。</p><p>智能体的概念是计算机科学的核心，在认知科学中也很重要。因为它可以研究真实的主体，建模和在现实世界中模拟并观察智能群体。</p><p>人工智能体是一个计算机系统，能够代表使用者或设计者自主运行。<strong>智能体可以形式化表达为从感知到行动的函数</strong>，它将每个可能的感知序列，映射到智能体可以执行的操作，或映射到影响最终操作的系数、反馈元素、函数或常量。软件和机器人都可视为智能体。</p><p>人工智能体有以下特征：</p><ul><li>情境性（situatedness）：通过传感器感知环境，能够通过行动效果器（effectors）影响环境 </li><li>自主和积极主动（Autonomy and pro-activity）: 行动没有外部干预，自己控制内部状态</li><li>灵活性<ul><li>可响应: 及时响应环境的变化</li><li>社交性：与其他智能体或人类互动</li></ul></li></ul><p><img src="https://www.doc.ic.ac.uk/project/examples/2005/163/g0516334/images/sensorseniv.png" alt=""></p><p>智能体的结构</p><ul><li>认知（Cognitive）：维持内部符号表征（一般会有记忆），可能包含推理和规划的评估结构（deliberative architectures）</li><li>反应（Reactive）：没有明确的环境表征，专注于行为规则<ul><li>反射：没有内部状态（只是将输入映射到输出）</li><li>反应：有内部状态（但不是认知）</li></ul></li><li>混合（Hybrid）：混合反应和认知成分，以平衡反应性（reactiveness）和审慎性（deliberativeness）</li></ul><blockquote><p>A first-order intentional system has beliefs and desires but no beliefs and desires about beliefs and desires.</p><p>A second -order intentioal system has beliefs and desires about beliefs and desires both those of others and its own.</p></blockquote><p>一阶意向系统和二阶意向系统。</p><h2 id="Belief–Desire–Intention-BDI-模型"><a href="#Belief–Desire–Intention-BDI-模型" class="headerlink" title="Belief–Desire–Intention BDI 模型"></a>Belief–Desire–Intention BDI 模型</h2><p>信念 - 愿望 - 意图模型（BDI）是智能体编程的软件模型。从表面看，它以智能体的信念、愿望和意图的实现为特征，使用这些概念来解决智能体编程中的特定问题。 实质上它提供了一种机制，将选择计划的活动与当前活动计划的执行分开。 因此，BDI 智能体能够平衡计划（选择做什么）和执行这些计划所花费的时间。</p><p><img src="http://www.inf.ufrgs.br/prosoft/bdi4jade/wp-content/uploads/bdiArch.jpg" alt=""></p><ul><li>Beliefs：信息态度，表示状态和智能体的 know-how，可能是错误的，由 perception 和 reasoning 更新</li><li>Desires：动机态度，评估是对欲望的过滤，决定哪个愿望可以提升为真正的意图</li><li>Intertions：智能体致力于发生的愿望，它是一致的、不冲突的、可能达成的，比 Desires 要强</li></ul><p>确定性行动由以下元素表示：</p><ul><li>可能包含参数的名称</li><li>前置条件列表：必须为真的要执行操作的事实列表</li><li>删除列表：执行操作后不再为真的事实列表</li><li>添加列表：通过执行操作使事实为真的列表</li></ul><p><img src="http://img.viz.mobi/3-BDI%20agent.png" alt="BDI agent"></p><p>Interpreter 主要做两个操作：</p><ul><li>根据当前的信念选择需要追求的意图</li><li>Mean-end 推理生成或选择要执行的计划，以实现意图</li></ul><p>BDI 算法可以表达如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(B,D,I): = Initialize-state();</span><br><span class="line"></span><br><span class="line">While(true):</span><br><span class="line"></span><br><span class="line">    update(B,D,I); //according to internal and external perceptions</span><br><span class="line"></span><br><span class="line">    Options: = option-generator(B,D,I)</span><br><span class="line"></span><br><span class="line">    Selected-options: = deliberate(B,D,I)</span><br><span class="line"></span><br><span class="line">    Update-intentions(selected-options, I)</span><br><span class="line"></span><br><span class="line">    Plan: = planning(I,B)</span><br><span class="line"></span><br><span class="line">    execute(plan);</span><br><span class="line"></span><br><span class="line">    Get-new-perceptions()</span><br><span class="line"></span><br><span class="line">end while</span><br></pre></td></tr></table></figure><p>可以对基础 BDI 算法做很多调整，比如重新规划或意图再考虑。问题是，如果经常重新考虑，会花费太多时间来评估而没有足够时间采取行动；如果使用两种策略，不经常重新考虑，那么盲目执行可能会做出不相关的行动。</p><p>真是经典的 exploration vs. exploitation (deliberation and action) tension 呢！</p><h2 id="智能体在多个创作领域的应用"><a href="#智能体在多个创作领域的应用" class="headerlink" title="智能体在多个创作领域的应用"></a>智能体在多个创作领域的应用</h2><h3 id="UNMAKEABLE-LOVE"><a href="#UNMAKEABLE-LOVE" class="headerlink" title="UNMAKEABLE LOVE"></a>UNMAKEABLE LOVE</h3><p>UNMAKEABLE LOVE 是一个互动多媒体装置作品。此作品由多人操控，但观众无法操控 3D 动画影像，只能透过手电筒感应器的虚拟光束投射到背投式影幕，聚光探索 3D 人物动画的行为与影像。</p><p><img src="http://unmakeablelove.org/images/UML_main.png" alt=""></p><p><a href="http://unmakeablelove.org/" target="_blank" rel="noopener">UNMAKEABLELOVE</a></p><p>作品中的六角形立体柱有六面背投式影幕，可由六个人同时操控手电筒聚光探索 3D 人物活动状况。当观众在操控手电筒投射屏幕观看时，会看到对面的观用者也在用手电筒投射，观看到的对方是真实人物经由红外线摄取影像呈现在屏幕，让观看者仿佛看到真实的另一观看者，让观看者之间在虚拟 3D人物动画的氛围情境内互动。</p><p>这个作品通过算法智能体，人工生命，虚拟社区，人机交互，增强虚拟，混合现实和多媒体表现的实践，以「参与身体的原始铭文」。它将 Beckett 的 “lost ones” 定位在一个虚拟空间中，这个虚拟空间代表着一种严重的身体限制状态，可能会唤起监狱，庇护，拘留营，甚至是「现实」的电视节目。</p><h3 id="The-Painting-Fool"><a href="#The-Painting-Fool" class="headerlink" title="The Painting Fool"></a>The Painting Fool</h3><p>2013 年 7 月，一名崭露头角的艺术家在巴黎 Galerie Oberkampf 举办了展览会。</p><p>展览会持续了一周时间，民众前来观看，新闻媒体广泛报道，一些作品花了多年时间创作，还有一些直接画在画廊上。无论怎么看，这都是一场典型的艺术展。唯一不同的是，这名艺术家不是真人，而是一个名叫 The Painting Fool 的电脑程序。</p><p><img src="http://www.thepaintingfool.com/commercial/tree.png" alt=""></p><p>The painting fool  是一个模块化的架构，包括：</p><ul><li>视觉系统</li><li>内存模块</li><li>一些自我评价系统</li><li>感知系统</li><li>情绪系统</li><li>一些渲染模块，例如 肖像模块</li><li>解释系统</li><li>概念生成模块</li></ul><p>The Painting Fool 是 Simon Colton 的作品。Colton 是伦敦大学金史密斯学院的计算机创作学教授，他认为要让程序创作，先要跨过一些与图灵测试不同的测试。图灵测试要求机器按人类的方式进行可以信服的交谈，Colton 却认为 AI 艺术家要让自己的行为变得「富有技巧」、「可以欣赏」、「富有想像力」才行。</p><p>到目前为止，Painting Fool 已经在这三个方面取得了进步。所谓的欣赏性，按 Colton 的意思就是对情绪作出反应。Painting Fool 的早期作品由图片拼成。程序先要扫描英国卫报一篇关于阿富汗战争的文章，从中提取关键字，比如“军队”和“英国人”，然后寻找与之相关的图片。找到之后程序用图片制作合成图，以反映报纸文章的内容和情绪。</p><h3 id="音乐智能体"><a href="#音乐智能体" class="headerlink" title="音乐智能体"></a>音乐智能体</h3><p>在音乐智能智能体方面，George E. Lewis 在 1983 完成了一个即兴的爵士演奏，是早期有智能智能体参与的例子：</p><div class="video-container"><iframe src="//www.youtube.com/embed/hO47LiHsFtc" frameborder="0" allowfullscreen></iframe></div><p><a href="https://www.youtube.com/watch?v=hO47LiHsFtc&amp;list=RDhO47LiHsFtc#t=12" target="_blank" rel="noopener">George E. Lewis – Voyager Duo 4 - YouTube</a></p><p>Arne Eigenfeldt 是加拿大作曲家，他创作互动和生成音乐系统。 Eigenfeldt 为当代舞蹈做了大量工作，特别是与编舞家Serge Bennathan合作。他的电子音乐主要用 Max/MSP 编写的软件中实时生成。 他最近的研究重点是将知识编码到智能性能系统中。 </p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Arne_eigenfeldt_04_jpg.jpg/1200px-Arne_eigenfeldt_04_jpg.jpg" alt=""></p><div class="video-container"><iframe src="//www.youtube.com/embed/i7IP9d_KBzA" frameborder="0" allowfullscreen></iframe></div><p><a href="https://www.youtube.com/watch?v=i7IP9d_KBzA" target="_blank" rel="noopener">Moments: Time and Space - YouTube</a></p><p><a href="https://aeigenfeldt.wordpress.com/works/music-by-agents/" target="_blank" rel="noopener">Music by agents</a> 是 Arne Eigenfeldt 创建的实时作曲系统，由一组 BDI 智能体组成。智能体们协商各种参数，实现和谐的实时作曲。</p><p><a href="http://metacreation.net/?page_id=443" target="_blank" rel="noopener">James Maxwell</a>, <a href="http://metacreation.net/?page_id=479" target="_blank" rel="noopener">Arne Eigenfeldt</a>, <a href="http://metacreation.net/?page_id=482" target="_blank" rel="noopener">Philippe Pasquier</a>开发的 <a href="http://metacreation.net/musicogmanuscore/" target="_blank" rel="noopener">MusiCOG</a> 是一个用于单声道音乐信息的识别，生成，延续和模式编辑的系统模型。</p><blockquote><p>Music composition is an intellectually demanding human activity that engages a wide range of cognitive faculties. In designing MusiCOG, we wanted to bring forward ideas from our previous work, and combine these with principles from the fields of music perception and cognition and ICA design, in an initial attempt at an integrated model. </p></blockquote><p>为音乐理解和分类设计的 MusiCog 是认知智能体中，处理领域特定知识的智能体。音乐认知智能体一般会参与以下活动：</p><ul><li>自己演奏</li><li>与人类一起演奏</li><li>帮助人类创作新材料</li></ul><p>MUME 是一个汇集了对开发系统感兴趣的艺术家、从业者和研究人员的组织，研究可以自主地识别、学习、表现、编写、完成、陪伴或解释音乐的系统。Metacreation 涉及使用人工智能，人工生命和机器学习的工具和技术，它们本身通常受到认知和生命科学的启发。其中有一个项目叫做 Musebot。</p><p><img src="http://img.viz.mobi/mume_logo-e1544125760113.png" alt=""></p><p>Musebot 项目的目标是建立一个有趣和实验性的研究，教育和制作平台。它是一个协作性的创造性实验：共同制作自主软件智能体，共同制作原创音乐。这些软件智能体将在一个计算机网络上运行。每个软件智能体大致对应于一段音乐中的单个乐器部分，如贝斯或鼓点。</p><p>Musebot 可以与其他 Musebot 一起自动生成音乐。Musebot 协议传递实时数据，但不是具体数据，而是更高层次的音乐概念。</p><h3 id="会话智能体，虚拟智能体，游戏智能体"><a href="#会话智能体，虚拟智能体，游戏智能体" class="headerlink" title="会话智能体，虚拟智能体，游戏智能体"></a>会话智能体，虚拟智能体，游戏智能体</h3><p>会话智能体是相对成熟的智能智能体研究领域，一些典型的智能体包括：</p><ul><li><p>ELIZA, Joseph Weizenbaum, 1964</p></li><li><p>PARRY, Kenneth Colby, 1972</p></li><li><p>SmarterChild, ActiveBuddy, 2001</p></li><li><p>Eugene Goostman, 2001</p></li></ul><p>虚拟智能体</p><p><a href="http://stelarc.org/?catID=20241" target="_blank" rel="noopener">STELARC | PROSTHETIC HEAD</a> (Stelarc, 2003) 是基于认知智能体体系结构的互动作品。智能体可以感知环境，通过检测颜色的超声波传感器来感知观众的服装颜色和基本的运动及行为：<br><img src="http://stelarc.org/media/img/pro-head/head-animation-on-white.gif" alt=""></p><p>游戏中存在许多认知智能体，它们通常不是游戏玩家，而是执行一些需要自动化的任务。这些互动叙事中的智能体行为，可能是预先编写好的，也可能是由程序自动生成的（比如 intelligent drama/story/manager 或 procedural simulation）。</p><h2 id="智能体通信"><a href="#智能体通信" class="headerlink" title="智能体通信"></a>智能体通信</h2><p>认知智能体通过智能体消息和智能体通信协议进行交流，也可能使用 Agent communication language(ACL) 交流，常用的 ACL 有 KQML，FIPA ACL。</p><p>言语行为类型：</p><ul><li>自信：speaker 表达世界表现（告知，断言，……）</li><li>指令：speaker 要求其他人（订单，问题，请求……）</li><li>承诺：speaker 承诺（承诺）</li><li>表达：speaker 表达感受（爱情宣言，…）</li><li>陈述：speaker 根据情境行事（开除，祝福，结婚……）</li></ul><p>消息类型语义：言语行为，前提条件，后置条件。</p><p>智能体之间的通讯过程也涉及到复杂的感知、解释、推理、评估、行动等过程：</p><p><img src="http://img.viz.mobi/9-conversational%20agents.png" alt="conversational agents"></p><p>智能体通讯协议帮助结构化智能体之间的对话，提高通讯效率：</p><p><img src="http://img.viz.mobi/10-agent%20communication%20protocals.png" alt="agent communication protocals"></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Intelligent_agent" target="_blank" rel="noopener">Intelligent agent - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Belief%E2%80%93desire%E2%80%93intention_software_model" target="_blank" rel="noopener">Belief–desire–intention software model - Wikiwand</a></li><li><a href="https://www.kadenze.com/courses/generative-art-and-computational-creativity-i/sessions/cognitive-agents-and-multiagent-systems" target="_blank" rel="noopener">Cognitive Agents And Multiagent Systems | Kadenze</a></li><li><a href="http://musicalmetacreation.org/musebots/musebot-getting-started/" target="_blank" rel="noopener">Musebot Getting Started | Musical Metacreation</a></li><li><a href="https://www.doc.ic.ac.uk/project/examples/2005/163/g0516334/" target="_blank" rel="noopener">Topics in AI : AGENTS</a></li><li><a href="http://www.thepaintingfool.com/index.html" target="_blank" rel="noopener">The Painting Fool - A Computer Artist</a></li><li><a href="https://www.researchgate.net/profile/Philippe_Pasquier/publication/220982337_Shadow_agent_a_new_type_of_virtual_agent/links/0912f510ac2bea76ef000000.pdf" target="_blank" rel="noopener">Shadow agent: a new type of virtual agent</a></li><li><a href="https://aeigenfeldt.wordpress.com/works/music-by-agents/" target="_blank" rel="noopener">music by agents – arne eigenfeldt</a></li><li><a href="http://metacreation.net/musicogmanuscore/" target="_blank" rel="noopener">MusiCOG &amp; ManuScore |</a></li><li><a href="https://www.jiqizhixin.com/articles/2016-10-28-4" target="_blank" rel="noopener">40年认知架构研究概览：实现通用人工智能的道路上我们已走了多远？ | 机器之心</a></li><li><a href="https://www.leiphone.com/news/201602/W3R5gl8rWGCV7xDL.html" target="_blank" rel="noopener">机器学徒：AI有可能变成画家吗？ | 雷锋网</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="AI" scheme="http://uegeek.com/tags/AI/"/>
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="Agent" scheme="http://uegeek.com/tags/Agent/"/>
    
      <category term="智能体" scheme="http://uegeek.com/tags/%E6%99%BA%E8%83%BD%E4%BD%93/"/>
    
      <category term="认知智能体" scheme="http://uegeek.com/tags/%E8%AE%A4%E7%9F%A5%E6%99%BA%E8%83%BD%E4%BD%93/"/>
    
      <category term="BDI" scheme="http://uegeek.com/tags/BDI/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作08-马尔可夫模型</title>
    <link href="http://uegeek.com/181130-generative-art-creativity-08.html"/>
    <id>http://uegeek.com/181130-generative-art-creativity-08.html</id>
    <published>2018-11-30T14:16:40.000Z</published>
    <updated>2018-11-30T14:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></li><li><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></li><li><a href="https://www.uegeek.com/181021-generative-art-creativity-03.html" target="_blank" rel="noopener">生成式艺术和算法创作03-混沌和分形</a></li><li><a href="https://www.uegeek.com/181023-generative-art-creativity-04.html" target="_blank" rel="noopener">生成式艺术和算法创作04-规则系统</a></li><li><a href="https://www.uegeek.com/181107-generative-art-creativity-05.html" target="_blank" rel="noopener">生成式艺术和算法创作05-Tessellation</a></li><li><a href="https://www.uegeek.com/181120-generative-art-creativity-06.html" target="_blank" rel="noopener">生成式艺术和算法创作06-形状语法</a></li><li><a href="https://www.uegeek.com/181123-generative-art-creativity-07.html" target="_blank" rel="noopener">生成式艺术和算法创作07-向自然致敬的 L-system</a></li></ul><h2 id="马尔可夫模型-Markov-Model"><a href="#马尔可夫模型-Markov-Model" class="headerlink" title="马尔可夫模型 Markov Model"></a>马尔可夫模型 Markov Model</h2><p>开始的开始，有必要来认识一下主人公，俄国数学家安德雷·安德耶维齐·马尔可夫。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/AAMarkov.jpg/640px-AAMarkov.jpg" alt=""></p><p>1874 年，18 岁的马尔可夫考入圣彼得堡大学，师从切比雪夫（著名的切比雪夫定理提出者）。他是物理-数学博士，圣彼得堡大学教授，圣彼得堡科学院院士。在概率论、数论、函数逼近论和微分方程等方面卓有成就。</p><p>总的来说，马尔可夫模型是一种<strong>统计模型</strong>，可以用于计算条件概率分布，为一系列的离散事件建模。这就应用很广泛了，哪些是「离散事件」呢？句子中的词汇，音乐中的音符，通过交通灯的车辆数，女票每个月购物的次数……</p><p>以「马尔可夫」开头的术语有很多，先来熟悉一下最重要的几个：</p><ul><li>马尔可夫性质：当一个随机过程在给定现在状态及所有过去状态情况下，其未来状态的条件概率分布仅依赖于当前状态。</li><li>马尔可夫过程：是一个具备了马可夫性质的随机过程，不具备记忆特质（memorylessness）。换言之，马可夫过程的条件概率仅仅与系统的当前状态相关，而与过去历史或未来状态，都是独立、不相关的。</li><li>马尔可夫链：具备离散状态的马可夫过程，通常使用离散的时间集合定义。</li><li>马尔可夫模型：用马尔科夫过程生成序列的算法模型</li></ul><p>它们之间的关系大概可以这样划分：</p><table><thead><tr><th></th><th>系统状态是完全可观察的</th><th>系统状态是部分可观察的</th></tr></thead><tbody><tr><td>系统是自治的</td><td><a href="https://www.wikiwand.com/en/Markov_chain" target="_blank" rel="noopener">马尔可夫链</a></td><td><a href="https://www.wikiwand.com/en/Hidden_Markov_model" target="_blank" rel="noopener">隐马尔可夫模型</a></td></tr><tr><td>系统受到控制</td><td><a href="https://www.wikiwand.com/en/Markov_decision_process" target="_blank" rel="noopener">马尔可夫决策过程</a></td><td><a href="https://www.wikiwand.com/en/Partially_observable_Markov_decision_process" target="_blank" rel="noopener">部分可观察的马尔可夫决策过程</a></td></tr></tbody></table><p>在马尔可夫模型中</p><ul><li>$X_t$ 是时间 t 时表示音符的随机变量</li><li>$P(X_t)$ 是随机事件 $X_t$ 的概率分布</li></ul><p><img src="http://img.viz.mobi/cc-markov-model.png" alt=""></p><p>马尔可夫模型可以基于「上文」做出判断和预测，未来状态只取决于当前状态或者限定范围的过去状态。</p><p>实现马尔可夫模型的学习算法有几个步骤：</p><ul><li>构建一个 transition count table (state transition matrix)，计算每一种可能的上下文的频率分布</li><li>用每一种组合的 count 除以所有的组合总数，即下表中每一行加起来为 1</li><li>随机选择一个起始值，根据概率表格选择下一个序列值</li></ul><p>马尔可夫模型生成算法其实也是一种 <a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">random walk</a> ，根据转换概率分布，基于目前已经生成的序列，随机选择下一个序列值。</p><p>以一段乐曲为例，它由音符 B2,C4#,D4,E4,F4#,G4,G4#,A4,B4,C5#,D5,E5 组成。计算每一个音符后面紧跟着的音符的出现概率。例如，最后一个音符 E5，出现在它后面的音符只有 A4 和 C5#，出现概率分别是 6/16 和 10/16。当生成新的序列时，如果当前音符是 E5，那么根据表格，下一个音符只可能是 A4 或 C5#。</p><p><img src="http://img.viz.mobi/2-song%20corpus.png" alt="song corpus"></p><p>再来看一个三节点的马尔可夫链：</p><p><img src="http://codehop.com/wp-content/uploads/2010/07/3_node_markov_chain.gif" alt=""></p><p>这首马尔可夫旋律以 state_0 开始，播放一个八分音符 Eb。然后选择一个新的状态。选择 state_0，state_1 或 state_2 的概率相等，都是 1/3。假设选择了 state_2，则播放下加二间的十六分音符 G。从 state_2 开始，state_0 被选择的概率是 1/10，state_1 是 2/10，state_2 是 7/10。</p><p>因为马尔可夫模型状态是离散的，可以用有限状态的自动机 (automata) 来表示。</p><p><img src="http://img.viz.mobi/4-markov%20models%20automata%20representation.png" alt="markov models automata representation"></p><h2 id="变量马尔可夫模型"><a href="#变量马尔可夫模型" class="headerlink" title="变量马尔可夫模型"></a>变量马尔可夫模型</h2><p>在随机过程中，变量马尔可夫（Variable order Markov Models/VOM/VMM/VOMM）模型是一类重要的模型，它扩展了马尔可夫模型。</p><p>马尔可夫模型中，具有马尔可夫性质的序列中的每个随机变量，取决于固定数量的随机变量；在 VOM 模型中，该数量的调节随机变量可以基于观察到的特定实现而变化。</p><p>这个实现序列通常被称为上下文 ; 因此 VOM 模型也称为上下文树。调节随机变量数量的灵活性对于许多应用来说是非常有利的，例如统计分析、分类和预测。</p><p>变量马尔可夫模型一般由三部分组成：</p><ul><li>Counting：建立转换表，这是预测的来源</li><li>Smoothing：处理未见过的事件/序列</li><li>Variable length modeling:<ul><li>A transition matrix</li><li>Probabilistic suffix tree</li><li>Factor Oracle, and Context Tree Weighting method (CTW)</li><li>Lempel-Ziv 78 and its improvement LZ-MS</li><li>Prediction by partial match</li></ul></li></ul><p>它的缺点之一是难以产生语料之外的内容。</p><h2 id="隐马尔科夫模型-Hidden-Markov-Model"><a href="#隐马尔科夫模型-Hidden-Markov-Model" class="headerlink" title="隐马尔科夫模型 Hidden Markov Model"></a>隐马尔科夫模型 Hidden Markov Model</h2><p>隐马尔可夫模型（Hidden Markov Model，HMM）是统计模型，它用来描述一个<strong>含有隐含未知参数的马尔可夫过程</strong>。其难点是<strong>从可观察的参数中确定该过程的隐含参数</strong>，然后利用这些参数来作进一步的分析，例如模式识别。</p><p>在一般的马尔可夫模型中，状态对于观察者来说是直接可见的。这样状态的转换概率便是全部的参数。</p><p>而在隐马尔可夫模型中，状态并不是直接可见的，<strong>但受状态影响的某些变量是可见的</strong>。每一个状态在可能输出的符号上，都有一定的概率分布。因此输出符号的序列能够透露出状态序列的一些信息。</p><p><img src="http://www.davidsbatista.net/assets/images/2017-11-11-HMM.png" alt=""></p><p>也就是说，HMM 系统的实际状态是隐藏的，只能观察到 emission probilities。</p><p>HMM 常用来学习两个耦合的内容语料。例如，在语音识别中，可见的信息是音频信号，隐藏的信息是语音词汇。又例如，旋律是可见信息，伴奏/ 和声 是隐藏的信息。</p><p>最常见的三种 Hidden Markov Model 算法：</p><ul><li>the forward algorithm: 计算特定序列的概率，假设已知 transitions and observation 概率和初始状态</li><li>the Baum-Welch algorithm：找出被观测序列中最常见的参数</li><li>the Viterbi algorithm：维特比算法，基于观测序列计算隐藏状态最可能的序列（viterbi path）</li></ul><p>隐马尔科夫模型的优势：</p><ul><li>是学习和生成离散序列最有效和使用广泛的算法</li><li>可以对横轴和纵轴的相关性都建模，HMM 是随机耦合过程</li><li>比马尔可夫模型更好保留原始的数据结构</li></ul><p>劣势：</p><ul><li>需要有很好的领域知识来调整模型结构和参数</li><li>需要相对大的训练数据集</li></ul><h2 id="马尔可夫模型在音乐中的应用"><a href="#马尔可夫模型在音乐中的应用" class="headerlink" title="马尔可夫模型在音乐中的应用"></a>马尔可夫模型在音乐中的应用</h2><p>Lejaren Hiller 在 1957 年完成了算法生成的弦乐四重奏「依利亚克组曲」（Illiac Suite），这也是历史上第一支完全由计算机生成的音乐作品。首先使用马尔可夫链模型来产生有限控制的随机音符，之后利用和声与复调的规则测试这些音符，最后选择符合规则的材料，修改、组合成传统音乐记谱的弦乐四重奏。</p><p><img src="https://pbs.twimg.com/media/DfAdXfHV4AA0Bxb.jpg" alt="ILLIAC Suite "></p><div class="video-container"><iframe src="//www.youtube.com/embed/QyqiSbbwHIs" frameborder="0" allowfullscreen></iframe></div><p><a href="https://www.youtube.com/watch?v=QyqiSbbwHIs" target="_blank" rel="noopener">Lejaren Hiller - Illiac Suite for String Quartet [4/4] - YouTube</a></p><p><a href="http://www.musicainformatica.org/topics/illiac-suite.php" target="_blank" rel="noopener">该作品分为四个乐章</a>：</p><ul><li>第一乐章：计算机生成的不同长度的固定主题旋律</li><li>第二乐章：使用变奏的规则生成的四声部音乐</li><li>第三乐章：通过计算机对节奏、动态和演奏法的不同处理生成的音乐</li><li>第四乐章：通过衍生算法和马尔可夫链的不同模型及概率生成的音乐（pitch, intervals and textures）</li></ul><p>Iannis Xenakis在他 1958 年的专辑 Analogique 中就使用了马尔可夫链来作曲。</p><p><img src="http://img.viz.mobi/xenakis.jpg" alt=""></p><p>在他的著作 Formalized Music: Thought and Mathematics in Composition 里详细描述了使用马尔可夫模型的算法。</p><p><img src="https://discourse-cdn-sjc2.com/standard17/uploads/critterandguitari/original/2X/a/aede09d8452c1b3d4273a4515dfa6c941c62e21e.jpg" alt=""></p><p><img src="http://img.viz.mobi/markovian%20stochastic%20music.png" style="zoom:50%"></p><p>用马尔可夫模型生成音乐的优势，包括符合直觉、容易理解，以及计算量小。但也存在一些问题。例如，输出相当随机、缺乏整体结构；抽象层级有限，容易重复语料库中的片段；限于一维符号序列；限于风格模仿等等。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Markov_model" target="_blank" rel="noopener">Markov model - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh-hans/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%80%A7%E8%B4%A8" target="_blank" rel="noopener">马尔可夫性质 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh-hans/%E9%A6%AC%E5%8F%AF%E5%A4%AB%E9%81%8E%E7%A8%8B" target="_blank" rel="noopener">马可夫过程 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh-hans/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">隐马尔可夫模型 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Variable-order_Markov_model" target="_blank" rel="noopener">Variable-order Markov model - Wikiwand</a></li><li><a href="http://setosa.io/ev/markov-chains/" target="_blank" rel="noopener">Markov Chains explained visually</a></li><li><a href="http://codehop.com/three-node-markov-chain/" target="_blank" rel="noopener">Three Node Markov Chain</a></li><li><a href="https://www.uegeek.com/170713-algorithmic-composition-1.html" target="_blank" rel="noopener">算法作曲历险记01-简史 | 00’s Adventure</a></li><li><a href="https://www.wikiwand.com/en/Iannis_Xenakis" target="_blank" rel="noopener">Iannis Xenakis - Wikiwand</a></li><li><a href="http://metacreation.net/project_1/" target="_blank" rel="noopener">Harmonic Progression</a></li><li><a href="http://www.sfu.ca/~eigenfel/ControlledMarkovSelection.pdf" target="_blank" rel="noopener">Realtime Generation of Harmonic Progressions Using Controlled Markov Selection | PDF</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="Markov" scheme="http://uegeek.com/tags/Markov/"/>
    
      <category term="马尔可夫" scheme="http://uegeek.com/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/"/>
    
      <category term="马尔可夫模型" scheme="http://uegeek.com/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法创作实战03 - 用 MaxMSP 实现 L-system</title>
    <link href="http://uegeek.com/181128-computational-creativity-in-maxmsp-03.html"/>
    <id>http://uegeek.com/181128-computational-creativity-in-maxmsp-03.html</id>
    <published>2018-11-28T13:28:33.000Z</published>
    <updated>2018-11-28T13:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-title1.jpg" alt=""></p><a id="more"></a><p><a href="https://www.uegeek.com/181017-computational-creativity-in-maxmsp-01.html" target="_blank" rel="noopener">算法创作实战01 - 巴纳姆效应之随机星座实验</a></p><p><a href="https://www.uegeek.com/181021-computational-creativity-in-maxmsp-02.html" target="_blank" rel="noopener">算法创作实战02 - 用 MaxMSP 生成随机颜色</a></p><p>好久不见~</p><p>前面两篇算法创作的实战，都是相对容易的小程序。今天我们一起来挑战用 Max/MSP (更准确说，是用 jitter) 来「种」植物。</p><blockquote><p>名称：L-system</p><p>主要使用的对象：jit.linden, jit.turtle, jit.matrix, jit.str.fromsymbol, jit.iter, jit.lcd, jit.pwindow</p><p>难度系数：★★★★☆</p></blockquote><h2 id="什么是-L-system"><a href="#什么是-L-system" class="headerlink" title="什么是 L-system?"></a>什么是 L-system?</h2><p>在<a href="https://www.uegeek.com/181123-generative-art-creativity-07.html" target="_blank" rel="noopener">生成式艺术和算法创作07-向自然致敬的 L-system</a> 中，已经对 L-system 做了详细的介绍。L-system 是 Aristid Lindenmayer  提出的有关生长发展中的细胞交互作用的数学模型，被广泛应用于植物生长过程的研究和建模，也常用于模拟各种生物体的形态。</p><p>L-system 是一系列不同形式的语法规则，它的自然递归规则产生自相似性，也能用于生成自相似的分形，例如迭代函数系统。它一般可以这样定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">G ＝｛V,S,ω,P&#125;,</span><br><span class="line"></span><br><span class="line">V: 变量符号集合</span><br><span class="line"></span><br><span class="line">S: 常量符号集合</span><br><span class="line"></span><br><span class="line">ω: 初始状态串(i.e. seed or axiom)</span><br><span class="line"></span><br><span class="line">P: 生成式规则(production)</span><br></pre></td></tr></table></figure><p>接下来，我们动手来实现它。</p><h2 id="开始的正确姿势"><a href="#开始的正确姿势" class="headerlink" title="开始的正确姿势"></a>开始的正确姿势</h2><blockquote><p>如何在 Max/MSP 实现 L-system？</p></blockquote><p>最开始面对这个问题，会觉得茫然无措：该从哪里开始？</p><p>回答与软件相关的工程问题，最好答案永远是——搜索。</p><p>而搜索的第一站，不是 Google，应该是官方文档。在经历了长时间漫无头绪的搜索，各种成功不成功的尝试后，00 再次获得了一个多么痛的领悟——永远先搜索软件文档。搜索结果已经清楚明白地列出跟 L-system 有关的对象了！</p><p><img src="http://img.viz.mobi/searchL-systemInMax.png" alt=""></p><p>然后我们来仔细读一下文档里面的说明吧。</p><h2 id="jit-linden"><a href="#jit-linden" class="headerlink" title="jit.linden"></a><code>jit.linden</code></h2><p>打开 <code>jit.linden</code> 的帮助文档，例子如下：</p><p><img src="http://img.viz.mobi/jit.linden-help.png" alt=""></p><p>一阵头晕目眩后冷静下来，试着运行程序。然而并不知道它在做什么……</p><p>只好静下心来一点一点看。</p><p>首先是找出核心对象。核心对象 <code>jit.linden</code> 前面连接的是一个矩阵，接收了 tolinden 的消息（unlock patch 后才看到 <code>s tolinden</code> 的内容）；后面连接的是同一个矩阵。将矩阵可视化出来时需要变成 1 维 1 平面的矩阵。但是这个可视化方式非常不直观，需要另外寻找方法。（所以搜索结果列出了 <code>jit.turtle</code> 是不是……）</p><p>例子右边是规则相关的部分。在<a href="https://www.uegeek.com/181123-generative-art-creativity-07.html" target="_blank" rel="noopener">生成式艺术和算法创作07-向自然致敬的 L-system</a> 中我们已经知道，生成式规则(production) 是决定 L-system 生成结果的关键。那么，这里 production 后面的一串 <code>* F * +[F+]* G * -[GF-]F - F --</code> 是什么意思呢？下面给出的注释是：</p><blockquote><p>list of symbols in the format：<br><code>left_context  strict_predecessor  right_context  successor</code></p><p>if a symbol matching the strict_predecessors is found in the matrix it is replaced with the sucessor string if the left and right context is met. the wildcard character (‘*’ by default) means no left or right context.</p></blockquote><p>还是一知半解的感觉，这时候需要打开顶部 <code>p moreinfo</code> 子 patch。里面解释了 production 规则是如何设定的。</p><blockquote><p>L-systems work on an interpreted grammar model wherein a syntax is defined for replacing individual elements of the incoming string with a replacement string. </p><p>L-systems get larger through successive productions. the size of the Jitter matrix used by the object determines the maximum length of the string, so a large matrix is advisable, even if the axiom (starting string) is very small.</p></blockquote><p>大意是，随着迭代，矩阵会变得越来越大，建议设定一个较大尺寸的矩阵。</p><blockquote><p>‘production <em> F </em> +F[F]’ tells jit.linden to take every ‘F’ found in the input matrix and replace it with the string ‘+F[F]’. So the first four generations of an L-system with an axiom of ‘F’ would look like this:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F</span><br><span class="line">+F[F]</span><br><span class="line">++F[F][+F[F]]</span><br><span class="line">+++F[F][+F[F]][++F[F][+F[F]]]</span><br></pre></td></tr></table></figure><p>production 接着的第一个 <em> F 是初始值，或者叫做 axiom（公理），第二个 </em> 是 axiom 替代自己的规则。</p><blockquote><p>More complex models can be created by adding multiple productions, or by introducing context matching into the L-system grammar. </p></blockquote><p>例如：<code>production G F * +F</code>  意思是只有在 <code>F</code> 前面是一个 <code>G</code> 的时候，才将 <code>F</code> 替换为 <code>+F</code> 。</p><p>又如：<code>production G F * +F * G * G-</code> 包含两个规则，一个是上面提到的 <code>GF</code> 替换 为 <code>G+F</code>; 另一个是 <code>G</code> 替换为 <code>G-</code>。</p><p><code>jit.linden</code> 最多可以定义 50 个规则。</p><blockquote><p>the jit.turtle object interprets L-systems as turtle graphics, so that characters such as ‘F’, ‘+’, and ‘-‘ acquire special meaning. you could easily use jit.iter to access the Lindenmayer string in Max.</p></blockquote><p>这一段也剧透了很多重要信息，包括用 <code>jit.iter</code> 获取字符串和用 <code>jit.turtle</code> 显示 L-system 生成的图形。 </p><h2 id="jit-turtle"><a href="#jit-turtle" class="headerlink" title="jit.turtle"></a><code>jit.turtle</code></h2><p> 然后再来看看 <code>jit.turtle</code> 怎么画图。</p><p><img src="http://img.viz.mobi/jit.turtle-help.png" alt=""></p><p><code>jit.turtle</code> 前面是设定各种参数，例如步进值、旋转角度、起始点等，然后接收 <code>jtr</code> 传来的 production 规则，尤其要理解 F、+、- 的含义。<code>jit.turtle</code> 后面接的是一个 <code>jit.lcd</code> ，将规则显示出来。</p><h2 id="生成-L-system"><a href="#生成-L-system" class="headerlink" title="生成 L-system"></a>生成 L-system</h2><p>下面开始动手尝试了。好消息是，不必从零开始，从 <code>jit.linden</code> 帮助里面 copy 主要的部分，就可以快速建立起程序的框架。</p><p>首先是用规则生成矩阵的部分。又可以分为矩阵、公理和规则三部分：</p><ol><li>矩阵部分：<code>jit.linden</code> 前面是一个初始化矩阵，<code>r generate</code> 接收每一步的生成指令；<code>jit.linden</code> 后面是一步生成后存储的矩阵，在下面用 <code>jit.cellblock</code> 和 <code>jit.pwindow</code> 显示存储的值和存储占用情况</li><li>公理：用 <code>jit.str.fromsymbol</code> 接收 axiom 字母并转换成 ASCII 编码，同时指定矩阵的大小，如 1000</li><li>规则：将包含 axiom、production、turtle 参数的规则写入一个 <code>message</code> 中，然后用 <code>r linden</code> 接收并传入 <code>jit.linden</code> </li></ol><p><img src="http://img.viz.mobi/CCMax03-jit.lindenPart.png" alt=""></p><p>接下来将矩阵中存储的规则用 <code>jit.turtle</code> 画出来。</p><p>这里的关键是用 <code>jit.iter</code> 将矩阵中每个值依次传到 <code>jit.turtle</code> ，并且接收 <code>r turtle</code> 中关于角度、大小等设置值，然后传给 <code>jit.lcd</code> 绘制：</p><p><img src="http://img.viz.mobi/CCMax03-jit.turtlePart.png" alt=""></p><h2 id="Let’s-Play"><a href="#Let’s-Play" class="headerlink" title="Let’s Play!"></a>Let’s Play!</h2><p>接下来终于进入寻找有趣 production 的游戏环节了~</p><p>可以自己试验，也可以从网上搜刮一些已经写好的规则。一个完整的规则可以写到一个 <code>message</code> 里面，打包传给 <code>jit.linden</code>:</p><p><img src="http://img.viz.mobi/CCMax03weed%20production.png" alt=""></p><p>下面进入愉快的玩耍时间~</p><p>种草：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* A * F * F * F-[[A]+A]+F[+FA]</span><br></pre></td></tr></table></figure><p><img src="http://img.viz.mobi/CCMax-weed.gif" alt=""></p><p>种（歪的）树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* X * C0F-[C2[X]+C3X]+C1F[C3+FX]-X * F * FF</span><br></pre></td></tr></table></figure><p><img src="http://img.viz.mobi/CCMax-tree.gif" alt=""></p><p>种粮食：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* A * G * G * GFX[+G][-G] * X * X[-FFF][+FFF]FX</span><br></pre></td></tr></table></figure><p><img src="http://img.viz.mobi/CCMax-grain.gif" alt=""></p><p>大城市的“地铁图”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* F * +F[--F+F]</span><br></pre></td></tr></table></figure><p><img src="http://img.viz.mobi/CCMax-sub.gif" alt=""></p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ul><li><a href="https://www.uegeek.com/181123-generative-art-creativity-07.html" target="_blank" rel="noopener">生成式艺术和算法创作07-向自然致敬的 L-system</a> </li><li><a href="https://www.wikiwand.com/en/L-system" target="_blank" rel="noopener">L-system - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Koch_snowflake" target="_blank" rel="noopener">Koch snowflake - Wikiwand</a></li><li><a href="http://paulbourke.net/fractals/lsys/" target="_blank" rel="noopener">L-System manual</a></li><li><a href="https://www.wikiwand.com/en/Turtle_graphics" target="_blank" rel="noopener">Turtle graphics - Wikiwand</a></li><li><a href="http://piratefsh.github.io/p5js-art/public/lsystems/" target="_blank" rel="noopener">L-Systems Renderer</a></li><li><a href="http://www.kevs3d.co.uk/dev/lsystems/" target="_blank" rel="noopener">L-Systems Turtle Graphics Renderer - HTML5 Canvas - by Kevin Roast</a></li></ul><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-title1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="MaxMSP" scheme="http://uegeek.com/tags/MaxMSP/"/>
    
      <category term="分形" scheme="http://uegeek.com/tags/%E5%88%86%E5%BD%A2/"/>
    
      <category term="L-system" scheme="http://uegeek.com/tags/L-system/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作07-向自然致敬的 L-system</title>
    <link href="http://uegeek.com/181123-generative-art-creativity-07.html"/>
    <id>http://uegeek.com/181123-generative-art-creativity-07.html</id>
    <published>2018-11-23T12:20:51.000Z</published>
    <updated>2018-11-23T12:23:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></li><li><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></li><li><a href="https://www.uegeek.com/181021-generative-art-creativity-03.html" target="_blank" rel="noopener">生成式艺术和算法创作03-混沌和分形</a></li><li><a href="https://www.uegeek.com/181023-generative-art-creativity-04.html" target="_blank" rel="noopener">生成式艺术和算法创作04-规则系统</a></li><li><a href="https://www.uegeek.com/181107-generative-art-creativity-05.html" target="_blank" rel="noopener">生成式艺术和算法创作05-Tessellation</a></li><li><a href="https://www.uegeek.com/181120-generative-art-creativity-06.html" target="_blank" rel="noopener">生成式艺术和算法创作06-形状语法</a></li></ul><p>Lindenmayer system，简称 L-system，是由荷兰乌特勒支大学的生物学和植物学家，匈牙利裔的 Aristid Lindenmayer 于 1968 年提出的有关生长发展中的细胞交互作用的数学模型，被广泛应用于植物生长过程的研究和建模，也常用于模拟各种生物体的形态。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Fractal_weeds.jpg/600px-Fractal_weeds.jpg" alt=""></p><p>使用 L-system 生成的 3D 杂草</p><h2 id="L-system-语法"><a href="#L-system-语法" class="headerlink" title="L-system 语法"></a>L-system 语法</h2><p>L-system 是一系列不同形式的语法规则，它的自然递归规则产生自相似性，也能用于生成自相似的分形，例如迭代函数系统，因此也是一种形态发生（morphogenesis）算法。</p><p>L-system 一般可以这样定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">G ＝｛V,S,ω,P&#125;,</span><br><span class="line"></span><br><span class="line">V: 变量符号集合</span><br><span class="line"></span><br><span class="line">S: 常量符号集合</span><br><span class="line"></span><br><span class="line">ω: 初始状态串(i.e. seed or axiom)</span><br><span class="line"></span><br><span class="line">P: 生成式规则(production)</span><br></pre></td></tr></table></figure><p>例如，Lindenmayer 研究海藻生长模式时提出的最早的 L-system：</p><blockquote><p><strong>变量</strong> : A B</p><p><strong>常量</strong> : 无</p><p><strong>公理 </strong>(axiom) : A</p><p><strong>规则</strong> : (A → AB), (B → A)</p></blockquote><p>迭代过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">n = 0 : A</span><br><span class="line">n = 1 : AB</span><br><span class="line">n = 2 : ABA</span><br><span class="line">n = 3 : ABAAB</span><br><span class="line">n = 4 : ABAABABA</span><br><span class="line">n = 5 : ABAABABAABAAB</span><br><span class="line">n = 6 : ABAABABAABAABABAABABA</span><br><span class="line">n = 7 : ABAABABAABAABABAABABAABAABABAABAAB</span><br><span class="line"></span><br><span class="line">用树状分枝表示迭代过程会更容易理解：</span><br><span class="line"></span><br><span class="line">n=0:         A           开始 (公理/起始点)</span><br><span class="line">            / \</span><br><span class="line">n=1:       A   B         根据规则(A → AB)起始点A拓展成AB，由于起始点没有B，规则(B → A)没有被用到</span><br><span class="line">          /|    \</span><br><span class="line">n=2:     A B     A       AB中的A拓展成AB，B变成A，于是得到了ABA</span><br><span class="line">        /| |     |\</span><br><span class="line">n=3:   A B A     A B     可以看到每个A都是一个新的子树的根，由此引发出和整体结构同构的子结构。</span><br><span class="line">      /| | |\    |\ \</span><br><span class="line">n=4: A B A A B   A B A</span><br></pre></td></tr></table></figure><p>下面我们来看看著名的 Koch snowflake（科赫曲线）是如何用 L-system 生成迭代过程的：</p><p><img src="https://www.researchgate.net/profile/Hamid_Bennis/publication/316742654/figure/fig1/AS:545826508607488@1507146588038/Koch-curve-at-iterations-from-0-to-4.png" alt=""></p><p> L-system 规则是：F→F+F–F+F。想象一下有一只乌龟🐢，当它接收到指令 F 时向前走，接收到指令 + 号就左转 60°，- 号右转 60°：</p><p><img src="http://www.fractalcurves.com/images/side_turtle_draws_Koch.jpg" alt=""></p><p>F→F+F–F+F 的意思就是：把每一个线段 F，用 <code>F&#39; 右转 F&#39; 左转再左转 F&#39; 右转 F&#39;</code> 替代……晕了吧？00 为你准备了分解动作示意图：</p><p><img src="http://img.viz.mobi/Koch%20Snowflake%20Rule.png" alt=""></p><p>使用 L-system 生成图形图像时，模型中的符号要能引用计算机屏幕上的图形元素。例如，Fractint 程序使用 Turtle graphics（类似于 Logo 编程语言中的图形）来生成屏幕图像。它将 L-system 模型中的每个常量解释为海龟命令。</p><p>在 L-system 的语法中，常用的符号及其含义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Character        Meaning</span><br><span class="line">   F         Move forward by line length drawing a line</span><br><span class="line">   f         Move forward by line length without drawing a line</span><br><span class="line">   +         Turn left by turning angle</span><br><span class="line">   -         Turn right by turning angle</span><br><span class="line">   |         Reverse direction (ie: turn by 180 degrees)</span><br><span class="line">   [         Push current drawing state onto stack</span><br><span class="line">   ]         Pop current drawing state from the stack</span><br><span class="line">   #         Increment the line width by line width increment</span><br><span class="line">   !         Decrement the line width by line width increment</span><br><span class="line">   @         Draw a dot with line width radius</span><br><span class="line">   &#123;         Open a polygon</span><br><span class="line">   &#125;         Close a polygon and fill it with fill colour</span><br><span class="line">   &gt;         Multiply the line length by the line length scale factor</span><br><span class="line">   &lt;         Divide the line length by the line length scale factor</span><br><span class="line">   &amp;         Swap the meaning of + and -</span><br><span class="line">   (         Decrement turning angle by turning angle increment</span><br><span class="line">   )         Increment turning angle by turning angle increment</span><br></pre></td></tr></table></figure><h2 id="L-system-在生成式艺术中的应用"><a href="#L-system-在生成式艺术中的应用" class="headerlink" title="L-system 在生成式艺术中的应用"></a>L-system 在生成式艺术中的应用</h2><p>L-system 常被艺术家用于生成植物形态或者模拟植物的生长过程。</p><p>例如，下面的规则可以生成一株 Fractal plant：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量 : X F</span><br><span class="line">常量 : + − [ ]</span><br><span class="line">起始状态 : X</span><br><span class="line">规则 : (X → F+[[X]-X]-F[-FX]+X), (F → FF)</span><br><span class="line">角度 : 25°</span><br></pre></td></tr></table></figure><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Fractal-plant.svg/906px-Fractal-plant.svg.png" style="zoom:50%"></p><p>如果 L-system 语法中每个规则仅涉及单个符号而不涉及邻近符号，则属于 context-free。如果规则不仅取决于单个符号而且还取决于邻近符号，则属于 context-sensitive  L-system。这样，不同的规则可以在不同的上下文中运用。</p><p>如果每个符号对应多个 production，并且在每次迭代时以一定概率随机选择，则它是随机 L-system（Stochastic L-systems）。</p><p><img src="https://image.slidesharecdn.com/20procedural-120403132552-phpapp01/95/cs-354-procedural-methods-23-728.jpg?cb=1333459756" alt=""></p><p>L-system weed:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axiom = F</span><br><span class="line">F -&gt; FF-[XY]+[XY]</span><br><span class="line">X -&gt; +FY</span><br><span class="line">Y -&gt; -FX</span><br><span class="line">angle = 22.5</span><br></pre></td></tr></table></figure><p><img src="http://paulbourke.net/fractals/lsys/weed_1.gif" alt=""></p><p>L-system 已经是很成熟的算法，组合不同的规则、尺寸、角度和迭代次数，可以生成变化多样、富有美感的生成式图形。</p><p><img src="http://img.viz.mobi/l-system%20generator1.png" alt=""></p><p><img src="http://img.viz.mobi/l-system%20generator2.png" style="zoom:50%"></p><p>Christa Sommerer 和 Laurent Mignonneau 研究互动式植物生成过程，采集人在环境中的移动等数据作为参数，加入到生成式算法中。</p><div class="video-container"><iframe src="//www.youtube.com/embed/JXX7JNFD2X8" frameborder="0" allowfullscreen></iframe></div><p><a href="https://www.youtube.com/watch?v=JXX7JNFD2X8" target="_blank" rel="noopener">Interactive Plant Growing - YouTube</a></p><p><img src="http://www.interface.ufg.ac.at/christa-laurent/BOOK/InteractiveArtResearch/InteractiveArtResearch.jpg" alt=""></p><p>Jon McCormack 是莫纳什大学的一名艺术家兼计算机科学教授，他的工作包含了算法创作。</p><p>他创作的 Fifty Sisters (2012)系列的特色是「未来的植物」，这些植物用代码通过算法生成。在另一部名为 Eden 的作品中，他创作了一个以虚拟生物为主题的装置作品。</p><p>Bloom 是昆士兰州 QUT 创意产业区委托他制作的一幅 43米 x 9.7米 的数字图像。</p><p><img src="http://jonmccormack.info/wp-content/uploads/2011/04/Bloom960.png" alt=""></p><p>「我认为自己是艺术家」，McCormack 在谈到他的作品时说。</p><blockquote><p>电脑仍然非常原始——它没有人类的创造力，但它有能力做一些我们无法做到的事情。人工智能目前只能给艺术实践带来有限的视角，它们只能利用所学到的知识，而人类的现实情况则是非常广阔的，并且能够给艺术带来了更深刻的视角。</p></blockquote><p>McCormack 指出，人工智能本身就可以创造出看起来像艺术的东西，但是能否把它看作艺术是一个更难的问题。「我们对艺术的看法，很大程度上是人类之间的交流。一旦把一台电脑带进这个情境，你就会突然发现一个非人类的实体正在努力实现这个角色，而这个角色过去是由人类主导的。」</p><p>我们不仅把机器当成一个工具，更是一个合作伙伴或合作者，它拥有自己创造的能力。McCormack 说：</p><blockquote><p>我们一直认为列侬和麦卡特尼是伟大的音乐创作伙伴。我们最终是否会看到一个转折点，这个转折点让我们承认，人类和计算机的伙伴关系不仅仅是其各部分的总和。</p></blockquote><h2 id="L-system-在建筑设计中的应用"><a href="#L-system-在建筑设计中的应用" class="headerlink" title="L-system 在建筑设计中的应用"></a>L-system 在建筑设计中的应用</h2><p>建筑一直都离不开技术的影响。如今电脑技术已经为建筑界带来了许多改变，但它依然潜力无限，甚至可能彻底动摇建筑界的基础规则。</p><p>Michael Hansmeyer 是一位建筑师和程序员，他探索使用算法和计算来生成建筑形式。受到了细胞分裂的启发，Michael Hansmeyer 写下了拥有惊人艳丽的造型和无数刻面的设计运算法则。没人能将他们手绘出来，但它们确实可以被做出来——它们也可以向常规的建筑形态掀起思想狂潮。</p><p><img src="http://www.michael-hansmeyer.com/images/l-systems/l-system-7.jpg" alt=""></p><p><img src="http://www.michael-hansmeyer.com/images/l-systems/l-system-2.jpg" alt=""></p><p>下面是 Michael Hansmeyer 在 TED 2012 年会上的演讲 Building unimaginable shapes：</p><iframe height="498" width="510" src="http://player.youku.com/embed/XNDc4MDM2NzA4" frameborder="0" 'allowfullscreen'=""></iframe><p><a href="https://v.youku.com/v_show/id_XNDc4MDM2NzA4.html" target="_blank" rel="noopener">Michael Hansmeyer：塑造不可思议</a></p><h2 id="L-systems-在音乐中的应用"><a href="#L-systems-在音乐中的应用" class="headerlink" title="L-systems 在音乐中的应用"></a>L-systems 在音乐中的应用</h2><p>使用 L-system 辅助生成音乐片段的研究由来已久。</p><p>Przemyslaw Prusinkiewicz 在 1986 年的论文 Score generation with L-system 中探讨了用算法生成乐谱的方法：用 L-system 生成字符符号，再讲符号解析成一系列的音符<br><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/2820acc0a2efeeaae441ed3b8fba00b7fbcaac8b/4-Figure4-1.png" alt=""></p><p>The score associated with the Hilbert curv in the common musical notation</p><p>随着技术的演进，生成式音乐、算法作曲越来越成熟，架构也越来越复杂，L-system 依然被用作规则和语法生成的方式：</p><p><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/fabba1ee66cd3a835fdfabcb78e19f330eabaf9f/4-Figure1-1.png" alt=""></p><p>via: Improving L-System Music Rendering Using a Hybrid of Stochastic and Context-Sensitive Grammars in a Visual Language Framework.</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/L-system" target="_blank" rel="noopener">L-system - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Koch_snowflake" target="_blank" rel="noopener">Koch snowflake - Wikiwand</a></li><li><a href="http://paulbourke.net/fractals/lsys/" target="_blank" rel="noopener">L-System manual</a></li><li><a href="https://www.wikiwand.com/en/Turtle_graphics" target="_blank" rel="noopener">Turtle graphics - Wikiwand</a></li><li><a href="http://piratefsh.github.io/p5js-art/public/lsystems/" target="_blank" rel="noopener">L-Systems Renderer</a></li><li><a href="http://www.kevs3d.co.uk/dev/lsystems/" target="_blank" rel="noopener">L-Systems Turtle Graphics Renderer - HTML5 Canvas - by Kevin Roast</a></li><li><a href="http://jonmccormack.info/" target="_blank" rel="noopener">Jon McCormack</a></li><li><a href="http://www.michael-hansmeyer.com/l-systems" target="_blank" rel="noopener">Michael Hansmeyer - L-Systems</a></li><li><a href="http://www.michael-hansmeyer.com/" target="_blank" rel="noopener">Michael Hansmeyer - Computational Architecture</a></li><li><a href="http://algorithmicbotany.org/papers/score.icmc86.html" target="_blank" rel="noopener">Score generation with L-systems</a></li><li><a href="https://www.semanticscholar.org/paper/Improving-L-System-Music-Rendering-Using-a-Hybrid-a-Lim-Talib/fabba1ee66cd3a835fdfabcb78e19f330eabaf9f" target="_blank" rel="noopener">Improving L-System Music Rendering Using a Hybrid of Stochastic and Context-Sensitive Grammars in a Visual Language Framework - Semantic Scholar</a></li><li><a href="http://www.theatreofnoise.com/2014/03/l-system-garden-max-implementation-of.html" target="_blank" rel="noopener">theatre of noise: L-System Garden: Max implementation of Lindenmeyer</a></li><li><a href="http://creativetuts.com/creating-cubic-spline-with-mospline-l-system/" target="_blank" rel="noopener">Creating Cubic Spline with Mospline L-System</a></li><li><a href="http://www.motionesque.com/beautyoffractals/" target="_blank" rel="noopener">The Beauty of Fractals - L-system in Houdini - motionesque - Andrea Kühne | motionesquemotionesque</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="分形" scheme="http://uegeek.com/tags/%E5%88%86%E5%BD%A2/"/>
    
      <category term="L-system" scheme="http://uegeek.com/tags/L-system/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作06-形状语法</title>
    <link href="http://uegeek.com/181120-generative-art-creativity-06.html"/>
    <id>http://uegeek.com/181120-generative-art-creativity-06.html</id>
    <published>2018-11-20T12:51:14.000Z</published>
    <updated>2018-11-23T12:21:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></li><li><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></li><li><a href="https://www.uegeek.com/181021-generative-art-creativity-03.html" target="_blank" rel="noopener">生成式艺术和算法创作03-混沌和分形</a></li><li><a href="https://www.uegeek.com/181023-generative-art-creativity-04.html" target="_blank" rel="noopener">生成式艺术和算法创作04-规则系统</a></li><li><a href="https://www.uegeek.com/181107-generative-art-creativity-05.html" target="_blank" rel="noopener">生成式艺术和算法创作05-Tessellation</a></li></ul><p>形状语法/形状文法（Shape grammars）是生成特定类别几何形状的生产系统。</p><p>1971年，<a href="https://www.wikiwand.com/en/George_Stiny" target="_blank" rel="noopener">George Stiny</a> 和 <a href="https://www.wikiwand.com/en/James_Gips" target="_blank" rel="noopener">James Gips</a> 在一篇开创性的文章中定义了形状语法的基础。形状语法是一种计算机辅助设计方法，是研究二维和三维语言的一种方式，它可以按照人们的设计思想和要求，按照一定的规则自动产生新形态。</p><p><img src="http://web.mit.edu/haldane/www/icerays/sm_iceray07.jpg" alt=""></p><p>具体来说，形状语法由形状规则（shape rules）和选择、处理规则的生成引擎（generation engine）组成。形状语法执行计算的两个主要步骤是：识别特定形状，用可能的形状替代。</p><p>形状规则定义如何转换现有形状，由两个部分组成，两个部分由从左到右指向的箭头分隔：</p><ul><li>箭头左侧的部分称为左侧（LHS），描绘形状和标记的条件。</li><li>箭头右侧的部分称为右侧（RHS），描述如何转换 LHS 形状以及标记的位置，标记有助于定位和定向新形状。</li></ul><p>形状语法最少由三个形状规则组成：<strong>起始规则，至少一个转换规则和终止规则</strong>。形状语法中的生产规则可以连续应用，类似 <a href="https://www.wikiwand.com/en/L-System" target="_blank" rel="noopener">L-Systems 中的</a> productions。</p><p>形状语法通常是一个四元组，SG＝（S, L, R, I）。其中 S 是形状的有限集合，L 是符号的有限集合，R 是规则的有限集合，I 是初始形状。形状文法产生的形状，都应通过形状规则由初始形状派生出来。</p><p><img src="/Users/kidult00/Downloads/Courses/Kadenze/generative-art-and-computational-creativity-i/3-rule-based-systems-grammars-and-markov-chains/shape%20grammars%20in%20action.png" alt="shape grammars in action"></p><p><img src="https://d2w9rnfcy7mm78.cloudfront.net/2351379/display_c5bf667d63e6917a82a5163d65212a6d.jpg" alt=""></p><p>形状语法在一个小规模的、定义明确的生成问题（如住房布局和结构细化）时最有用。由于形状规则通常是在小形状上定义的，因此形状语法可以包含许多规则。</p><p>Mitchell 提出的 Palladian 别墅形状语法包含 69 个规则，这些规则适用于整个八个实施步骤。</p><p><img src="https://images.slideplayer.com/27/9112988/slides/slide_6.jpg" alt=""></p><p><img src="https://images.slideplayer.com/27/9112988/slides/slide_7.jpg" alt=""></p><p>Rules of Mughal garden：</p><p><img src="https://arch.gatech.edu/sites/default/files/03_mughal_production.jpg" alt=""></p><p>借助 CAD，形状语法可以节省人力、缩短设计周期、产生系列化方案，能很好地传承文脉，使设计内涵在新环境下得以保存和发展，受到了设计界尤其是建筑设计的高度重视。</p><p><img src="http://keyan.info/wp-content/uploads/2013/04/KeyanGrammar2.png" alt=""></p><p><img src="https://arch.gatech.edu/sites/default/files/08_98_cube_subgroups.jpg" alt=""></p><p>近几十年来，形状语法在计算机图形学中越来越重要。 </p><p>除了用于建筑物或城市的程序建模（例如电影或视频游戏），Shape Grammars 是许多开发系统的基础，它们使用生产规则来生成各种不同的 3D 模型。 使用 Shape Grammars 可以创建具有逼真外观的街道平面图，以及建筑物的外墙或内部空间。</p><p>运用形状语法生成的建筑模型和建筑设计：</p><p><img src="/Users/kidult00/Downloads/Courses/Kadenze/generative-art-and-computational-creativity-i/3-rule-based-systems-grammars-and-markov-chains/architecture%20used%20shape%20grammars.png" alt="architecture used shape grammars"></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Shape_grammar" target="_blank" rel="noopener">Shape grammar - Wikiwand</a></li><li><a href="http://www.shapegrammar.org/" target="_blank" rel="noopener">Shape Grammars</a></li><li><a href="https://www.youtube.com/watch?v=pg1NpMmPv48" target="_blank" rel="noopener">The complex geometry of Islamic design - Eric Broug - YouTube</a></li><li><a href="http://users.metu.edu.tr/baykan/arch467/Readings/Stiny-Mitchell.pdf" target="_blank" rel="noopener">Stiny-Mitchell.pdf</a></li><li><a href="https://arch.gatech.edu/design-computation-1" target="_blank" rel="noopener">Design Computation | School of Architecture | Georgia Institute of Technology | Atlanta, GA</a></li><li><a href="https://slideplayer.com/slide/9522024/" target="_blank" rel="noopener">What is computation? What is a shape grammar? How are shape grammars used in design? How is a shape grammar developed? - ppt download</a></li><li><a href="https://www.youtube.com/watch?v=t-VUpX-xVo4" target="_blank" rel="noopener">Procedural Building Generation with Grammars - YouTube</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="Shape Grammar" scheme="http://uegeek.com/tags/Shape-Grammar/"/>
    
      <category term="形状语法" scheme="http://uegeek.com/tags/%E5%BD%A2%E7%8A%B6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>兴趣多动症的自救指南 | 00 的 TEDx 演讲全文</title>
    <link href="http://uegeek.com/181112TedxWumaStreet.html"/>
    <id>http://uegeek.com/181112TedxWumaStreet.html</id>
    <published>2018-11-12T15:54:05.000Z</published>
    <updated>2018-11-12T16:25:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/TEDxWumaStreet.jpg" alt="TEDxWumaStreet"></p><blockquote><p>11 月 3 日，一场以「变」为主题的思想大会 TEDxWumaStreet 在温州开讲。12 位来自学术界、互联网、新闻界、文化产业、地产行业、设计领域的讲者，跨越山川湖海，共赴这场知识盛宴。 </p><p>尽管行业不同、背景各异，但他们都是自身领域中的思考者和实践者，都在用思想和行动 Remake 人生，讲述精彩故事。 </p></blockquote><p><img src="http://img.viz.mobi/TEDxWumaStreetSpeakers1.jpg" alt="TEDxWumaStreetSpeakers1"></p><p><img src="http://img.viz.mobi/TEDxWumaStreetSpeakers2.jpg" alt="TEDxWumaStreetSpeakers2"></p><p>00 有幸作为本年度 TedxWumaStreet 的受邀演讲者，以自己所经历的兴趣和职业之「变」为主题，分享了个人的 Remake 故事。</p><p>以下是演讲全文，也许你也能感受到这个颇受关注的议题的共鸣，欢迎参与讨论。</p><a id="more"></a><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.002.jpeg" alt="兴趣多动症的自救指南.002"></p><p>这是一则寻人启事。</p><p>请大家回忆一下，在自己的亲朋好友、同事同学里面，有没有这样一类人：他们兴趣广泛，每隔一段时间都会开辟一些新的爱好。比如，这个月是美食博主、下个月可能就玩起了电子音乐。可是，他们挖坑远比填坑快，很难有长久的兴趣。</p><p>你可以回想一下这个朋友的名字，又或者，那个人就是你自己。</p><p>那么，欢迎加入兴趣多动症大家庭。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.005.jpeg" alt=""></p><p>这个词是我编造的，我用它来称呼这样一群人，他们经常要面对一个来自灵魂的拷问：</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.006.jpeg" alt=""></p><p>兴趣太多，容易一事无成，怎么办？</p><p>我被这个问题困扰了很久，应该是一个资深的患者。</p><p>我是学地理出身的互联网产品设计师，曾经在微信、网易等团队做了多年的产品和人机交互设计，业余运营两个公众号 HackYourself 和 ArtxCode，是一名写得了代码、焊的了电路板的菜鸟创客。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.007.jpeg" alt=""></p><p>今天想跟大家分享的是，作为一个兴趣多动症患者，这十多年来我的困惑和领悟。</p><p>兴趣多动症，其实是一种长时间注意力缺乏的表现，做事容易三分钟热度。据我观察，患有这个病症的人群正在快速扩大，因为我们身处的时代，信息越来越丰富，而注意力越来越稀缺。</p><p>具体来说呢，这个病症主要有两个症状——多和动。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.010.jpeg" alt=""></p><p>这一群人很容易被有意思的事情所吸引，这也觉得新鲜，那也觉得好玩。兴趣广泛是好事，可是兴趣泛滥就很难收拾了。然后，他们不但爱胡思乱想，还喜欢比划两下。行动力强是好事，可是经常乱动，也许就是不规则的布朗运动了。</p><p>//</p><p>俗话说，久病成医。</p><p>因为跟这个病症斗争了许多年，我也慢慢开始学着自救。自救的第一步呢，是先给自己把把脉。</p><p>之所容易兴趣广泛变成兴趣泛滥、行动变成乱动，我认为是没有处理好三对主要矛盾：</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.012.jpeg" alt=""></p><p><strong>一个是深度和广度的矛盾。一个是探索和应用的矛盾，应该多探索不同的领域，还是应该尽可能地学以致用，提高投入产出比？还有一个矛盾是愉悦和成就。是满足自己的好奇心、追求新鲜刺激呢，还是应该潜下心来好好积累，成为专家？</strong></p><p>这一群人自然是会选择广度、探索和愉悦的。</p><p>那么，有没有可能，既顺应天性，又不需要去做两难的取舍呢？</p><p>我想应该是有的，前提是要从我们给自己设下的二元对立的陷阱中挣脱出来。</p><p>//</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.014.jpeg" alt=""></p><p>第一个矛盾是追求深度还是追求广度。</p><p>我小时候是个乖学生，但是发现我的同桌们，有一个解答难题最取巧的方法。那就是——直接看别人的答案。所以，我们也可以找出那些兴趣很多，但是样样精通的人，看看他们是如何做到的。</p><p>大家可以想象这样一个人吗？他既拿过奥斯卡奖，又得过奥运会冠军。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.015.jpeg" alt=""></p><p>赫伯特·西蒙就是这样一位神奇的人物，不过他不是奥斯卡影帝和奥运金牌得主，他是至今唯一一位既得过诺贝尔奖又得过图灵奖的学术泰斗。图灵奖就好比计算机科学里的奥斯卡奖。</p><p>对多数人而言，一辈子在一个领域有所成就已经非常幸运了，而西蒙一生一共拿了 9 个博士学位，在经济学、政治学、管理学、人工智能、心理学、认知科学等领域都是大师级的人物……这简直是开了挂的人生，他是怎么做到的呢？</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.016.jpeg" alt=""></p><p>西蒙那些看似庞杂的研究领域，其实是围绕一个大问题展开的：</p><blockquote><p>人类如何决策</p></blockquote><p>他意识到这是人类行为的中心问题，无法由单一学科来解答。他分别从政治学、经济学与管理学视角研究过组织行为以后，转向了心理学，提出有限理性理论。为了深入解释人类决策的机制，又尝试用计算机去模拟人的思维过程，于是成为人工智能的先驱之一。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.017.jpeg" alt=""></p><p>西蒙的例子告诉我们，如果由一个大的主题来驱动，庞杂的兴趣不是障碍，反而是优势。但是如果反过来，先任由兴趣蔓延，再尝试将它们有机结合起来，则要困难很多。</p><p>那么，要如何找到属于自己的主题呢？这也是我探索了多年的问题。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.019.jpeg" alt=""></p><p>我在大学学的是地理信息系统和旅游规划，却做了<a href="https://www.uegeek.com/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/" target="_blank" rel="noopener">互联网产品</a>和<a href="https://www.uegeek.com/tags/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">交互设计</a>的工作。刚开始我觉得挺焦虑的，好像那么多年白费了，一切要从零开始。后来，当我尝试把学科和领域抽象出来，寻找它们的共性，就有了不一样的发现。</p><p>我学的专业是地理，地理学的核心问题是人地关系，对应的实践领域是 planning，规划。我的工作是人机交互设计，顾名思义就是要研究人和计算机的关系，对应的实践领域是 design，设计。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.020.jpeg" alt=""></p><p>其实规划和设计的相似远大于差异，只不过我研究的对象、还有问题的尺度发生了变化，从区域、城市、旅游景区的规划，变成了电脑和手机屏幕界面的设计。</p><p>这就是我对第一个矛盾的理解：<strong>当我们觉得自己的兴趣太多太杂的时候，不仿为它寻找一个主题。</strong></p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.021.jpeg" alt=""></p><p>//</p><p>第二个矛盾，探索和应用，我把它称为资本家的小算盘。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.022.jpeg" alt=""></p><p>试想一下，如果我们是一名淘金者，可能经常需要做这样的取舍：是继续找更大的金矿，还是先把已经找到的矿开采完？探索还是开采，是资源有限的情况下，经常会遇到的两难。当我们面对新的领域和知识，想尝试另外一种职业、另外一种身份，甚至另外一种人生的时候，这个主题就会反复出现。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.023.jpeg" alt=""></p><p>我认为，想种不同的果树、尝试不同的人生，没有问题。问题往往出在，果树还没有结出果实就把树砍了，一种人生的滋味还没有尝到就提前离席了。</p><p>兴趣太多，最容易遇上的尴尬就是从刚入门到秒放弃。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.025.jpeg" alt=""></p><p>比如我，高中开始学吉他，但是几乎每一次都是练到手指起茧刚开始有进步，就没有继续下去了。所以十多年来依然停留在高级入门水平。</p><p>任何兴趣，都需要一个生长期。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.026.jpeg" alt=""></p><p>深耕一个领域，一两年太短，十年又可能坐不住。<strong>那么不妨试着给兴趣分配一笔大额的预算，以两年或者四年为一个财政周期，就像重新读一次本科或者研究生，在开始时就选好课题，督促自己在这个周期内必需学有所成，交出像样的作品才能拿到毕业证。</strong></p><p>Tim Ferriss 也是一名兴趣多动症患者。他是企业家、畅销书作家、演员、武术和舞蹈爱好者，会 6 国语言，拿过中国散打全美冠军、保持着一项探戈舞吉尼斯世界记录。虽然涉猎广泛，但是他会在某一段时间内（比如说 3-6 个月）沉浸地学习某项新技能，直到学有所成，并且把学习经验整理出来出版。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.027.jpeg" alt=""></p><p>我觉得他的方法非常好。所以我也试着给我的兴趣至少半年的时间，并且记录自己的学习过程。</p><p>我一直对做东西感兴趣，所以参加了 <a href="https://www.uegeek.com/tags/Fab/" target="_blank" rel="noopener">MIT 麻省理工大学一个向全球开放的课程</a>，用半年的时间专门学习数字制造的各种技能，包括 3D 建模，3D 打印，电路设计，嵌入式开发等等。每周要去上课，在实验室里动手做作业。</p><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=t0312hw9hzn" allowfullscreen="true"></iframe><p>因为当时是在国内最早的一批学生，没有什么中文的资料，所以我把<a href="https://www.uegeek.com/tags/Fab/" target="_blank" rel="noopener">每一周的笔记和需要动手做出实物的作业</a>都写成了教程。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.029.jpeg" alt=""></p><p>半年里，看着自己一点一点地学着画图、操作机器、接电路板、编程，最终还通过了答辩拿到了毕业证，就会觉得从入门到没有放弃，这种感觉真是太鼓舞人心了。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.030.jpeg" alt=""></p><p>所以，<strong>面对探索和应用的矛盾，我们可以设定兴趣周期，在相对固定的时间框架内自由探索，并且形成积累，成为下一个阶段的储备。</strong></p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.031.jpeg" alt=""></p><p>//</p><p>第三个难题，是如何平衡愉悦和成就。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.032.jpeg" alt=""></p><p>多动症患者很喜欢 接触新课题时的感觉，喜欢即时满足，可能容易欺骗自己认为已经学到了，而对漫长、看似停滞的练习阶段缺乏耐心。可是如果不经过积累，哪来的成果和意义呢？</p><p>这个矛盾困扰了我很久。直到有一天，我突然反问自己，为什么愉悦和成就变成了矛盾呢？</p><blockquote><p>愉悦到底来自哪里？</p><p>什么样的愉悦是我们应该追求的？</p><p>怎样可以既愉悦又有所建树？</p></blockquote><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.034.jpeg" alt=""></p><p>村上春树在《我的职业是小说家》这本书里这样写到。在外人看来，村上的写作生活，规律到有点乏味，就像钟表一样分秒不差。每天 4 点起床，写作 5 小时，下午跑步 1 小时或游泳 1 个半小时，然后读书、听音乐，晚上 9 点睡觉。这样的作息，从他写长篇小说开始，几乎从未改变。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.035.jpeg" alt=""></p><p>愉悦和成就本来就不该是对立的，恰恰相反，在常人并没有什么感觉的事情上面，能体会到持续的愉悦，才容易做出不一般的成绩。我想，不论是写作还是跑步，村上应该都体验到了极强的心流。</p><p>心流是积极心理学的创始人之一，希斯赞特米哈伊提出的概念，它是指我们在做某些事情时，那种全神贯注、投入忘我的状态，甚至感觉不到时间的存在，而完成之后会有一种充满能量并且非常满足的感受。在做那些自己喜欢、擅长、有挑战的事情时，就容易体验到心流，比如写作、演奏乐器、玩游戏、运动等等。</p><p>所以，并不是所有的愉悦都值得追求。现在我常常会<strong>用一个标准来过滤兴趣，那就是看这件事情能否容易让我进入心流状态。</strong></p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.037.jpeg" alt=""></p><p>想要兼顾愉悦和成就，最简单有效的做法就是在心流中形成作品——不论是一篇文章，一个程序，还是一件物品。</p><p>//</p><p>以上就是我对兴趣多动症三个主要矛盾的自救策略。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.038.jpeg" alt=""></p><p><strong>深度和广度的矛盾，可以用主题来整合。探索和应用的矛盾，可以用兴趣周期来拆分。愉悦和成就的矛盾，可以用心流换作品，皆大欢喜。</strong></p><p>兴趣多动症是一种频发症状，这也是我给自己的三颗速效救心丸。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.039.jpeg" alt=""></p><p>在这些年的自救过程中，我曾经焦虑于自己的不专注，期望自己变成在兴趣上很专一的人。但是都失败了。因为那不是我。一个人最鲜明的特质，往往就是最大的缺点，也是最大的优点。<strong>找出那些自己能够以苦为乐的事情，不断地觉察、顺应、引导和锻炼天性，把它培养成优势，是我们每一个人真正的人生课题。</strong></p><p>所以我的多动症还在继续。</p><p>你看，因为想给这次演讲做一个小片头，我又新开了一个坑：学做 3D 动画。我跟着教程做了一个四处张望的多动的潜水艇。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.040.jpeg" alt=""></p><p>做完以后，我发现它更适合做片尾，因为这是我的第一个练习作品，前面有一个大坑等着我来填。</p><p>如果你跟我一样，曾经被兴趣太多而困扰，不妨试着善待自己本性，把天性塑造成独特的优势。</p><p>每个人都可以、并且应该成为自己的伯乐，为世界贡献一人份的多样性。</p><hr><p><img src="http://img.viz.mobi/TEDxWumaStreet-thanks.jpeg" alt=""></p><p>你也是兴趣多动症患者吗？欢迎在留言区吐槽和支招 ~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/TEDxWumaStreet.jpg&quot; alt=&quot;TEDxWumaStreet&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;11 月 3 日，一场以「变」为主题的思想大会 TEDxWumaStreet 在温州开讲。12 位来自学术界、互联网、新闻界、文化产业、地产行业、设计领域的讲者，跨越山川湖海，共赴这场知识盛宴。 &lt;/p&gt;
&lt;p&gt;尽管行业不同、背景各异，但他们都是自身领域中的思考者和实践者，都在用思想和行动 Remake 人生，讲述精彩故事。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/TEDxWumaStreetSpeakers1.jpg&quot; alt=&quot;TEDxWumaStreetSpeakers1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/TEDxWumaStreetSpeakers2.jpg&quot; alt=&quot;TEDxWumaStreetSpeakers2&quot;&gt;&lt;/p&gt;
&lt;p&gt;00 有幸作为本年度 TedxWumaStreet 的受邀演讲者，以自己所经历的兴趣和职业之「变」为主题，分享了个人的 Remake 故事。&lt;/p&gt;
&lt;p&gt;以下是演讲全文，也许你也能感受到这个颇受关注的议题的共鸣，欢迎参与讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="HackYourself" scheme="http://uegeek.com/categories/HackYourself/"/>
    
    
      <category term="TED" scheme="http://uegeek.com/tags/TED/"/>
    
      <category term="Speech" scheme="http://uegeek.com/tags/Speech/"/>
    
      <category term="演讲" scheme="http://uegeek.com/tags/%E6%BC%94%E8%AE%B2/"/>
    
      <category term="兴趣" scheme="http://uegeek.com/tags/%E5%85%B4%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作05-Tessellation</title>
    <link href="http://uegeek.com/181107-generative-art-creativity-05.html"/>
    <id>http://uegeek.com/181107-generative-art-creativity-05.html</id>
    <published>2018-11-07T13:13:18.000Z</published>
    <updated>2018-11-07T13:27:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></li><li><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></li><li><a href="https://www.uegeek.com/181021-generative-art-creativity-03.html" target="_blank" rel="noopener">生成式艺术和算法创作03-混沌和分形</a></li><li><a href="https://www.uegeek.com/181023-generative-art-creativity-04.html" target="_blank" rel="noopener">生成式艺术和算法创作04-规则系统</a></li></ul><p>Tessellation（密铺/镶嵌/平面填充）或称细分曲面（subdivision surface），是指用一些较小的表面填满（tiling）一个较大的表面而不留任何空隙。在数学上，Tessellation 可以推广到更高的维度，称为空间填充。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Leeuwarden_-_Tegeltableau_Escher.jpg/580px-Leeuwarden_-_Tegeltableau_Escher.jpg" alt=""></p><p>A wall sculpture in <a href="https://www.wikiwand.com/en/Leeuwarden" target="_blank" rel="noopener">Leeuwarden</a> celebrating the artistic tessellations of <a href="https://www.wikiwand.com/en/M._C._Escher" target="_blank" rel="noopener">M. C. Escher</a></p><p>在几何学中，两块相邻 tiles 的边界叫做 edge，三个或更多 tiles 的交点叫做 vertex。平面密铺分为规则和不规则两种，规则镶嵌即重复组合一种或多种不同的图形，具有周期性的重复模式。由正多边形组成的可以分为正镶嵌、半正镶嵌（Demiregular Tessellation）和不均匀半正镶嵌和复合多边形镶嵌等种类。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/Academ_Periodic_tiling_by_hexagons_and_other_regular_polygons.svg/240px-Academ_Periodic_tiling_by_hexagons_and_other_regular_polygons.svg.png" alt=""></p><p>通过两个或多个凸规则多边形对平面进行细分，使得相同顺序的相同多边形围绕每个多边形顶点称为半规则 Tessellation，或者有时称为阿基米德曲面细分：</p><p><img src="http://mathworld.wolfram.com/images/eps-gif/SemiregularTessellations_700.gif" alt=""></p><p>有 14 个单向 Tessellation 是三个常规和八个半规则镶嵌的有序组合：</p><p><img src="http://mathworld.wolfram.com/images/eps-gif/DemiregularTessellations_600.gif" alt=""></p><p>有规律的填充形成的图案，可分为 17 组。你没有看错，是总共只有 17 组，详细的介绍请见 <a href="https://www.wikiwand.com/en/Wallpaper_group" target="_blank" rel="noopener">Wallpaper group</a>，感觉有必要单开一篇来专门研究。</p><p><img src="http://img.viz.mobi/Overview%20of%20wallpaper%20groups.png" alt=""></p><p>缺乏重复图案的密铺称为非周期平铺（Non-periodic/Aperiodic）。非周期平铺使用一些较小的表面来填满一个较大的表面而不留任何空隙，但由于每一片的形状皆不相同，以致无法形成重复图案。</p><p>另外，也存在非欧几里得空间的密铺，如正七边形镶嵌、七阶三角形镶嵌等。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/H2_tiling_237-4.png/240px-H2_tiling_237-4.png" alt=""></p><p>在三维成像中也会使用 Tessellation 快速生成 3D 成像的小三角形。可以使用 GPU 通过 Programmable Tessellator 实现细分曲面，使得渲染对象的表面和边缘更平滑，物件呈现更为精细。</p><p>（写到这里只有一个感受：需要完全重修几何学和计算机图形学……）</p><p><img src="http://tessellations.org/tgp-seth/angry-birds-tessellation.jpg" alt=""></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Tessellation" target="_blank" rel="noopener">Tessellation - Wikiwand</a></li><li><a href="http://mathworld.wolfram.com/Tessellation.html" target="_blank" rel="noopener">Tessellation – from Wolfram MathWorld</a></li><li><a href="https://www.mathsisfun.com/geometry/tessellation.html" target="_blank" rel="noopener">Tessellation</a></li><li><a href="https://www.wikiwand.com/en/Wallpaper_group" target="_blank" rel="noopener">Wallpaper group - Wikiwand</a></li></ul><p>二次搬运 Wolfram 的 Reference：</p><ul><li>Ball, W. W. R. and Coxeter, H. S. M. <em>Mathematical Recreations and Essays, 13th ed.</em> New York: Dover, pp. 105-107, 1987.</li><li>Bhushan, A.; Kay, K.; and Williams, E. “Totally Tessellated.” <a href="http://library.thinkquest.org/16661/" target="_blank" rel="noopener">http://library.thinkquest.org/16661/</a>.</li><li>Britton, J. <em>Symmetry and Tessellations: Investigating Patterns.</em> Englewood Cliffs, NJ: Prentice-Hall, 1999.</li><li>Critchlow, K. <em>Order in Space: A Design Source Book.</em> New York: Viking Press, 1970.</li><li>Cundy, H. and Rollett, A. <em>Mathematical Models, 3rd ed.</em> Stradbroke, England: Tarquin Pub., pp. 60-63, 1989.</li><li>Gardner, M. <em>Martin Gardner’s New Mathematical Diversions from Scientific American.</em> New York: Simon and Schuster, pp. 201-203, 1966.</li><li>Gardner, M. “Tilings with Convex Polygons.” Ch. 13 in <em>Time Travel and Other Mathematical Bewilderments.</em> New York: W. H. Freeman, pp. 162-176, 1988.</li><li>Ghyka, M. <em>The Geometry of Art and Life.</em> New York: Dover, 1977.</li><li>Kraitchik, M. “Mosaics.” §8.2 in <em>Mathematical Recreations.</em> New York: W. W. Norton, pp. 199-207, 1942.</li><li>Lines, L. <em>Solid Geometry, with Chapters on Space-Lattices, Sphere-Packs, and Crystals.</em> New York: Dover, pp. 199 and 204-207 1965.</li><li>Pappas, T. “Tessellations.” <em>The Joy of Mathematics.</em> San Carlos, CA: Wide World Publ./Tetra, pp. 120-122, 1989.</li><li>Peterson, I. <em>The Mathematical Tourist: Snapshots of Modern Mathematics.</em> New York: W. H. Freeman, p. 75, 1988.</li><li>Radin, C. <em>Miles of Tiles.</em> Providence, RI: Amer. Math. Soc., 1999.</li><li>Rawles, B. <em>Sacred Geometry Design Sourcebook: Universal Dimensional Patterns.</em> Nevada City, CA: Elysian Pub., 1997.</li><li>Steinhaus, H. <em>Mathematical Snapshots, 3rd ed.</em> New York: Dover, pp. 75-76 and 78-82, 1999.</li><li>Vichera, M. “Archimedean Polyhedra.” <a href="http://www.vicher.cz/puzzle/telesa/telesa.htm" target="_blank" rel="noopener">http://www.vicher.cz/puzzle/telesa/telesa.htm</a>.</li><li>Walsh, T. R. S. “Characterizing the Vertex Neighbourhoods of Semi-Regular Polyhedra.” <em>Geometriae Dedicata</em> <strong>1</strong>, 117-123, 1972.</li><li>Weisstein, E. W. “Books about Tilings.” <a href="http://www.ericweisstein.com/encyclopedias/books/Tilings.html" target="_blank" rel="noopener">http://www.ericweisstein.com/encyclopedias/books/Tilings.html</a>.</li><li>Wells, D. <em>The Penguin Dictionary of Curious and Interesting Geometry.</em> London: Penguin, pp. 121, 213, and 226-227, 1991.</li><li>Williams, R. <em>The Geometrical Foundation of Natural Structure: A Source Book of Design.</em> New York: Dover, pp. 35-43, 1979.</li><li>Woo, M.; Neider, J.; Davis, T.; and Shreiner, D. Ch. 11 in <em>OpenGL 1.2 Programming Guide, 3rd ed.: The Official Guide to Learning OpenGL, Version 1.2.</em> Reading, MA: Addison-Wesley, 1999.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="Tessellation" scheme="http://uegeek.com/tags/Tessellation/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作04-规则系统</title>
    <link href="http://uegeek.com/181023-generative-art-creativity-04.html"/>
    <id>http://uegeek.com/181023-generative-art-creativity-04.html</id>
    <published>2018-10-23T11:32:35.000Z</published>
    <updated>2018-10-23T11:36:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></li><li><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></li><li><a href="https://www.uegeek.com/181021-generative-art-creativity-03.html" target="_blank" rel="noopener">生成式艺术和算法创作03-混沌和分形</a></li></ul><h2 id="规则系统"><a href="#规则系统" class="headerlink" title="规则系统"></a>规则系统</h2><blockquote><p>In computer science, rule-based systems are used as a way to store and manipulate knowledge to interpret information in a useful way. –Wiki</p></blockquote><p>规则系统（rule-based systems）的类型：</p><ul><li>生成语法和乔姆斯基等级（乔姆斯基在20世纪50年代提出）</li><li>形式逻辑系统和逻辑程序：推理规则，定理求解程序，论证系统，案例推理系统</li><li>专家系统：将特定领域的专业知识，编码在可以执行演绎和归纳的框架中</li><li>跃迁过程网络（Transition-based networks）：有限状态自动机（finite state automata）和扩展随机系统（extension stochastic systems）如马尔可夫模型，马尔可夫链，以及隐马尔可夫模型</li></ul><p><img src="https://cdn-ed.haymarketbooks.org/images/000001/149/Noam_Chomsky_(c" alt="">_Don_Usner-f_large-863c2ffef0e17c5b6fa999586cc0419d.jpg)</p><p>乔姆斯基（C.Chomsky）最初从产生语言的角度研究语言；他将语言 L 形式地定义为由一个字母表中的字母 ∑ 组成的一些串的集合 <img src="https://www.zhihu.com/equation?tex=%5Cforall+L%2C+%5Cexists+%5CSigma%2C+L%5Csubseteq+%5CSigma%5E%2A" alt="\forall L, \exists \Sigma, L\subseteq \Sigma^*"> ，可以在字母表上按照一定的规则定义一个方法，该文法产生的所有句子组成的集合，就是该文法产生的语言。形式语言是模拟这些语言的一类数学语言，它采用数学符号，按照严格的语法规则构成。</p><p>那么，到底什么是规则呢？</p><blockquote><p>α→β</p></blockquote><p>α 和 β 是由终结符（terminal symbol 如名词、动词等）或非终结符（如句子、动词短语、名词短语等）组成的表达式。</p><h2 id="生成文法"><a href="#生成文法" class="headerlink" title="生成文法"></a>生成文法</h2><p>生成文法（generative grammar）尝试给出一套规则，能正确的预测在一种语言中怎样的词汇组合能成为正确的句子，这些规则通常也能预测句子中的构词法。生成文法可以借助<a href="https://www.wikiwand.com/en/Chomsky_hierarchy" target="_blank" rel="noopener">乔姆斯基等级</a>来描述和比较。</p><p>文法 G 是一个四元组：G =（V, T, P, S）</p><ul><li>V：变量/非终结符号的非空有穷集；</li><li>T：终结符的非空有穷集，V∩T=Ø；</li><li>P：生成式的非空有穷集合；</li><li>S：开始符号，S 是 V 中的元素。</li></ul><p>P 生成式的基本形式是 α→β，这里 α 和 β 都是（V∪T）中的元素，即它们都是由变元和终结符组成的符号串，但要求 α 至少含有一个非终结符；在形式文法定义中 P 至关重要，它决定了语言是如何构造出来的。</p><p>根据 P 中生成式 α→β 的特点，可以将形式文法及其产生的形式语言分类，构成形式语言谱系，对应四种自动机：</p><ul><li><p>0 型文法，又称为短语文法：对生成式 α→β 不作特殊限制，α 和 β 可以是任意的文法符号串，当然 α 不能是空字符串；0 型文法是形式语言谱系中最大的文法类，是图灵机所识别的语言类，即递归可枚举语言。</p></li><li><p>1 型文法，又称为上下文有关文法：要求生成式 α→β 满足 |α|≤|β|，即 β 要至少和 α 一样长；由 1 型文法产生的语言称为 1 型语言或上下文有关语言，是非确定型线性有界自动机所识别的语言类。</p></li><li><p>2 型文法，又称为上下文无关文法（context-free grammars ）：要求生成式 α→β 中的 α 必须是变元；由 2 型文法产生的语言称为 2 型语言或上下文无关语言，是由下推自动机所识别的语言类。</p></li><li><p>3 型文法，又称为正则文法，这种文法分为两种类型：生成式的形式必须是 A→ωB 或 A→ω，其中 A，B 都是变元，ω 是终结符串（可以是空串），这种特殊的正则文法称为右线性文法；第二类正则文法称为左线性文法，它要求生成式必须是 A→Bω，或 A→ω 的形式。由正则文法生成的语言称为正则语言，它是有穷自动机所识别的语言类。</p></li></ul><p>上述定义的 4 种语言类具有依次包含关系，即对于 i＝0，1，2，在不考虑空字符串时，i 型语言都真包含 i＋1 型语言。</p><p>通过这种语法推导出的句子可以用派生树描述。相邻的单词被组合成成分，可以进一步与其他单词或成分组合以创建分层树结构。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Basic_english_syntax_tree.svg/300px-Basic_english_syntax_tree.svg.png" alt=""></p><p>看着很晕吧？…… 我们还是来看一些艺术创作领域的例子吧！</p><p>法国诗人雷蒙·格诺 (Raymond Queneau) 是国际文学团体乌力波（Oulipo, Ouvroir de littérature potentielle, 潜在文学工场）的创始人，其会员中名气较大的有意大利作家卡尔维诺（Italo Calvino），法国作家乔治·佩雷克（Georges Perec），此外还有一些成员是和文学不搭边的数学家。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Ambigramme_Oulipo_%28bold_pencil%29.png/300px-Ambigramme_Oulipo_%28bold_pencil%29.png" alt=""></p><p>Raymond Queneau 的诗集「百万亿首诗」(Cent mille milliards de poèmes) 是一本不寻常的诗集：表面上看这本书是由 10 首十四行诗构成，10 首诗的同一行都押同一个韵，实际上它能排列组合成一百万亿首诗。首行诗句有 10 种选择，第二行诗句也有 10 种选择，十四行诗组合在一起也就得到了 10 的 14 次方首各不相同的诗了。</p><p>诗集的设计也很特别，每一行都被剪成纸条，读完第一首诗的第一行，然后把第二行的纸条折过去读第二首诗的第二行，以此类推……这便是一个语法生成系统了。</p><p><img src="http://www.greenchairpress.com/blog/wp-content/uploads/2014/08/queneau.png" alt=""></p><h2 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h2><p>最简单的来说，自动机（Automaton）就是具有离散输入输出的数学模型，接受一定的输入，执行一定的动作，产生一定的结果。</p><p>状态是一个标识，能区分自动机在不同时刻的状况。可以使用状态迁移描述整个工作过程。有限状态系统具有任意有限数目的内部状态。自动机的本质是，<strong>根据状态、输入和规则决定下一个状态，即</strong></p><blockquote><p>状态 ＋ 输入（激励）＋ 规则 → 状态迁移</p></blockquote><p>可能的状态、运行的规则都是事先确定的。一旦开始运行，就按照事先确定的规则工作，因此叫自动机。</p><p>根据结构不同，自动机又可分为：</p><ul><li>有限自动机，可以认为是由一个带有读头的有限控制器和一条写有字符的输入带组成；</li><li>下推自动机，可以看作是由一条输入带、一个有限控制器和一个下推栈组成；</li><li>基本图灵机，由一个具有读写头的有限控制器和一条无限带组成</li></ul><p>在这个系列的后续文章中，还会单独来讲讲元胞自动机。</p><h2 id="Transition-network"><a href="#Transition-network" class="headerlink" title="Transition network"></a>Transition network</h2><p>Transition Networks 是一系列有限状态自动机。</p><p>如果用有向图表示，节点表示状态，边缘表示转换过程。每一个自动机表示一个非终结符；每一个转换过程产生一个非终结符或终结符。</p><p><img src="http://img.viz.mobi/eg-transition-network.png" style="zoom:50%"></p><p>Augmented transition networks (ATN) 是一种形式语言操作化定义的图论结构。ATN 建立在使用有限状态机来解析句子的基础上，它理论上可以分析任何句子的结构，无论多么复杂。ATN 的一个优点是延迟决策——当模糊性出现时，许多语法会在对句子的了解还不够时进行猜测。而 ATN 使用递归来推迟决定，直到对句子了解得更多。</p><p>算法作曲的先驱 David Cope 创作的 EMI 是著名的和开创新的系统。EMI 使用了 ATN，由系统分析和分割给定的语料库，然后重新组合元素。<br><img src="/Users/kidult00/Downloads/Courses/Kadenze/generative-art-and-computational-creativity-i/3-rule-based-systems-grammars-and-markov-chains/David%20Cope%20EMI%20ATN.png" alt="David Cope EMI ATN"></p><p>在这里，终结符是各种音乐片段，非终结符元素则捕捉各种层级的片段结构。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Rule-based_system" target="_blank" rel="noopener">Rule-based system - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Generative_grammar" target="_blank" rel="noopener">Generative grammar - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Context-free_grammar" target="_blank" rel="noopener">Context-free grammar - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Oulipo" target="_blank" rel="noopener">Oulipo - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Automaton" target="_blank" rel="noopener">Automaton - Wikiwand</a></li><li><a href="https://book.douban.com/subject/24089566/" target="_blank" rel="noopener">乌力波（2） (豆瓣)</a></li><li><a href="https://zhuanlan.zhihu.com/p/28624160" target="_blank" rel="noopener">形式语言与自动机</a></li><li><a href="http://artsites.ucsc.edu/faculty/cope/experiments.htm" target="_blank" rel="noopener">EMI</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="规则系统" scheme="http://uegeek.com/tags/%E8%A7%84%E5%88%99%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作03-混沌和分形</title>
    <link href="http://uegeek.com/181021-generative-art-creativity-03.html"/>
    <id>http://uegeek.com/181021-generative-art-creativity-03.html</id>
    <published>2018-10-21T12:11:30.000Z</published>
    <updated>2018-10-21T12:20:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><p><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></p><p><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Lorenz_attractor_yb.svg/800px-Lorenz_attractor_yb.svg.png?1538707261695" style="zoom:50%"></p><h2 id="动态系统"><a href="#动态系统" class="headerlink" title="动态系统"></a>动态系统</h2><p>动态系统（dynamical system）是数学上的一个概念，是一种固定的规则，它描述一个给定空间中所有点随着时间变化的情况，例如运动的钟摆、弹跳的球、管道中水的流动等。</p><p>动态系统的行为可以分为四类：</p><ul><li>Fixed point behavior (equilibrium)：固定（平衡）行为</li><li>Limit cycle or periodic behavior：循环或周期行为</li><li>Quasi-periodic behavior：准周期行为</li><li>Chaotic behavior：混沌行为</li></ul><p><strong>虽然动态系统是可以确定的，但是一旦输入发生微小改变，结果都会变得难以预测。混沌系统短期、局部可预测，长期、全局不可预测的特点，让它成为算法创作中常用的手段。</strong></p><p><img src="http://sprott.physics.wisc.edu/pubs/354fig01.gif" alt=""></p><p>via Generalization of the simplest autonomous chaotic system</p><p>单峰映象（logistic map）是一个二次的多项式映射，是由简单非线性方程式产生<a href="https://www.wikiwand.com/zh/%E6%B7%B7%E6%B2%8C%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">混沌</a>现象的经典范例。</p><p>这种映射因生物学家 Robert May 在 1976 年发表的一篇论文而著名。公式为 $$x_{n+1}=rx_n(1-x_n)$$。对于任一个 r 值，最多只有一个稳定的极限环，若稳定极限环存在，几乎所有的点最后都会趋近极限。这些情况可用分枝图表示，分枝图中的横轴是 r 的数值，纵轴中显示大部份初值下稳态可能的 x 值，若数值在 2 个值中震荡，分枝图上对应的数值就会有 2 个点。若某 r 值已无法明确有几个对应的点，系统可能已经处于混沌状态。</p><p>分枝图有自相似的特性。若将分枝图中 r=3.82 的部份展开，只取三个分支中的一个，图形会好像是原分枝图缩放及扭曲后的结果。所有非混沌的参数 r 都有此一特性。可以看出混沌和分形的关系。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/7/7d/LogisticMap_BifurcationDiagram.png" alt=""></p><p>吸引子（attractor）是微积分和系统科学论中的一个概念。一个系统有朝某个稳态发展的趋势，这个稳态就叫做吸引子。</p><p>吸引子分为平庸吸引子和奇异吸引子。例如一个钟摆系统有一个平庸吸引子，这个吸引子使钟摆系统向停止晃动的稳态发展。平庸吸引子有不动点（平衡）、极限环（周期运动）和整数维环面（概周期运动）三种模式。不属于平庸的吸引子的都称为奇异吸引子，它表现了混沌系统中非周期性，无序的系统状态，例如天气系统。目前吸引子在学术上还没有完善的定义，奇异吸引子对于<a href="https://www.wikiwand.com/zh/%E6%B7%B7%E6%B2%8C%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">混沌系统</a>的研究意义重大。</p><p>混沌理论的思想也从上世纪后半叶开始，逐渐渗入到音乐和作曲领域。</p><p>1960 年 George Brecht 在滴水事件（drip event）中，使不同来源的水，滴进所有空的容器。这个作品可以被视为音乐、剧场、或者是动态雕塑。</p><p><img src="https://www.moma.org/media/W1siZiIsIjMwNDk2NSJdLFsicCIsImNvbnZlcnQiLCItcmVzaXplIDIwMDB4MjAwMFx1MDAzZSJdXQ.jpg?sha=74b38f4f98552501" alt=""></p><p>Brecht 的极简主义艺术活动是神秘费解、令人困惑的，这些作品及其配乐为观众设计成仅在想象的范围内可被解读与激活。滴水音乐（drip music）由此形成，指可由单个或多个表演者演出单一滴水水源与一个空的容器，通过设置使水滴入容器中。Drip music 很快就成为激浪派（fluxus）的标志，flux 一词本身不仅指持续的运动与改变，也指流体与流动，或更精确的是一个流体的流动速度。</p><p>80 年代，混沌理论开始被应用在作曲中。它适用于音高、持续时间、动态范围和编排。它们很容易产生重复，以及周期性/准周期性模型变化，或者在混沌模式下产生更多不可预测的行为，而重复、变化、convergence 和 divergence 是音乐作曲里的关键要素。</p><h2 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h2><p>分形是一个可以分成数个部分的几何形状，且每一部分都（至少近似地）是整体缩小后的形狀，即具有<a href="https://www.wikiwand.com/zh/%E8%87%AA%E7%9B%B8%E4%BC%BC" target="_blank" rel="noopener">自相似</a>的性质。分形也被称为扩展对称或展开对称。如果在每次放大后，形状的重复是完全相同的，被称为自相似。作为一个数学函数，分形通常是处处不可微的。无穷分形曲线可以理解为一条一维的曲线在空间中绕行。</p><blockquote><p>Fractals are mathematical dynamic systems represented by iterative equations that develop curves and geometrical shapes that have property of self-similarity. </p></blockquote><p>Sierpinski 三角是典型的自相似分形图形。1915 年由波兰数学家 Wacław Franciszek Sierpiński 提出。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a8/Sierpinski_triangle_%28blue%29.jpg" alt=""></p><p>算法：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/Sierpinski_triangle_evolution.svg/1024px-Sierpinski_triangle_evolution.svg.png" alt=""></p><ol><li>取一个实心的三角形（多数使用等边三角形）</li><li>沿三边中点的连线，将它分成四个小三角形</li><li>去掉中间的那一个小三角形</li><li>对其余三个小三角形重复第 1 步</li></ol><p>Sierpinski 三角可由分型树产生：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a9/Fractal_tree.gif" alt=""></p><p>分形算法已经被广泛用于生成式艺术创作中。</p><p>Bogdan Soban 是斯洛文尼亚的信息学专家和软件开发者，退休后作为自由艺术家从事创作。他从 1999 年开始接触生成式艺术，开始编写基于算法的生成式艺术软件用于创作。</p><p><img src="http://www.soban-art.com/images/naslovnica.jpg" alt=""></p><p>Paul DeCelle 用 Frederik Slijkerman 开发的 <a href="http://www.ultrafractal.com/" target="_blank" rel="noopener">Ultra Fractal</a> 创作了一些列作品：</p><p><img src="http://www.submit.manscostyle.com/submit/130_Image9.jpg" alt=""></p><p><img src="https://www.fractalus.com/paul/20071022-kesius.jpg" alt=""></p><p>Etienne Saint Amant 是来自加拿大魁北克省舍布鲁克的艺术家。他专注于用数学语言设计和描述的大幅艺术品，致力于概念研究和当代艺术创作。</p><p><img src="https://t00.deviantart.net/AIQ7rP3wX0CLZ0sC29rhgA1QBZE=/fit-in/700x350/filters:fixed_height(100,100" alt="">:origin()/pre00/ae50/th/pre/i/2005/136/1/4/rakis_by_etiennesaintamant.jpg)</p><p><img src="https://chaoscopia.com/artworks/m20180926-13.jpg" alt=""></p><p>一些分形艺术的软件：</p><ul><li><a href="https://www.ultrafractal.com/" target="_blank" rel="noopener">Ultra Fractal: Advanced Fractal Software for Windows and macOS</a></li><li><a href="http://fract.al/" target="_blank" rel="noopener">Frax - Immerse, Create, Inspire</a> </li><li><a href="https://mandelbulber.com/" target="_blank" rel="noopener">Laravel</a></li><li><a href="http://www.fractal-explorer.com/" target="_blank" rel="noopener">Fractal Explorer</a></li><li><a href="http://www.apophysis.org/" target="_blank" rel="noopener">Apophysis.org</a></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Dynamical_system" target="_blank" rel="noopener">Dynamical system - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Attractor" target="_blank" rel="noopener">Attractor - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Logistic_map" target="_blank" rel="noopener">Logistic map - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh/%E5%88%86%E5%BD%A2" target="_blank" rel="noopener">分形 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Sierpinski_triangle" target="_blank" rel="noopener">Sierpinski triangle - Wikiwand</a></li><li><a href="http://sprott.physics.wisc.edu/pubs/paper354.htm" target="_blank" rel="noopener">Generalization of the Simplest Autonomous Chaotic System</a></li><li><a href="https://www.moma.org/collection/works/127310?artist_id=756&amp;locale=zh&amp;page=1&amp;sov_referrer=artist" target="_blank" rel="noopener">Poul Hansen, George Brecht, Dick Higgins. George Brecht’s Drip Music, performed by Dick Higgins during Fluxus/Musik og Anti-Musik/det Instrumentale Teater, Nikolai Kirke, Copenhagen, November 23, 1962. 1962 | MoMA</a></li><li><a href="http://www.soban-art.com/index-ang.asp" target="_blank" rel="noopener">Generative Art - generated, artificial, random, software</a></li><li><a href="https://www.fractalus.com/paul/" target="_blank" rel="noopener">Fractal Art by Paul DeCelle</a></li><li><a href="https://chaoscopia.com/nouveautes_en.html" target="_blank" rel="noopener">chaoscopia - news</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="混沌" scheme="http://uegeek.com/tags/%E6%B7%B7%E6%B2%8C/"/>
    
      <category term="分形" scheme="http://uegeek.com/tags/%E5%88%86%E5%BD%A2/"/>
    
      <category term="Chaotic" scheme="http://uegeek.com/tags/Chaotic/"/>
    
      <category term="Fractal" scheme="http://uegeek.com/tags/Fractal/"/>
    
  </entry>
  
  <entry>
    <title>算法创作实战02 - 用 MaxMSP 生成随机颜色</title>
    <link href="http://uegeek.com/181021-computational-creativity-in-maxmsp-02.html"/>
    <id>http://uegeek.com/181021-computational-creativity-in-maxmsp-02.html</id>
    <published>2018-10-21T11:13:58.000Z</published>
    <updated>2018-10-21T11:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-title1.jpg" alt=""></p><a id="more"></a><p>在「生成式艺术和算法创作」系列第二篇中，00 <a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">介绍了随机和噪声在算法创作中的应用</a>。上一篇我们<a href="https://www.uegeek.com/181017-computational-creativity-in-maxmsp-01.html" target="_blank" rel="noopener">用 Max/MSP 做了一个随机生成星座描述的小应用</a>，切身实践和感受了巴纳姆效应。</p><p>今天我们一起来用 Max/MSP 实现简单的随机颜色生成器，加深对 Max/MSP 中 <code>random</code> 对象的了解。</p><blockquote><p>名称：Random Color</p><p>主要使用的对象：random, send, receive, uzi, pack, jit.matrix, jit.pwindow</p><p>难度系数：★☆☆☆☆</p></blockquote><p>这个程序叫 Random Color，可以指定行（y）和列（x）的数量，然后用随机颜色填充，可以手动生成新的图像，也可以自动连续生成。生成的图像可以导出成图片。最后的成果是这样：</p><p><img src="http://img.viz.mobi/RandomColor.png" alt=""></p><p>首先来拆解需要实现的功能：</p><ul><li>手动生成或者自动连续生成</li><li>指定图像的尺寸(dim)</li><li>生成随机颜色</li><li>自动填充每一个单元格</li><li>显示图像</li><li>导出图片</li></ul><p>开始动手前，请复习 Max/MSP 文档中 random, send, receive, uzi, pack, jit.matrix, jit.pwindow 等对象的说明。</p><p>准备就绪后，我们先来看前两步如何实现：</p><p><img src="http://img.viz.mobi/RandomColorPatch-1.png" alt=""></p><p><strong>1.手动生成或者自动连续生成</strong></p><p>用 <code>button</code> 触发生成事件，前面加上 <code>metro</code> 对象并指定时间间隔就可以自动连续触发生成事件。</p><p><strong>2.指定图像的尺寸(dim)</strong></p><p>设置两个整数数字框，可以输入水平和垂直维度的数量，来指定图像的尺寸。</p><p>生成事件的 bang、x 和 y 的数值，都通过 <code>send</code>(简写为 s) 对象传递到后面的步骤。</p><p>接下来是关键的部分，用随机颜色自动填充每一个单元格：</p><p><img src="http://img.viz.mobi/RandomColorPatch-2.png" alt=""></p><p><strong>3.生成随机颜色</strong></p><p>用 3 个<code>random</code> 对象分别生成 R G B 三个颜色值，然后用 <code>pack</code> 对象打包起来。因为最后需要用 <code>jit.pwindow</code> 显示图像，它需要接收 ARGB 颜色，所以我们还需要用 <code>setcell</code> 消息指定需要填充的单元格，并且传递 255 作为 ARGB 的 Alpha 值。于是，pack 对象的参数需要写成：<code>pack setcell 0 0 val 255 0 0 0</code>。其中，前面两个 0  会传入之前通过数字框输入的 x 和 y 的垂直和水平 dim 值，后面 3 个 0 会传入由 <code>random</code> 对象生成的 GRB 值。</p><p><strong>4.自动填充每一个单元格</strong></p><p>编程中经常使用 for 循环来实现矩阵的填充，在 MaxMSP 里常用 <code>uzi</code> 对象来实现简单的循环效果。（当然，如果是 modern 的矩阵处理和运算，会用 jit 提供的丰富的矩阵功能；这里我们怀旧一下用 uzi）<code>uzi</code> 的作用是连续发出 bang，左入口接收触发命令，右入口接收连续 bang 的数量；左出口输出 bang，中出口输出完成所有 bang 后的消息，右出口输出当前是第几个 bang。</p><p>首先接收 y 维度的值，用 1 个 <code>uzi</code> 作为外层循环。因为 <code>uzi</code> 对象从 1 开始计数，所以需要减去 1 再传给 <code>setcell</code>，因为矩阵单元格从 0  开始计数。然后接收 x 维度的值，作为内层循环（同样要减去 1）。</p><p><code>uzi</code> 和 <code>random</code> 生成的矩阵单元格位置和颜色都传给 <code>pack</code> 对象打包。</p><p>最后是显示和导出图像：</p><p><img src="http://img.viz.mobi/RandomColorPatch-3.png" alt=""></p><p><strong>5.显示图像</strong></p><p>使用 <code>jit.matrix</code> 存储并显示矩阵，更多 <code>jit.matrix</code> 的用法请参考 <a href="https://www.uegeek.com/tags/Max-MSP/" target="_blank" rel="noopener">00  翻译的 Max/MSP/Jitter 官方教程系列</a>。</p><p>指定矩阵为 4 个平面（plane），用 <code>receive</code> 对象（简写为 r）接受 x 和 y 维度的值。为了实时响应维度修改的操作，这里用 <code>pak</code> 对象而不是 <code>pack</code> 对象。<code>pak</code> 对象响应任一一个输入的变化，而 <code>pack</code> 对象需要由 bang 触发何时响应。</p><p>另外，使用一直开启的 <code>qmetro</code> 对象（@active 属性为 1）来监控矩阵的变化，以便随时更新，将矩阵值通过 <code>send</code> 对象发送给 <code>jit.pwindow</code> 中显示。</p><p><strong>6.导出图片</strong></p><p>用 <code>exportimage</code> 消息可以触发 <code>jit.matrix</code> 导出图像保存。因为矩阵的初始尺寸是 10x10，所以最后用了一个 <code>jit.matrix 4 char 400 400</code> 将矩阵扩大为 400x400 的尺寸，这样导出的图像大小就是 400x400 像素。</p><p><img src="http://img.viz.mobi/randomColorExport.png" alt=""></p><p>完整的 patch 如下：</p><p><img src="http://img.viz.mobi/RandomColorPatch.png" alt=""></p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-title1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="随机" scheme="http://uegeek.com/tags/%E9%9A%8F%E6%9C%BA/"/>
    
      <category term="MaxMSP" scheme="http://uegeek.com/tags/MaxMSP/"/>
    
  </entry>
  
  <entry>
    <title>算法创作实战01 - 巴纳姆效应之随机星座实验</title>
    <link href="http://uegeek.com/181017-computational-creativity-in-maxmsp-01.html"/>
    <id>http://uegeek.com/181017-computational-creativity-in-maxmsp-01.html</id>
    <published>2018-10-17T10:22:16.000Z</published>
    <updated>2018-10-17T11:37:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-title1.jpg" alt=""></p><a id="more"></a><p>在「生成式艺术和算法创作」系列第二篇中，00 <a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">介绍了随机和噪声在算法创作中的应用</a>。</p><p>今天我们一起来用 Max/MSP 实现一个半（hu）仙（shuo）算（ba）命（dao）小应用，加深对 Max/MSP 中 <code>random</code> 对象的了解，并且学习如何使用 <code>coll</code> 对象。</p><blockquote><p>名称：麦克斯半仙儿（又名 Random Bullshit）</p><p>主要使用的对象：random, coll, route, jit.cellblock, fpic</p><p>难度系数：★☆☆☆☆</p></blockquote><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><a href="https://www.wikiwand.com/zh-hans/%E5%B7%B4%E7%B4%8D%E5%A7%86%E6%95%88%E6%87%89" target="_blank" rel="noopener">巴纳姆效应（Barnum effect）</a>是 1948 年由心理学家伯特伦·福勒通过试验提出的一种心理学现象，以杂技师巴纳姆的名字命名。巴纳姆效应是一种心理现象，人们会对他们认为是为自己量身订做的一些人格描述，给予高度准确的评价，而这些描述往往十分模糊及普遍，以致能够放诸四海皆准适用于很多人身上。</p><p>据说巴纳姆的成功秘诀是：「永远要让每一个观众都感到自己若有所获」。意思如果要让每一个人都能感到对自己个性的描述是准确的，就要去提供一些放之四海而皆准的描述。看手相、算命、占星术及其他伪心理学经常利用这种效应，怎么说都能让你听着有点儿道理。于是有人将十二星座的描述随机排列，发现不同星座的描述基本上可以适用于其他星座。</p><p>所以今天我们来实践一下这个想法，看看程序随机给出的星座描述，有没有戳中你 🌝。</p><h2 id="任务拆解"><a href="#任务拆解" class="headerlink" title="任务拆解"></a>任务拆解</h2><p>这个程序叫麦克斯半仙儿，用户选择自己的星座后，程序给出描述。最后的成果是这样：</p><p><img src="http://img.viz.mobi/BarnumEffectDemo.gif" alt=""></p><p>首先来拆解需要干的事儿：</p><ul><li>收集十二星座的简短描述和图标</li><li>存储文本，方便随机调用</li><li>12 星座的选择控件</li><li>显示结果（包括加载默认值）</li></ul><p>开始动手前，请复习 Max/MSP 文档中 random, coll, route, jit.cellblock, fpic 等对象的说明。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>这个小程序的核心是用 <code>random</code> 对象随机显示 <code>coll</code> 对象中存储的内容。<code>coll</code> 即 collection，用来存储一个列表，列表中每一项都包含 key 和 value（中间用 ， 隔开），可以通过 key 获取对应的 value。value 可以是单个值，也可以是以空格分隔的多个值。</p><p>在 Max 中新建名字为 blah 的 <code>coll</code> 对象，双击（或者 cmd+点击）打开，填入我们在网上找到的十二星座描述内容，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0, 你大方、明朗，全身充滿活力……;</span><br><span class="line">1, 你不但好學、知識豐富，還很……;</span><br><span class="line">2, 嗯，你善於說服別人，還是個……;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>十二个星座描述的索引是从 0~11，所以在 <code>coll</code> 前用一个 <code>random</code> 对象随机选取其中一个星座的描述，然后从 <code>coll</code> 的左出口输出。因为我们存储的是文本内容（symbol），所以需要用一个 <code>route</code> 对象读取 symbol 内容，并发送到显示区域。</p><p><img src="http://img.viz.mobi/BarnumEffect-coll.png" alt=""></p><p>如果不想每次双击打开 <code>coll</code> 查看，可以用 <code>refer 名字</code> 消息连接一个 <code>jit.cellblock</code> 查看 <code>coll</code> 里面的内容。</p><p>随机调用的内容准备就绪后，接下来是选择星座的界面：</p><p><img src="http://img.viz.mobi/BarnumEffect-ui.png" alt=""></p><p>用 <code>fpic</code> 显示星座图标，在上面覆盖一个 <code>button</code> 对象，将按钮背景设置为透明。然后将按钮连接到 <code>random</code> 对象，读取 <code>coll</code> 的内容。</p><p>因为想显示每次选择的星座名称，所以每个按钮连接了一个包含对应星座名称的 <code>message</code> ，点击按钮时可以触发显示在内容区域。其实用 <code>radio group</code> 对象能更好实现，但是它的 UI 不好自定义，就放弃了。</p><p>完整的 patch 如下：</p><p><img src="http://img.viz.mobi/BarnumEffectPatch.png" alt=""></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>程序做好以后，随机生成了几个描述，发到朋友圈，让大家猜这些描述原本对应的是什么星座。</p><p>结果是——没有全部猜对的，哈哈哈！应该给撰写星座描述的小编加🍗~</p><p>下一期实战见~</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-title1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="随机" scheme="http://uegeek.com/tags/%E9%9A%8F%E6%9C%BA/"/>
    
      <category term="MaxMSP" scheme="http://uegeek.com/tags/MaxMSP/"/>
    
      <category term="巴纳姆效应" scheme="http://uegeek.com/tags/%E5%B7%B4%E7%BA%B3%E5%A7%86%E6%95%88%E5%BA%94/"/>
    
      <category term="星座" scheme="http://uegeek.com/tags/%E6%98%9F%E5%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作02-随机和噪声</title>
    <link href="http://uegeek.com/181014-generative-art-creativity-02.html"/>
    <id>http://uegeek.com/181014-generative-art-creativity-02.html</id>
    <published>2018-10-14T15:02:20.000Z</published>
    <updated>2018-10-14T15:06:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><p><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></p><p>利用随机性（Randomness）和噪声（Noise），可能是最古老、最简单、最常见的生成式艺术的方法。</p><p>艺术家用各种参数来定义一个变化空间，可以在一定范围内取值，随机选中的值影响被操控的元素，形成最终的作品。</p><p>随机性表示一定程度上的目的、动机、规则等可预测性的缺失。引入随机性可以带来多样、不可预测的结果，从而让作品更丰富而有活力。</p><h2 id="产生各种概率分布的随机数"><a href="#产生各种概率分布的随机数" class="headerlink" title="产生各种概率分布的随机数"></a>产生各种概率分布的随机数</h2><p>概率分布是随机变量的概率性质。比如，符合均匀分布的随机数，表示所有可能选项的出现概率是一样的。选择不同的概率分布，可以让随机数产生不同的结果。</p><p>常见的概率分布：</p><p><img src="http://blog.cloudera.com/wp-content/uploads/2015/12/distribution.png" alt=""></p><p><a href="http://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/" target="_blank" rel="noopener">http://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/</a></p><ul><li>Uniform distribution：均匀分布</li><li>Bernoulli distribution：伯努利分布，就是常见的 0-1 分布，即随机变量只取 0 或者 1，频率分别为 1−p 和 p</li><li>Binomial distribution：二项分布，例如在一连串 N/yes/no 中八次成功的概率。二项分布公式基于伯努利分布得到，因为每次实验都是独立的，因此每次实验都是一次伯努利实验</li><li>Hypergeometric distribution：超几何分布，常用来表示在 N 个物品中有指定商品 M 个，不放回抽取 n 个，抽中指定商品的个数</li><li>Poisson distribution：泊松分布，主要用来研究单位时间或单位空间内某事件的发生次数，事件的发生必须是相互独立的，比如单位时间内通过某一交通灯的车辆数</li></ul><p>具有相同分布函数的随机变量一定是同分布的，因此可以用分布函数来描述一个分布，但更常用的描述手段是<a href="https://www.wikiwand.com/zh-hans/%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">概率密度函数</a>（Probability Density Functions）。利用概率分布和密度函数，可以引导和交叉训练随机性，让某些部分发生概率更高，而另一些概率更低。</p><h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><blockquote><p>In <a href="https://www.wikiwand.com/en/Signal_processing" target="_blank" rel="noopener">signal processing</a>, <strong>white noise</strong> is a random <a href="https://www.wikiwand.com/en/Signal_(information_theory" target="_blank" rel="noopener">signal</a>) having equal intensity at different <a href="https://www.wikiwand.com/en/Frequencies" target="_blank" rel="noopener">frequencies</a>, giving it a constant <a href="https://www.wikiwand.com/en/Power_spectral_density" target="_blank" rel="noopener">power spectral density</a>. – Wiki</p></blockquote><p>我们经常会听到一个名词：白噪声。</p><p>它是什么意思呢？为什么噪声还有颜色呢？</p><p>白噪声是一种功率谱密度为常数的随机信号或随机过程。即信号在各个频段上的功率是一样的。</p><p>由于白光是由各种频率（颜色）的单色光混合而成，因而此信号的这种具有平坦功率谱的性质被称作是「白色的」，此信号也因此被称作白噪声。相对的，其他不具有这一性质的噪声信号被称为有色噪声。</p><p>需要注意，<strong>相关性和概率分布是不同的概念</strong>。白色仅意味着信号是不相关的，白噪声的定义除了要求均值为零，并没有对信号应当服从哪种概率分布作出任何假设。因此，如果某白噪声过程服从<a href="https://www.wikiwand.com/zh/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83" target="_blank" rel="noopener">高斯分布</a>，它就是「高斯白噪声」。类似的，还有泊松白噪声、柯西白噪声等。</p><p>噪声的颜色分类，来自于将频谱中的噪声谱密度函数，和频谱中的<a href="https://www.wikiwand.com/zh/%E5%85%89%E6%B3%A2" target="_blank" rel="noopener">光波</a>信号做形式上的类比，也就是说，如果一束光波在频域内具有和蓝噪声相同的谱密度图样，则这束光波看上去将呈现蓝色。</p><ul><li>White noise: 频率密度均匀分布</li><li>Brown noise (Red noise): 由布朗运动造成，又称为随机移动噪音（random walk noise）</li><li>Pink noise (F noise): <a href="https://www.wikiwand.com/zh/%E5%8A%9F%E7%8E%87%E8%B0%B1%E5%AF%86%E5%BA%A6" target="_blank" rel="noopener">功率谱密度</a>与频率成反比的频谱信号或过程。在粉红噪声中，每个倍频程中都有一个等量的噪声功率。在生成式艺术中很常用，因为它可以模拟自然现象中的随机性</li></ul><p><img src="http://img.viz.mobi/various%20colors%20of%20noise.png" alt=""></p><h3 id="Aleatoric-Music-机遇音乐"><a href="#Aleatoric-Music-机遇音乐" class="headerlink" title="Aleatoric Music 机遇音乐"></a>Aleatoric Music 机遇音乐</h3><blockquote><p>A process is said to be aleatoric … if its course is determined in general but depends on chance in detail. </p><p>—— Werner Meyer- Eppler, 1957</p></blockquote><p>机遇音乐是一种包含随机性元素的音乐创作。</p><p>在一首音乐作品中，作曲家在某些地方会让演奏者按自己的意愿，或使用一些系統来决定音乐的演奏，由于随机性不可能每次都得出相同的结果，所以乐曲每次的演奏版本都不完全相同。</p><p>Iannis Xenakis 开创了机遇音乐的一个子类：随机音乐（Stochastic music），即在音乐创作中或者在演奏中使用随机过程生成乐曲片段。</p><p>Xenakis 经常使用计算机来制作乐谱，例如包括 Morsima-Amorsima 和 Atrées 在内的 ST 系列。</p><p><img src="https://discourse-cdn-sjc2.com/standard17/uploads/critterandguitari/original/2X/a/aede09d8452c1b3d4273a4515dfa6c941c62e21e.jpg" alt=""></p><h3 id="Noise-music-噪声音乐"><a href="#Noise-music-噪声音乐" class="headerlink" title="Noise music 噪声音乐"></a>Noise music 噪声音乐</h3><p>Noise music 是音乐的一个子流派，研究声学噪声的概念并将其作为重要的声学材料。</p><blockquote><p>I believe that the use of noise to make music will continue and increase until we reach a music produced through the aid of electrical instruments which will make available for musical purposes any and all sounds that can be heard.</p><p>— John Cage, The Future of Music: Credo (1937)</p></blockquote><p>让我们来听听日本著名的噪音音乐人 Merzbow 的一首作品，感受一下什么是噪声音乐：</p><iframe width="100%" height="166" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/450625851&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true"></iframe><p><a href="https://soundcloud.com/merzbow/v2-1" target="_blank" rel="noopener">https://soundcloud.com/merzbow/v2-1</a></p><blockquote><p>噪音和音乐的定义因人而异，如果噪音是指让人不舒服的声音的话，流行音乐对我而言就是噪音。</p><p>——Merzbow</p></blockquote><p>在工业噪音、噪音摇滚、No wave 和 Harsh noise 之后，出现了大量的噪音音乐家，风格包括 Ambient、Microsound、Glitch 等，更强调微妙的脉冲式声响和敏感的听觉。</p><h2 id="Random-walk"><a href="#Random-walk" class="headerlink" title="Random walk"></a>Random walk</h2><p>Random walk 1905 年由皮尔逊首次提出，它是一种数学统计模型，由一连串轨迹组成，每一步根据概率随机选择。步长可以是固定也可以是动态的。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Random_Walk_example.svg/840px-Random_Walk_example.svg.png" style="zoom:50%"></p><p>一维 Random Walk</p><p>Brownian movement 是 Random walk 的特例（step 为 0）。所以上文提到的 Brown noise 也称为 Random walk noise。</p><p>随机漫步的算法虽然简单，但是经过多次迭代，可以产生丰富的随机效果，所以在生成式艺术中被广泛使用。</p><p>Chance and Order 是 Kenneth Martin 1971 使用随机漫步规则创作的一个系列。</p><blockquote><p>the points of intersection on a grid of squares are numbered and the numbers are written on small cards and picked at random… A line is made between each successive pair of numbers as they are picked out. </p><p>——Kenneth Martin</p></blockquote><p><img src="https://www.tate.org.uk/art/images/work/T/T01/T01847_10.jpg" style="zoom:50%"></p><p>Quantum cloud 是艺术家 Antony Gormley 1999 年完成的当代雕塑作品。它由一系列四面体单元构成，由 1.5 米长的钢制成。钢架部分用 Random walk 算法生成。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Quantum_Cloud_by_Antony_Gormley_in_March_2011_01.jpg" style="zoom:20%"></p><h2 id="Perlin-noise"><a href="#Perlin-noise" class="headerlink" title="Perlin noise"></a>Perlin noise</h2><p>Perlin noise 是由 Ken Perlin 发明的自然噪声生成算法，经常用来模拟自然界中的噪声现象、人体的随机运动、蚂蚁行进的线路等。还可以通过计算分形来模拟云朵，火焰等非常复杂的纹理。</p><p><img src="https://media.moddb.com/images/games/1/39/38759/3x-ANITblB0.1.jpg" alt=""></p><p>在很多生成式系统中，比如游戏制作场景里的贴图材质、波澜起伏的地面和海洋，很多都是用 perlin noise 生成的。它旨在描述自然中的随机效果，创建的纹理可以直接运用于顶点着色器，而不是像纹理映射技术，先生成一张纹理图，然后把贴图附加到一个三维物体上。也就是说，只需要提供每个顶点的 (x,y,z) 的坐标，传入 perlin noise 函数，计算得到一个随机数，然后与原颜色运算，得到新的颜色，如同直接在物体表面绘制纹理一样。</p><p>Perlin 认为，理想的噪声函数应当具有以下性质：</p><ol><li>旋转统计不变性（不管怎么旋转它的域都有同样的统计特性）  </li><li>能量在频谱上集中于一个窄带（图像是连续的，高频分量受限）</li><li>变换统计不变性（不管如何平移它的域都有同样的统计特性）</li></ol><p>产生 2D Perlin Noise 的方法：</p><ol><li>为所有坐标为（x,y）且 x, y 都是整数的点指定一个值，同时指定一个<a href="https://www.wikiwand.com/zh/%E6%A2%AF%E5%BA%A6" target="_blank" rel="noopener">梯度</a>，这些点将空间分成方格；</li><li>对于坐标轴为整数的点，即上述方格的顶点的值作为该点的值；对于某个方格内部的点（x,y），用所在方格四个顶点的值和<a href="https://www.wikiwand.com/zh/%E6%A2%AF%E5%BA%A6" target="_blank" rel="noopener">梯度</a>进行插值。</li></ol><p>为了简化计算，方便硬件实现，Ken Perlin 在 2002 年改进了方法，称为 Simplex 噪声。Simplex 噪声使用 <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ed5b799e7d9cd423db6f533050ddfda181b4850b" alt="{\displaystyle 6t^{5}-15t^{4}+10t^{3))">作为插值函数，避免了导数中的线性部分。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/SimplexNoise2D.png/240px-SimplexNoise2D.png" alt=""></p><p>使用 Simplex 方法产生噪声</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ul><li><a href="https://www.wikiwand.com/zh-hans/%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83" target="_blank" rel="noopener">概率分布 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Probability_density_function" target="_blank" rel="noopener">Probability density function - Wikiwand</a></li><li><a href="http://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/" target="_blank" rel="noopener">Common Probability Distributions: The Data Scientist’s Crib Sheet - Cloudera Engineering Blog</a></li><li><a href="https://www.wikiwand.com/zh/%E7%99%BD%E9%9B%9C%E8%A8%8A" target="_blank" rel="noopener">白噪声 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh/%E5%99%AA%E5%A3%B0%E7%9A%84%E9%A2%9C%E8%89%B2" target="_blank" rel="noopener">噪声的颜色 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Pink_noise" target="_blank" rel="noopener">Pink noise - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Aleatoric_music" target="_blank" rel="noopener">Aleatoric music - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Noise_music" target="_blank" rel="noopener">Noise music - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh/Perlin%E5%99%AA%E5%A3%B0" target="_blank" rel="noopener">Perlin噪声 - Wikiwand</a></li><li><a href="http://flafla2.github.io/2014/08/09/perlinnoise.html" target="_blank" rel="noopener">Understanding Perlin Noise</a></li><li><a href="https://blog.csdn.net/ZJU_fish1996/article/details/71136348" target="_blank" rel="noopener">[图形学] 柏林噪声 （perlin noise）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="随机" scheme="http://uegeek.com/tags/%E9%9A%8F%E6%9C%BA/"/>
    
      <category term="噪声" scheme="http://uegeek.com/tags/%E5%99%AA%E5%A3%B0/"/>
    
      <category term="Noise" scheme="http://uegeek.com/tags/Noise/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作01-概述</title>
    <link href="http://uegeek.com/181009-generative-art-creativity-01.html"/>
    <id>http://uegeek.com/181009-generative-art-creativity-01.html</id>
    <published>2018-10-09T11:18:35.000Z</published>
    <updated>2018-10-15T04:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><p>自从今年把兴趣领域<a href="https://www.uegeek.com/180717-human-computer-symbiosis.html" target="_blank" rel="noopener">从人机交互扩展到人机协同创作</a>之后，接触到越来越多「艺术x技术」的新鲜知识、有趣项目和精彩作品。一个星期有那么 7 天心情如下图：</p><p><img src="http://img.viz.mobi/justMyMind.jpg" alt=""></p><p>这个系列，<a href="https://uegeek.com/">00</a> 将会（希望是深入地）整理和介绍 Generative Art 和 Computational Creativity 的一些研究领域、概念和作品。当然，我们不满足于做手残党。为了避免出现只是看看图惊叹两句就没有然后的纯消费行为，这个系列也会探讨相关的技术、算法，以及实现的思路。</p><h2 id="需求井喷下的工具进化"><a href="#需求井喷下的工具进化" class="headerlink" title="需求井喷下的工具进化"></a>需求井喷下的工具进化</h2><p>为什么关注生成式艺术和算法创作？</p><p>除了个人的职业背景和癖好，还有对声色犬马的生活，哦不，做一个声色全码的手艺人的向往。</p><p>创意和娱乐产业发展到今天，已经是一个巨大的造梦引擎。但消费市场对极致体验和制造梦境能力的追求并不会停歇，这迫使技术和计算能力以前所未有的速度变化和发展。不但场景越来越宏大、梦幻、沉浸，对实时性、多角色协同、虚实融合的诉求也愈发强烈。这其中有大量的创作工作要做。</p><p><img src="https://images.unsplash.com/photo-1514525253161-7a46d19cd819?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=be465b88fdf21a6e05ab522458452344&amp;auto=format&amp;fit=crop&amp;w=800&amp;q=60" alt=""></p><p>比如，在 Minecraft 中，每周有超过 1000 万玩家，会在游戏里待上 20 小时。这样算下来，需要多少作曲家才能为每一位玩家提供个性化的音乐呢？</p><p><img src="https://images.g2a.com/newlayout/470x470/1x1x0/a476e4dbb6b0/591ef89dae653af3c942eff4" alt=""></p><p>Non-linear （非线性叙事）媒体日渐流行，自动生成丰富而个性化的内容流成为强需求，或者至少需要有方法能够帮助创意工作者更有效地完成创意任务。但是传统的工具例如视频剪辑、音频效果制作、图像合成等等，工具本身并不能提供更多的帮助。不论创意有多明确，一切都需要从头开始。</p><p>为什么机器不能以更动态、灵活、人性的方式与我们交互呢？比如说，我已经设计过 100 张海报，这次的设计跟其中的 3 张风格相似，但是内容会有变化。创作工具能不能自动生成几个草稿或模板，让我不必重零开始呢？</p><p>打造这样的工具或者工作流程，需要研究人类的创造过程，让机器在一定程度上自主完成创造过程，才能更好地辅助我们创造。</p><p>应用了计算机算法的生成式艺术处于艺术和创造的前沿，已经涌现出许多艺术和文化作品。</p><h2 id="生成式艺术"><a href="#生成式艺术" class="headerlink" title="生成式艺术"></a>生成式艺术</h2><p><strong>生成式艺术（Generative art）是指部分或全部使用自动创作系统（autonomous system）创造的艺术。</strong></p><blockquote><p>Generative art refers to any art practice where the artist <strong>uses a system</strong>, such as a set of natural language rules, a computer program, a machine, or other procedural invention, which is set into motion <strong>with some degree of autonomy</strong> contributing to or resulting in a completed work of art. </p><p>—— Philip Galanter </p></blockquote><p>可以用来辅助生成艺术作品的系统有很多，通常是一个非人类的独立系统（不一定是计算机），只要它可以独立确定一件艺术品的特征。生成式艺术几乎跟艺术本身一样古老，使用几何对称、样式、重复来生成图案的做法，已经存在几千年了。</p><p><img src="http://www.sfu.ca/~mdevos/notes/geom-sym/wallpaper/2222/egypt8b.jpg" alt=""></p><p>艺术家需要设计一个自主运作的机制来创作作品，这个机制通常包含一组规则，例如自然/音乐/编程语言、二进制代码、数据映射、生物指令等，由它们生成自动化处理过程，最终产生艺术作品。</p><p>生成式艺术可以为艺术家提供减少主观创造意向的手段。在不同的条件、参数、设置下，运行过程不同，结果会呈现出一定特征，但常常是不可预测的。</p><p>随着互动需求的增加、计算机计算能力提高，越来越多的生成式艺术作品是实时生成的，而且系统会收集反馈或产生即时的新输入，让结果持续更新和变化。</p><p>需要注意的是，<strong>生成式艺术并不是艺术流派、艺术运动或某种意识形态，它只是一种创造性的方法</strong>，与作品的意图和价值取向无关。</p><h2 id="算法创作"><a href="#算法创作" class="headerlink" title="算法创作"></a>算法创作</h2><p>Computational Creativity（我翻译为算法创作），是一个学术研究领域，<strong>研究的对象主要是创意活动的计算化/自动化过程。</strong>它并不局限于艺术，还包含各种创造性活动，如绘画、音乐、文学、表演等等。</p><p>算法创作听起来跟人工智能似乎很像，都强调算法、计算、自动的处理过程。它们是一样的吗？</p><p>让我们先来看看 Sternberg 在 Handbook of Creativity 里提出的创造性最重要的 3 类智能：</p><ul><li>分析智能 Analytical Intelligence：分析、评论、判断、比较、评估</li><li>实用智能 Practical Intelligence：使用、实施</li><li>创作智能 Synthetic/creative Intelligence：想象、创造、发明、发现、预测 </li></ul><p>再来回顾一下人工智能先驱司马贺给出的人工智能的定义：</p><blockquote><p>Artificial intelligence is the science of having machines solve problems that do require intelligence when solved by human. </p><p>—— Herbert Simon (1960)</p></blockquote><p>此处的重点是：solve problems。</p><p>AI 擅长 rational problem solving，也就是说，擅长处理那些解决方案可能很复杂，但是容易理解、目标明确或定义良好（well defined）的问题。</p><p>但是，机器可以擅长创作吗？</p><p>跟理性问题相比，创造性活动一般没有「最佳」结果或答案。不存在最好的音乐、绘画、诗歌、故事、笑话、菜谱、游戏……这一类活动更加需要 Sternberg 所说的第三类 synthetic 智能。于是算法创作渐渐从 AI 研究领域中分离出来，因为「最优」（optimality）的概念对创作行为来说是定义不良的（ill-defined）。</p><h2 id="Creative-System-的分类"><a href="#Creative-System-的分类" class="headerlink" title="Creative System 的分类"></a>Creative System 的分类</h2><p>从通用性来分，创意系统可分为特定的 (基于领域/任务/审美的) 和通用的。</p><p>从自动化程度来分，可分为响应式的和全自动的。</p><p>从互动性来分，可分为低互动性的（只响应输入，比如一般的人机交互界面）和高互动性的（可以相互影响的智能体行为）。</p><p>从系统的知识来源分，可分为硬编码的、输入的和学习式的（比如从语料学习）。</p><p>从系统的行为模式来分，可分为：fixed - periodic - complex - chaotic。</p><p>从有效复杂性（effective complexity）来分，可以分为：</p><p><img src="https://www.researchgate.net/profile/Philip_Galanter/publication/220947690/figure/fig2/AS:651931043233793@1532443881222/Effective-complexity-used-to-organize-various-generative-art-systems.png" alt=""></p><p>从架构和算法来分，可以分为：</p><ul><li><p>generative</p></li><li><p>generate and evaluate</p></li><li><p>generative with reflexive feedback</p><p><img src="http://img.viz.mobi/reflective%20system.png" alt=""></p></li><li><p>interactive and adaptive</p><p><img src="http://img.viz.mobi/interactive%20system.png" alt=""></p></li></ul><h2 id="算法创作的领域实践"><a href="#算法创作的领域实践" class="headerlink" title="算法创作的领域实践"></a>算法创作的领域实践</h2><h3 id="生成绘画"><a href="#生成绘画" class="headerlink" title="生成绘画"></a>生成绘画</h3><p>哈罗德·科恩（Harold Cohen）的 AARON 系统是一个从 1973 年开始的长期项目，他将软件人工智能与机器人绘画设备相结合，让机器自动作画，可以算得上是 AI 画家的鼻祖了。</p><p><img src="https://static1.squarespace.com/static/5800c6211b631b49b4d63657/t/5807227bebbd1a790b76fdb6/1476862594263/" style="zoom:50%"></p><p>自动作画的机器人被明名为 AARON。AARON 是一台很原始的绘画机器，但它可以在没有照片或其他人类输入参考的情况下绘制人物形象的静物和肖像。</p><p>在专注水彩作画的 40 多年里，AARON 的绘画能力逐年提高。80 年代学会了将物体或人物放置在三维空间中，从 1990 年起可以用彩色绘画。它的部分作品已被泰特等知名美术馆和一些私人收藏家收藏。</p><p><img src="https://images2.corriereobjects.it/methode_image/2015/09/09/Cultura/Foto%20Gallery%20-%20Trattate/sfpeople_ori_crop_MASTER__0x0_MGZOOM.jpg" style="zoom:50%"></p><p>Final Approach 是 2013 年 AARON 最新的绘画作品之一：</p><p><img src="https://windowsunited.de/wp-content/uploads/sites/3/2018/06/AARON-neu-4-1024x553.jpg" alt=""></p><p>时间快进到 2018 年，已经连续举办 3 年的 Robot Art Prize 已落下帷幕（ARRON 也参加了比赛🙂），第一名由名叫 cloudpainter 的机器人画家获得，下面是它的画作：</p><p><img src="https://static1.squarespace.com/static/5800c6211b631b49b4d63657/t/5b0f2e52aa4a99692dc998a2/1527721560441/robotart_announcement.jpg?format=2500w" alt=""></p><blockquote><p>我认为，在短期内，机器人将越来越多地用于数字艺术的最终生产，特别是那些有很多细节或重复元素的机器人。</p></blockquote><p>创立 RobotArt 的艺术家和工程师 Andrew Conru 表示。</p><p>但他不认为机器人或算法艺术家会取代更有创造性的人类。他把机器创造的艺术品比作照相机的创造<strong>。</strong>摄影成为一种全新的艺术分支，捕捉不同类型的图像和作品。</p><p>Conru 认为机器人和人类艺术品将继续存在。每个人都会为艺术领域带来不同的技能和方法。正如他的网站所说：</p><blockquote><p>We all win when we see something beautiful.</p></blockquote><h3 id="生成音乐"><a href="#生成音乐" class="headerlink" title="生成音乐"></a>生成音乐</h3><p>人们希望借助自然的力量更自动地创作音乐，这种想法实际上早已出现。从某种程度上说，第一首自动生成音乐来自于大自然：中国的风铃、古希腊的风弦琴、日本的水琴窟等。</p><p>莫扎特的 Musikalisches Würfelspiel（Musical Dice Game，1757）被认为是早期的基于随机性的生成系统。</p><p><img src="http://abjad.mbrsi.org/_images/mozart-tables.png" style="zoom:40%"></p><p>在这部作品中，他创作了 176 小节音乐，然后将小节号排列为两个特殊的矩阵图，通过演奏家掷般子的方式来决定音乐序列的选择。这个机制提供了有序和无序的平衡。可以说，将算法应用于音乐创作可能和音乐本身一样古老。</p><p>Iannis Xenakis 在他 1958 年的专辑 Analogique 中，使用了马尔可夫链来作曲。他在著作 Formalized Music: Thought and Mathematics in Composition 里详细描述了使用马尔可夫模型的算法。</p><p><img src="https://discourse-cdn-sjc2.com/standard17/uploads/critterandguitari/original/2X/a/aede09d8452c1b3d4273a4515dfa6c941c62e21e.jpg" alt=""></p><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=e1343co9tml" allowfullscreen="true"></iframe><p>第三章“马尔可夫的随机音乐：应用”（节选）<a href="https://v.qq.com/x/page/e1343co9tml.html" target="_blank" rel="noopener">音乐生成3_腾讯视频</a></p><p>John Cage，Farmers Manual 和 Brian Eno 等现代（电子）音乐先驱都在早期作品中开始使用生成系统。</p><p>Continuator 是 Francois Pache 在索尼计算机科学实验室 (Sony Computer Science Laoratories) 时主导的项目。</p><blockquote><p>The Continuator is a usable musical instrument combining techniques from interactive and automatic learning systems. </p></blockquote><p><img src="https://www.sonycsl.co.jp/wp-content/uploads/2015/08/Continuator.jpg" alt=""></p><p>他最近几年则投入到 <a href="http://www.flow-machines.com/" target="_blank" rel="noopener">Flow Machines</a> 项目中。</p><p><img src="https://pic.36krcnd.com/201801/30024716/k5qmdhmi5h5yyl6u!1200" alt=""></p><p>2016 年，格莱美获奖制作人 Alex Da Kid 与 IBM Watson 搭档合作一起创作歌曲。Watson 将大量的非结构化数据转化为情感洞察，创造出有史以来一种全新的音乐——可以“聆听”受众的音乐。</p><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=b0388czlxm5" allowfullscreen="true"></iframe><p><a href="https://v.qq.com/x/page/b0388czlxm5.html" target="_blank" rel="noopener">Alex Da Kid 携手IBM Watson创作故事揭秘_腾讯视频</a></p><p><a href="https://www.ibm.com/ibm/cn/cognitive/outthink/watson/index.html" target="_blank" rel="noopener">Watson</a> 分析了近五年的文化和音乐数据，探索全新的情感洞察。</p><p>为了解最普遍最主流的话题及主题，自然语言分析 API <a href="http://www.ibm.com/watson/developercloud/alchemy-language.html" target="_blank" rel="noopener">Watson Alchemy Language</a> 分析了过去 5 年的各类文本，包括诺贝尔和平奖演讲内容，《纽约时报》头版，美国最高法院的裁定，洛杉矶 Getty 博物馆的报告，维基百科文章，热门电影梗概等等。</p><p>掌握这些文化主题后，情绪分析 API <a href="https://www.ibm.com/watson/services/tone-analyzer/" target="_blank" rel="noopener">Watson Tone Analyzer</a> 分析相关的社交媒体内容了解受众对主题的想法和感受。它还分析了过去 5 年 Billboard Hot 100 歌曲中超过 26000 首歌的歌词。Watson Beat 检测出来热门歌曲的作曲过程中，从逐年来不同的节奏、音高、乐器、流派中找出关系模型，帮助 Alex 发现不同声音所反映出的不同情感。</p><p>同时, 颜色分析 API <a href="http://www.research.ibm.com/" target="_blank" rel="noopener">Cognitive Color Design Tool</a> 对专辑封面、图像、色彩的分析也启发了 Alex 专辑封面的制作。</p><p><img src="http://www-31.ibm.com/ibm/cn/cognitive/outthink/watson/music/images/bg-03.jpg" alt=""></p><hr><p>新的创作时代已经到来。</p><p>新技术激发了前所未有的创造力，新的创作方式将赋予创作者们更大的能量。</p><p>00 的生成式艺术和算法创作系列，将带你一起探索（看起来很 Geek 很头疼的）知识和项目，其中很多都是艺术创作领域中前沿和硬核的话题，例如混沌和分型理论（Chaotic &amp; Fractal）、形状语法（Shape grammar）、规则系统（Rule-based system）、马尔可夫模型（Markov Model）、智能主体（Intelligent Agents）、多智能体系统（Multi-agent system）、元胞自动机（Cellular Automaton）等。</p><p>道阻且长，行则将至。</p><p>感谢你的陪伴。</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ul><li>Sternberg, R. J., &amp; O’HARA, L. A. (1999). 13 Creativity and Intelligence. <em>Handbook of creativity</em>, 251.</li><li>Philip Galanter. What is Generative Art? Complexity theory as a context for art theory, 2003 International Conference on Generative Art</li><li><a href="https://www.wikiwand.com/en/Triarchic_theory_of_intelligence" target="_blank" rel="noopener">Triarchic theory of intelligence - Wikiwand</a></li><li><a href="http://www.aaronshome.com/aaron/index.html" target="_blank" rel="noopener">Harold Cohen Home Page</a></li><li><a href="http://www.cloudpainter.com/" target="_blank" rel="noopener">cloudpainter - an artificially intelligent painting robot</a></li><li><a href="http://freedomandsafety.com/ru/node/1380" target="_blank" rel="noopener">Qbits for Cubists: Robots Made These Incredible Works of Fine Art | Freedom and Safety</a></li><li><a href="https://www.wikiwand.com/en/Musikalisches_W%C3%BCrfelspiel" target="_blank" rel="noopener">Musikalisches Würfelspiel - Wikiwand</a></li><li><a href="https://www.francoispachet.fr/" target="_blank" rel="noopener">François Pachet - Director of Spotify Creator Technology Research Lab</a></li><li><a href="http://www.flow-machines.com/" target="_blank" rel="noopener">Flow Machines: AI music-making</a></li><li><a href="https://medium.com/artists-and-machine-intelligence/neural-nets-for-generating-music-f46dffac21c0" target="_blank" rel="noopener">Neural Nets for Generating Music – Artists and Machine Intelligence – Medium</a></li><li><a href="http://www-31.ibm.com/ibm/cn/cognitive/outthink/watson/music/" target="_blank" rel="noopener">IBM Watson Music - 中国</a></li><li><a href="https://xw.qq.com/cmsid/20180409A1295K00" target="_blank" rel="noopener">机器人都能画出《蒙娜丽莎的微笑》了，那还要画家干什么？</a></li><li><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1538363661&amp;ver=1155&amp;signature=YiP2N6ONasXfYcTqidl7jz2x1KrfHO30I3hUGwHi9O2uqAL9tp8Z0xfeS7fVVljj7QMjazIetslJJ8r8whpe*brPZcbR3c1vRHin6Ovul4nxwE-ujd8z0qRXCeH1JIYg&amp;new=1" target="_blank" rel="noopener">人工智能是怎么创作音乐的？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/ Jitter 官方教程翻译20 - 迭代和矩阵重采样</title>
    <link href="http://uegeek.com/180930-jitter-20.html"/>
    <id>http://uegeek.com/180930-jitter-20.html</id>
    <published>2018-09-30T10:19:02.000Z</published>
    <updated>2018-09-30T10:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-2.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li><li><a href="https://www.uegeek.com/180915-jitter-17.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 17 - 图像旋转</a></li><li><a href="https://www.uegeek.com/180917-jitter-18.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程18 - 使用已命名的矩阵</a></li><li><a href="https://www.uegeek.com/180924-jitter-19.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程19 - 使用已命名矩阵的反馈</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter18" target="_blank" rel="noopener">Tutorial 18: Iterative Processes and Matrix Re-Sampling</a></p></blockquote><p>本教程演示何时应该使用已命名 <code>jit.matrix</code> 对象的更复杂示例，以及如何使用 <code>jit.matrix</code> 对图像增采样（upsampling）和减采样（downsampling）。</p><p>patch 左上角包含一个 <code>jit.movi​e</code>，patch 打开时会加载一个静止图像 fuzz_circle.jpg。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18a.png" alt="">            </p><p>单击开关启动 <code>metro</code>。图像出现在 patch 右下角的 <code>jit.pwindow</code> 中：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18b.png" alt=""></p><p>fuzz_circle.jpg 包含一个白色圆圈与黑色背景，在最终矩阵里尺寸被缩放为小的圆形。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18c.png" alt=""></p><h2 id="Getting-Drunk"><a href="#Getting-Drunk" class="headerlink" title="Getting Drunk"></a>Getting Drunk</h2><p> patch 顶部将 <code>jit.movi​​e</code> 中的图像写入链条中的第一个 <code>jit.matrix</code>。<code>bangbang</code> 对象发出的 bang 用 <code>drunk</code> 对象随机变化坐标，来改变 <code>jit.matrix</code> 每一帧的 dstdimstart 和 dstdimend 属性。请注意第一个 <code>jit.matrix</code> 的 usedstdim 属性为 1，它将缩放输入矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18d.png" alt=""></p><p>第一个 <code>jit.matrix</code> 只是用来缩放圆形图像以适应输出矩阵的 80 x 60 区域。请注意，格式化缩放图像坐标的消息框，也会逐帧清除矩阵（用 <code>clear</code> 消息），这样就不会残留之前的图像。<code>drunk</code> 改变了圆圈的位置，让它四处抖动。</p><p>单击 patch 右下角 <code>jit.pwindow</code> 中的某个位置。圆圈将跳到单击的位置，并从那里开始移动。</p><p>在 <code>jit.pwindow</code> 中单击鼠标的结果将发送到 <code>r winclick</code> 对象。<code>route</code> 对象将 <code>mouse</code> 相关的信息抽出来，用 <code>unpack</code> 对象提取前两个元素（鼠标单击的 x 和 y 位置）。然后使用来设置 <code>drunk</code> 对象的新原点。</p><h2 id="反馈网络"><a href="#反馈网络" class="headerlink" title="反馈网络"></a>反馈网络</h2><p>一旦圆圈图像已被缩放并由 <code>jit.matrix</code> 放置好，patch 流程就进入一对名为 blurry 的 <code>jit.matrix</code> 反馈链：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18e.png" alt=""><br>反馈循环</p><p>这一部分包含四个 <code>jit.matrix</code>（不包括顶部的一个缩小圆形图像的对象）。其中两个对象同名（blurry），仅用于存储和检索由 patch 的其余部分之前生成的矩阵。最上面的 <code>jit.matrix</code> 将矩阵发送到第一个 <code>jit.op</code> 的右入口。此外，它用 <code>bangbang</code> 发送 bang 到第一个 <code>jit.matrix blurry</code> 让它输出矩阵。该矩阵最终到达 <code>jit.op</code> 的左入口，然后显示（通过 <code>jit.pwindow</code>）并乘以标量（第二个 <code>jit.op</code> 对象）。它最终会覆盖先前的矩阵（进入下面的 <code>jit.matrix blurry</code>）。先不管中间一些对象，可以看到 blurry 矩阵将保留圆形图像前一“帧”的某个版本：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18f.png" alt="">            </p><p>第一个 <code>jit.op @op max</code> 组合新旧图像。@op max 比较两个矩阵中每个单元并保留值较高的那个单元。第二个 <code>jit.op @op *</code> 对象乘以标量（由 patch 右侧的数字框发送到 <code>s fb</code>）使图像变暗：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18g.png" alt=""><br>反馈量指定图像在存储之前变暗的程度</p><p>在 patch 的蓝色区域中用标记为 <code>Feedback</code> 的数字框来更改反馈量。单击 <code>jit.pwindow</code> 移动圆圈时，注意圆圈后的轨迹如何增加或减少，这取决于所设置的反馈量。</p><h2 id="增采样和减采样"><a href="#增采样和减采样" class="headerlink" title="增采样和减采样"></a>增采样和减采样</h2><p>图像处理算法的最后一步，涉及这两个对象之间的区域：发送前一帧中保留的矩阵的第一个 <code>jit.matrix blurry</code>，以及合成前后两个矩阵的 <code>jit.op</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18h.png" alt=""><br>用 <code>jit.matrix</code> 重新采样图像</p><p>教程 patch 中两个绿色 <code>jit.matrix</code> 重新采样上方的 <code>jit.matrix</code> 的模糊图像矩阵。两个 <code>jit.matrix</code> 中的第一个将 dim 的属性设置为 4 x 4。可以用蓝色区域中标记为 Pixelation 的数字框来更改。这个数字被发送到 <code>jit.matrix</code> 上方的 <code>s dim</code>   对象。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18i.png" alt="">            </p><p>在教程 patch 的蓝色区域中，更改标记为 Pixelation 的数字框。注意圆形轨迹如何变化。</p><p>对图像矩阵减采样，<code>jit.matrix</code> 将 320 x 240 矩阵从其输入复制到一个小得多的矩阵中，舍弃多余的数据。得到像素化的图像，可以用矩阵的 dim 控制。</p><p>第二个 <code>jit.matrix</code> 将矩阵增采样回到 320 x 240 大小。当后续的对象处理矩阵时，它们有全分辨率图像并将输出全分辨率矩阵。</p><p><code>jit.streak</code> 对象通过随机复制到相邻单元得到好看的像素化轨迹效果。<code>jit.streak</code> 的 prob 属性控制矩阵中任何给定单元格被复制到相邻单元格的可能性。这里的 prob 为 0.5，任何给定单元格都有 50％ 的可能性。</p><blockquote><p>技术细节：默认情况下 <code>jit.streak</code> 将单元格复制到左侧。更改  direction 属性将改变此行为。还有一个 scale 属性可以指定被复制的单元格与其原始值的亮度比值。<code>jit.streak</code> 的帮助文档有更具体的信息。</p></blockquote><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18j.png" alt="">            </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>成对命名 <code>jit.matrix</code> 可以有效地存储先前迭代。这些技术可以用合成对象（例如 <code>jit.op</code>）组合先前矩阵与当前矩阵来生成视频延迟效果。还可以使用 <code>jit.matrix</code> 重新采样图像（使用 dim 属性）以更有效地执行算法（矩阵越小，图像处理得越快）并创建像素化效果。<code>jit.streak</code> 对象根据概率因子（prob 属性）随机复制单元格到相邻单元格。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译19 - 使用已命名矩阵的反馈</title>
    <link href="http://uegeek.com/180924-jitter-19.html"/>
    <id>http://uegeek.com/180924-jitter-19.html</id>
    <published>2018-09-24T03:58:55.000Z</published>
    <updated>2018-09-25T07:36:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-1.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li><li><a href="https://www.uegeek.com/180915-jitter-17.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 17 - 图像旋转</a></li><li><a href="https://www.uegeek.com/180917-jitter-18.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 18 - 使用已命名的矩阵</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter17" target="_blank" rel="noopener">Max 7 - Tutorial 16: Using Named Jitter Matrices</a></p></blockquote><p>本教程讲解在反馈循环（feedback loop）中使用命名的 <code>jit.matrix</code> 。我们将使用随机值矩阵来构建迭代过程（Conway’s Game of Life）。</p><p>教程 patch 用 <code>jit.noise</code> 生成随机值的初始矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17a.png" alt=""><br><code>jit.noise</code> 对象</p><p><code>jit.noise</code> 生成由随机值填充的矩阵。dim，planecount 和 type 属性确定输出矩阵（需要一个 80 x 60 单平面 char 数据矩阵）。<code>jit.op</code> 将随机单元格的值（初始为 0~255）设置为 false（0）或 true（255）。<code>jit.op</code> 的 &gt; 运算符从右入口数字框中获取值并用于比较运算。如果单元格值小于该值，单元格的值将设置为 0，否则设置为 255。发送到 <code>jit.noise</code> 的 bang 将生成新的随机矩阵。</p><p>更改附加到 <code>jit.op</code> 的数字框。单击连接到 <code>jit.noise</code> 的按钮，每次都生成一个新矩阵。注意更大的比较值产生更少的白色（255）单元格。<code>jit.op</code> 下面的小 <code>jit.pwindow</code> 显示随机矩阵。单平面矩阵数据由 <code>jit.pwindow</code> 解析为灰度视频。</p><h2 id="矩阵反馈"><a href="#矩阵反馈" class="headerlink" title="矩阵反馈"></a>矩阵反馈</h2><p>patch 顶部的量化（quantized）噪声从 <code>jit.op</code> 传到名为 cellular 的 <code>jit.matrix</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17b.png" alt=""><br>在反馈循环中有两个已命名的 <code>jit.matrix</code></p><p><code>jit.matrix</code> 接收来自 patch 顶部的 <code>metro</code> 的 bang，它连接到一个名为 <code>jit.conway</code> 的对象，其输出连接到另一个同名的 <code>jit.matrix</code>。结果是 <code>jit.conway</code> 的输出（无论它做什么）被写入跟其输入相同的矩阵中，从而创建反馈循环。</p><p>点击开关启动 <code>metro</code>。 patch 底部的 <code>jit.pwindow</code> 将显示 <code>jit.conway</code> 的输出。</p><p>如果想从一个新的随机矩阵开始，单击连到 <code>jit.noise</code> 的按钮，将新矩阵复制到反馈循环中。来自 <code>jit.op</code> 的矩阵会进入反馈循环中相同的 cellular 矩阵。</p><h2 id="生命的游戏"><a href="#生命的游戏" class="headerlink" title="生命的游戏"></a>生命的游戏</h2><p><code>jit.conway</code> 对输入矩阵执行名叫 “Game of Life” 的简单元胞自动机算法。该算法由普林斯顿大学的 John Conway 发明，模拟食物供应有限环境中的有机生存周期。矩阵中的单元格被看做是活的（非 0）或死的（0）。比较每个单元与周围的单元。如果一个活细胞有两个或三个活的邻居，它就活着。如果多于或少于该数字，它将死亡（0）。如果死去的细胞恰好有三个活的邻居，它就会变为活的（255）。就这么简单。</p><p>每当 <code>jit.conway</code> 接收到输入矩阵时，会开始一轮生命游戏。因此，在反馈循环内使用对象是有意义的，可以看到在同一初始数据集上执行多代算法。</p><p>例如，初始随机矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17c.png" alt=""><br>一些随机矩阵值</p><p><code>jit.conway</code> 在前四次迭代中生成以下矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17d.png" alt=""><br>在上面的数据集上 Game of Life 的前四代</p><p>使用随机矩阵 seeding 反馈循环后，可以打开 <code>metro</code> 并观察算法运行。Game of Life 的设计方式使得矩阵最终将稳定到一组自振荡 (self-oscillating) 细胞单元或空矩阵（a dead world）。在任何一种情况下，都可以 bang 一组新的数字重新开始。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用 <code>jit.matrix</code> 的 name 属性在 Jitter 中创建反馈循环。在对象链的任一端使用两个同名 <code>jit.matrix</code>，可以创建输出将被写入与输入来源相同的矩阵的链条。<code>jit.noise</code> 产生的任意随机数 type/dim/planecount 的矩阵。<code>jit.conway</code> 对输入矩阵做简单的元胞自动处理，在反馈回路中效果最好。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译18 - 使用已命名的矩阵</title>
    <link href="http://uegeek.com/180917-jitter-18.html"/>
    <id>http://uegeek.com/180917-jitter-18.html</id>
    <published>2018-09-17T10:21:32.000Z</published>
    <updated>2018-09-25T07:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-9.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li><li><a href="https://www.uegeek.com/180915-jitter-17.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 17 - 图像旋转</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter16" target="_blank" rel="noopener">Tutorial 16: Using Named Jitter Matrices</a></p></blockquote><p>本教程将学习如何使用 <code>jit.matrix</code> 的 name 属性将来自多个源的矩阵数据写入同一矩阵。我们还将研究如何在复制时缩放矩阵的大小，以及如何用 Max 低优先级队列来降低事件的优先级，以支持更耗时的任务。</p><p>教程 patch 分为五个彩色区域。中间（浅蓝色）区域包含两个 <code>jit.movi​e</code> 对象。<code>loadbang</code> 对象在 patch 打开时读取两个视频（rain.mov 和 traffic.mov）到 <code>jit.movi​e</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16a.png" alt=""></p><p>与之前的教程不同，这里的 <code>jit.movi​e</code> 使用 <code>send</code> 和 <code>receive</code> 对象与 patch 的其余部分通信。名为 m1 和 m2 的 <code>receive</code> 对象将消息转发给两个 <code>jit.movi​e</code>  对象。然后发送它们的输出矩阵（使用 <code>send</code>）到 patch 其他位置名为 movie1 和 movie2 的 <code>receive</code> 对象。</p><p> patch 顶部的黄色区域包含驱动 patch 中 Jitter 进程的 <code>metro​</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16b.png" alt=""></p><center><code>metro</code> 驱动两个消息框中的一个</center><p>点击开关启动 <code>metro</code> 。 patch 中的三个 <code>jit.pwindow</code> 开始显示图像。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p><code>metro</code> 经过 <code>Ggate</code> 和 <code>jit.qball</code> 到达 <code>gate</code>。 <code>metro</code> 发送的 bang 由 <code>gate</code> 分流到两个消息框之一。最终输出矩阵（在 patch 底部的 <code>jit.pwindow</code> 中）将根据哪个消息框被触发而改变。</p><p>单击连接到 <code>gate</code> 左入口的两个消息框（1 和 2）。注意底部的 <code>jit.pwindow</code> 如何变化：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16c.png" alt=""></p><center>最终输出矩阵根据 patch 的消息顺序而变化</center><p>两个消息框都将 bang 发送到三个命名相同的 <code>receive</code> 对象（m1，m2 和 output）。两者的区别在于发送消息的顺序。左侧消息框（由 <code>metro</code> 驱动，当 <code>gate</code> 设置为 1 时）将第一个 bang 发送到 <code>jit.movie</code> （rain movie）。最后，patch 底部的 <code>jit.matrix</code> 收到 bang，最终矩阵被发送出去。右侧消息框（由 <code>metro</code> 驱动，当 <code>gate</code> 被设置为 2 时）调换驱动 <code>jit.movie</code> 的两个 bang 的顺序（左 <code>jit.movie</code> 先输出矩阵，然后是右边的 <code>jit.movie</code>）。</p><p>当查看两个 <code>jit.movie</code> 和最终的 <code>jit.pwindow</code> 之间发生了什么时，这些消息发送的顺序才有意义。</p><blockquote><p>要点：如果不确定 Max patch 中发生事件的顺序，可以查看 patch 的 trace 的执行方式。在接线中设置断点就可以使用 “Auto Step” 命令逐步执行 patch ，查看它如何运行。但是这对于 <code>metro</code> 效果不好，因为 bang 将持续重启。先在  <code>metro</code> 位置添加按钮用于调试。</p></blockquote><h2 id="名字里面有什么？"><a href="#名字里面有什么？" class="headerlink" title="名字里面有什么？"></a>名字里面有什么？</h2><p>一旦 <code>jit.movie</code> 接收到 bang，就会向下面的 <code>send</code> 对象输出一个矩阵，然后传递给名为 movie1 和 movie2 的 <code>receive</code> 对象。<code>receive</code>（在 patch 右侧两个相同的区域）连接到 <code>jit.pwindow</code> 以及两个已命名的 <code>jit.matrix</code> 对象：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16d.png" alt=""></p><center>已命名的 <code>jit.matrix</code> </center><p> patch 右侧的两个 <code>jit.matrix</code>（以及 patch 底部 <code>jit.pwindow</code> 上方的 <code>jit.matrix</code>）都有名称。这三个对象的名称是 composite。它们共享包含在名为 composite 的矩阵中的数据。</p><p>理解了两个 <code>jit.movie</code> 将数据写入相同的矩阵（名称相同的两个独立的 <code>jit.matrix</code>），就明白为什么 bang 的顺序很重要。如果左边的 <code>jit.movi​e</code> 首先发出矩阵，它会将数据写入 composite 矩阵，然后是右边的 <code>jit.movi​e</code>，它将数据写入同一个矩阵。如果两个矩阵写入任何共同的单元格（见下文），那么最后到达的矩阵将覆盖之前单元格中的数据。</p><h2 id="目的地维度"><a href="#目的地维度" class="headerlink" title="目的地维度"></a>目的地维度</h2><p>教程 patch 右侧的两个 <code>jit.matrix</code> 对象将 <code>usedstdim</code> 属性设置为 1。这样可以缩放由 <code>jit.movie</code> 发送的矩阵，以便它们只写入 composite 矩阵的某个区域。</p><p>调整标记为 <code>x origin</code> <code>y origin</code> 的数字框，缩放它所连接的两个子 patch <code>p coords</code>。请注意 composite 矩阵如何移动和调整 <code>jit.movie</code> 中两个图像的大小。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16e.png" alt=""></p><center>图片内的图片</center><p><code>p coords</code> 包含相同的辅助 patch ，用于格式化 <code>jit.matrix</code> 对象的 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性。这些属性分别指定将数据复制到 composite 矩阵时的左上角和右下角坐标。<code>usedstdim</code> 属性告诉 <code>jit.matrix</code> 复制数据时使用这些属性。当 <code>usedstdim</code> 为 0 时，缩放输入矩阵以填充 <code>jit.matrix</code> 引用的整个矩阵。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16f.png" alt=""></p><center>写入共享矩阵之前先缩放输入矩阵</center><p>发送到子 patch 的三个数字由内部对象格式化，生成要填充的输出矩阵的左上和右下区域坐标列表。消息在输出前，用 $ 暂时替代列表中对应的数字参数。</p><p>在两个矩阵写入 composite 矩阵之后，最后一件事是发送 bang 到名为output 的 <code>receive</code> 对象：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16g.png" alt=""></p><center>最后的结果</center><p>教程 patch 底部的区域是第三个名为 <code>jit.matrix</code> 的对象。由 <code>metro</code> 发送的 bang 经过一个 <code>trigger</code> 对象发送 bang 到 <code>jit.matrix</code>（让它输出矩阵到 <code>jit.pwindow</code>），紧接一个 <code>clear</code> 消息（0），清除所有名为 composite 矩阵中的单元格。如果不清空矩阵，改变任何<code>jit.matrix</code> 的 <code>dstdimstart</code> 和<code>dstdimend</code> 属性，可能导致残留之前输出位置的图像。</p><h2 id="队列优先级"><a href="#队列优先级" class="headerlink" title="队列优先级"></a>队列优先级</h2><p>当 Max 运算跟不上速度时， patch 顶部的 <code>jit.qball</code> 对象就有了用武之地。<code>metro​</code> （每隔 50 毫秒发出 bang）正在触发三个独立的操作（从 <code>jit.movi​e</code> 对象写入数据到两个已命名的矩阵，显示数据，清空矩阵以便重新开始）。<code>jit.matrix</code> 写入数据到内部矩阵（这个例子中是 composite 矩阵）并允许后续消息来插队。运行任务时，它允许其他优先级更高的 Max 事件发生。这样可以在前一操作完成之前显示矩阵（或将更多数据写入），从而引起闪烁和其他意外结果。</p><p><code>jit.qball</code> 对象把消息放到 Max 低优先级队列的最后， 在那里其他消息可以被优先处理。如果 <code>jit.qball</code> 在所有当前任务完成之前从 <code>metro​</code> 得到 bang，它将等到队列中其他所有任务都完成后，再发出 bang。同样，如果另一个 bang 在发出第一个 bang 之前就出现了（即如果 patch 的剩余时间需要超过 50 毫秒才能完成所有事情），第一个 bang 将被抢先（抛弃）而只发出第二个 bang。这让我们可以放心地在 Max patch 中设置极值，而不必担心事件累积过快 Max 处理不过来。</p><p>单击标记为 <code>jit.qball bypass switch</code> 的 <code>Ggate</code> 对象，让 <code>metro​</code> 的输出绕过 <code>jit.qball</code> 。底部 <code>jit.pwindow</code> 中的合成图像开始闪烁，表示消息乱序到达。</p><p>通常，发送 bang 到 Jitter 对象将插到已经挂起的事件（例如已经到达但尚未被处理的 bang）前面。不过 <code>jit.qball</code> 提供了对多个 Jitter 对象链的控制，自动调度事件（dropframing）保证消息以正确的顺序到达。</p><blockquote><p>注：在大多数应用中 <code>Qball</code>已被 <code>qmetro​​</code> 取代。 <code>qmetro​​</code> 是内置 <code>qball</code> 机制的 <code>metro​​</code> 对象。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>命名多个 <code>jit.matrix</code> 为同一个名称，可以在 patch 的不同部分中写入和读取矩阵数据。使用 dstdimstart 和 dstdimend 属性，或者设定 usedstdim 属性为 1，可以在将其复制到 <code>jit.matrix</code> 内部时缩放矩阵。<code>jit.qball</code> 对象把 Max 事件放到低优先队列中来降低优先级，如果没有足够资源来执行，则优先处理其他事件。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p><center>👇👇👇</center></p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译17 - 图像旋转</title>
    <link href="http://uegeek.com/180915-jitter-17.html"/>
    <id>http://uegeek.com/180915-jitter-17.html</id>
    <published>2018-09-15T12:09:37.000Z</published>
    <updated>2018-09-25T07:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-8.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter15" target="_blank" rel="noopener">Tutorial 15: Image Rotation</a></p></blockquote><h2 id="使用-jit-rota-旋转和缩放"><a href="#使用-jit-rota-旋转和缩放" class="headerlink" title="使用 jit.rota 旋转和缩放"></a>使用 jit.rota 旋转和缩放</h2><p>Jitter 提供 <code>jit.rota</code> 对象来旋转和/或缩放图像。旋转和缩放是常见的视频效果，以不同方式组合它们还可以实现万花筒效果。<code>jit.rota</code> 在入口处获取视频数据矩阵（或其他类型的图像），根据对象属性的设置发送已缩放、旋转和以其他方式失真的版本。</p><p>打开教程 patch 。loadbang 触发 QuickTime 视频 dishes.mov 读入 <code>jit.movi​​e</code>。单击 “Display” 开关启动 <code>metro</code> 开始播放视频。</p><p>视频是一个对着餐盘拍摄的三秒从左到右平移镜头。<code>jit.movi​​e</code> 的循环属性初始化为 2，因此视频来回循环产生了来回平移的效果。</p><blockquote><p>注意：Jitter 对象的许多属性使用参数 1 和 0 表示 “on” 和 “off”，因此可以合理地假设 <code>jit.movi​​e</code> 的 loop 属性也是这样。loop 0 关闭循环，loop 1 打开，loop 2 让视频向前播放，到达 loopend 点时向后播放，而不是跳回到视频起点。</p></blockquote><p><code>jit.rota</code> 的 theta 属性指定围绕中心锚点的旋转角度。</p><p>拖动 “Rotation Angle” 数字框旋转视频。正（或增加）值是逆时针旋转，负（或减小）值是顺时针旋转。旋转角度 - 也就是角度（θ） - 以弧度表示。0 或 2π 的任何倍数（如 6.283185）是正常的直立位置。π 值（3.141593）或 π 的任何奇数倍是颠倒的位置。随意尝试，直到了解 theta 值与 <code>jit.rota</code> 行为之间的关系。</p><blockquote><p>技术细节：<code>jit.rota</code> 用三角法进行大量内部计算，以确定如何旋转图像。如果不是三角学迷，你可能不习惯用弧度来思考角度。平时我们更常使用度数，即一个完整的旋转是 360°。在三角学中更常使用弧度，完整旋转是 2π 弧度。这是因为半径为 1 的圆的周长恰好为 2π，可以用与单位圆相交的点来表示角度。（例如，从单位圆上的一个点开始并绕圆周移动 π/2 的距离，会得到 90° 角度 - 即 π/2 弧度的角度 - 从开始的地方以圆心为中心）</p><p>另外，在三角学中，角度的正变化是围绕单位圆逆时针旋转，而在日常生活中，把顺时针运动看做 “正” 或 “增加” 更符合惯例（如钟表时针的转动）。</p><p>因此，如果把度为单位的顺时针旋转，转换为以弧度表示，需要将度角乘以 2π，然后除以 -360。</p></blockquote><h2 id="自动旋转"><a href="#自动旋转" class="headerlink" title="自动旋转"></a>自动旋转</h2><p>除了手动旋转图像外，还可以编写自动化程序提供不断变化的旋转角度。在<a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">上一章</a>中，我们编写了一个名为 rotate 的子 patch，它使用 <code>line</code> 对象将色调旋转角度从 0° 增加到 360°。现在做类似的事情，但使用 bang 视频的 <code>metro</code> 来增加旋转角度。为了使用上的友好，用 ° 表示旋转角度，而不是弧度（在子 patch 中转换度弧度单位），另外也显示转速为 “每秒转数”。</p><p>在标有 Degrees per bang 的数字框中输入数字 6。这让旋转角度在 <code>metro</code> 每次 bang 时增加 6°。由于 <code>metro</code> 每秒发出 20 次 bang（每 50 毫秒一次），我们可以通过公式 <code>d * 20 / 360</code> 计算每秒的转数（即 d / 18，d 是每次 bang 增加的角度）。现在单击标记为 On / Off 的开关开始自动旋转。</p><p>双击 <code>rotate</code> 查看子 patch</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter15a.png" alt=""><br>[rotate]子 patch 中的自动旋转</p><p>用度数 * 2π / -360，将用户指定的每次旋转角度转换为弧度量。当一个 bang 进入左入口时，如果正在旋转，bang 让旋转角度增加并添加到 <code>accum</code> 对象中。请注意，每次增加负的角度也 ok，这让图像逆时针旋转。当总旋转角度超过 2π（或 -2π）时，<code>split</code> 将值发送到使用模运算的 <code>expr</code>，并在发送到出口前将其恢复到范围内（重置 <code>accum</code> 中的值）。如过旋转关闭，我们 用 <code>sel 0</code> 检测到该事件，将 theta 角度重置为 0。</p><p>关闭子 patch 窗口。单击 On/Off 开关停止自动旋转。</p><h2 id="放大或缩小"><a href="#放大或缩小" class="headerlink" title="放大或缩小"></a>放大或缩小</h2><p><code>jit.rota</code> 的另一个主要功能是缩放。缩放量由 <code>zoom_x</code> 和 <code>zoom_y</code> 属性决定。这样可以单独放大或缩小水平和垂直尺寸；或者一次更改两个属性来同时缩放。</p><p>拖动标有 <code>Zoom</code> 的数字框来放大和缩小。大于 1 的值会放大图像，小于 1 的值会缩小图像。直接在 x 和 y 数字框中输入值分别更改 x 和 y 的缩放尺寸（负缩放值会翻转图像并调整其大小）。</p><p>当放大图像（如值为 2）时，图像质量仍然不错，因为我们已经用 <code>interp 1</code> 消息打开 <code>jit.rota</code> 的插值属性。如果关闭 interp，会在放大时产生像素化。当缩小时 interp 没有明显的效果，它几乎浪费了计算资源。（有关像素化和插值，请参阅 <a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Jitter 教程16</a>）不过插值确实可以改善旋转图像的现实，即便图像缩小。</p><h2 id="超越边缘"><a href="#超越边缘" class="headerlink" title="超越边缘"></a>超越边缘</h2><p>将缩放的两个尺寸设置为较小的值例如 0.25。</p><p>当图像由于收缩或旋转而未填满整个显示区域时，<code>jit.rota</code> 必须决定如何处理位于图像区域外的矩阵的其余部分。现在 <code>jit.rota</code> 将图像区域外的所有单元格值设置为 0，使它们为黑色。<code>boundmode</code>属性决定 <code>jit.rota</code> 如何处理位于图像边界之外的单元格。不同的可用 <code>boundmode</code> 设置显示在 patch 右上角标记为 <code>Space outside the image</code> 的弹出菜单中。将 <code>boundmode</code> 的值初始化为 1，让 <code>jit.rota</code> 清除所有外围单元格。以下是每个 <code>boundmode</code>设置的含义：</p><blockquote><p>0 Ignor：保持所有外围单元格不变。</p><p>1 Clear：将所有外围单元格值设置为0。</p><p>2 Wrap：根据需要重复图像以填充矩阵。</p><p>3 Clip：对于所有外围单元格，继续使用图像边界单元格的值。</p><p>4 Fold：重复图像，向相反方向翻转。</p></blockquote><ul><li>对于缩小图像时的特殊效果，尝试将 <code>boundmode</code> 属性设置为 2（Wrap）以获得 “Warhol” 复制图像效果，或设置为 4（Fold）得到万花筒效果。</li><li>现在试着重新打开自动旋转，组合旋转和缩放，并修改参数（每次 bang 的度数、缩放、Space outside the image）。</li><li>尝试完以后，关闭自动旋转并将缩放属性（ <code>zoom_x</code>和 <code>zoom_y</code>）调整回 1。</li></ul><h2 id="调整锚点和偏移"><a href="#调整锚点和偏移" class="headerlink" title="调整锚点和偏移"></a>调整锚点和偏移</h2><p>目前为止，我们一直使用图像的中心作为旋转锚点。其实可以选择任意一点。用 <code>anchor_x</code> 和 <code>anchor_y</code> 属性设置旋转中心。现在是 160 和 120（图像尺寸的一半），可以在标记为 Anchor 的数字框中更改。</p><p>尝试不同的锚点，然后在 Rotation Angle 数字框上拖动查看效果。可以尝试 0,0 或 40,30 或 160，-120 或 320,240。将 <code>boundmode</code>属性设置为 1 可以更清楚地看到不同旋转的效果。请注意，<code>anchor_x</code> 和 <code>anchor_y</code> 值是相对于矩阵的左上角指定的，但它们可以超出矩阵维度的边界。</p><p>此外可以用 <code>offset_x</code> 和 <code>offset_y</code> 属性在缩放和旋转后，将图像移动到输出矩阵中的其他位置。</p><p>要最有效地查看此内容，请先单击 patch 右下角的 <code>pvar</code> 对象上方的消息框。这会将旋转角度/边界模式/缩放/锚点恢复到本章开头的设置。（已经为相关的 UI 指定了名称，以便通过 <code>pvar</code> 与它们通信）现在将缩放数字框设置为 0~1 的某个值来缩小图像。</p><p>使用 Location offset 数字框，更改 <code>offset_x</code>和 <code>offset_y</code> 值来移动图像。同时设置 <code>boundmode 4</code>，在 “kaleidoscope” 模式下查看效果。</p><p>完成后，将位置偏移值重置为 0。</p><h2 id="鼠标控制旋转"><a href="#鼠标控制旋转" class="headerlink" title="鼠标控制旋转"></a>鼠标控制旋转</h2><p>我们为你设计了另一种旋转图像的方法。</p><p>单击 <code>jit.pwindow</code> 显示对象，按住鼠标，围绕对象中心以小圆周运动拖动。</p><p><code>jit.pwindow</code> 跟踪鼠标移动，当鼠标按下时，它会以鼠标消息的形式将坐标信息（和其他鼠标信息）发送到右输出口。鼠标消息的前两个参数是相对于 <code>jit.pwindow</code> 左上角的 x 和 y 坐标。使用这些坐标来计算鼠标相对于 <code>jit.pwindow</code> 中心的角度并发送到 <code>jit.rota</code> 作为theta 属性的参数。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter15b.png" alt=""><br>用 <code>jit.pwindow</code> 中的鼠标位置作为控制信息</p><h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>想知道这是如何计算的吗？</p><p>如果将 <code>jit.pwindow</code> 的中心点视为原点 0,0，把当前鼠标位置看做是位于该点圆周上的点，那么可以基于这两点得到一个直角三角形。获取鼠标坐标 y / x 的反正切值，得到鼠标相对于 <code>jit.pwindow</code> 中心的角度。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter15c.png" alt=""></p><p>接收到传入的 x 和 y 坐标要做的第一件事是做转换，使它们以 <code>jit.pwindow</code> 为中心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr<span class="number">-1.0</span>*atan(($i1<span class="number">-160.</span>)/(<span class="number">-1.</span>*$i2+<span class="number">119.5</span>))+($i2&gt;=<span class="number">120</span>)*<span class="number">-3.141593</span></span><br></pre></td></tr></table></figure><p>用 x 坐标减去 160 （x 值现在在 -160~160）并将 y 坐标乘以 -1（这样上移时值正向增大）然后加上 119.5。（如果正好添加120，那么每次从 <code>jit.pwindow</code> 得到 120 的 y 坐标时都会尝试在 expr 中除以0，这是一个未定义的数学运算）转换了 x 和 y 坐标，用 <code>atan(y / x)</code> 来获得弧度，然后乘以 -1 使鼠标顺时针旋转，从而使图像顺时针旋转。</p><p>此方法仅在 180° 范围内有效，因为反正切函数无法区分鼠标位置与圆上相对点之间的差异（这两个点 y / x 的值相同）。因此每当鼠标的 y 坐标进入 <code>jit.pwindow</code> 的下半部分时，我们在 θ 角度上添加 -π 的偏移量来区分那些来自另外一边的位置。（表达式中的最后一部分）</p><p>请注意，此表达式仅适用于 <code>jit.pwindow</code> 中的点 160,120。如果想创建一个适用于任何大小 <code>jit.pwindow</code> 中心点的表达式，要使用 <code>getsize</code> 消息获取 <code>jit.pwindow</code> 的维度，并用 size 值作为表达式中的变量。正如书上所说，“我们把这个练习留给读者”。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.rota</code> 对象用 theta 属性指定旋转角度，以弧度表示旋转图像。它还提供了使用 <code>zoom_x</code>和 <code>zoom_y</code> 属性放大和缩小图像的简便方法。用 <code>anchor_x</code>和 <code>anchor_y</code> 属性更改旋转的中心点，用 <code>offset_x</code> 和 <code>offset_y</code> 属性在输出矩阵中移动生成的图像。可以用 <code>boundmode</code> 属性更改 <code>jit.rota</code> 处理位于结果图像之外的矩阵单元格的方式。结合这些功能，除了缩放和旋转之外，你还可以获得重复图像和万花筒效果。</p><p>缩放和旋转涉及 <code>jit.rota</code> 相当密集的内部计算，这些操作对计算机的处理器提出了很高的要求。本教程中未提及的其他属性，可以调整旋转公式中的几乎每个系数，提供更多扭曲和旋转图像的可能性。请查看 <code>jit.rota</code> 文档说明。</p><p>要同时管理对如此多属性，可以设计自动流程以生成属性值，和/或交互式控件来更改值。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译16 - 矩阵定位</title>
    <link href="http://uegeek.com/180909-jitter-16.html"/>
    <id>http://uegeek.com/180909-jitter-16.html</id>
    <published>2018-09-09T11:02:52.000Z</published>
    <updated>2018-09-25T07:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-7.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter14" target="_blank" rel="noopener">Max 7 - Tutorial 14: Matrix Positioning</a></p></blockquote><h2 id="在矩阵中数据定位"><a href="#在矩阵中数据定位" class="headerlink" title="在矩阵中数据定位"></a>在矩阵中数据定位</h2><p>本教程将讨论如何获取矩阵的一部分数据，放到另一个矩阵中不同位置。要重新定位数据的原因可能有很多。这里讨论的技巧主要为了生成各种视觉效果，但对于其他目的也适用。</p><p>我们将展示如何分离矩阵的一个区域，将其放到另一个矩阵中的指定位置，调整大小（对于拉伸、像素化和模糊等视觉效果非常有用）并动态移动它。</p><h2 id="jit-window"><a href="#jit-window" class="headerlink" title="jit.window"></a>jit.window</h2><p>打开 Window_options 子 patch</p><p>在 patch​ 左下角有一个<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">教程 3</a> 介绍过的 <code>jit.window</code> 对象。它创建一个单独的窗口来显示矩阵内容。在大多数其他教程章节中都使用 <code>jit.pwindow​</code>。</p><p><code>jit.window</code> 和 <code>jit.pwindow​</code> 非常相似 - 除了一个是打开单独的窗口而另一个使用 Patch 中的矩形区域 - 它们有许多相同的属性和消息。但也有一些差异，这将使用 <code>jit.window</code> 来展示一些特性。</p><p>你可能看不到 <code>jit.window</code> 打开的 Display 窗口，因为它隐藏在 Patch 窗口后面。我们可以让 Display 窗口浮动 - 一直在浮动在 Max 每个窗口之上，同时仍然与 Patch 窗口交互。为此要用 <code>floating 1</code> 消息打开 <code>jit.window</code> 的浮动属性（默认为 0）。</p><p>打开 Window_options 子 patch​ ，单击标记为 <code>Display as floating window</code> 开关，将 <code>floating 1</code> 消息发送到 <code>jit.window</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14a.png" alt=""><br>使窗口“浮动”在其他窗口前面</p><p>输入到 <code>jit.window</code> 的屏幕坐标 - <code>450 60 770 300</code> - 指定了 320 像素宽，240 像素高的显示区域。（如何为 <code>jit.window</code> 指定屏幕坐标，请参阅本章后面的说明和/或<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">教程 3</a>）</p><h2 id="从一个-jit-matrix-到另一个"><a href="#从一个-jit-matrix-到另一个" class="headerlink" title="从一个 jit.matrix 到另一个"></a>从一个 jit.matrix 到另一个</h2><p>现在加载图片并尝试修改。</p><p>单击消息框 <code>importmovie sunset.jpg</code> 将图片加载到 patch 顶部的 <code>jit.matrix</code> 中。打开标有 <code>Display On/Off</code> 的 <code>metro</code>，开始向 <code>jit.matrix</code> 发送 bang。</p><p>用 <code>jit.window</code> 显示图像之前，bang 将矩阵（通过 <code>jit.hue</code>）发送到第二个 <code>jit.matrix</code>。在那里能够修改属性以指定显示矩阵的哪个部分。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14b.png" alt=""><br>发送矩阵给另一个 <code>jit.matrix</code>，然后到 <code>jit.window</code> </p><p>我们已经在 patch​ 中间的 <code>preset</code> 中为 UI 对象保存了几个配置。</p><p>选择 <code>preset</code> 中的配置 1 会发送 <code>dim 16 12</code> 消息将下方的 <code>jit.matrix</code> 的尺寸更改为 16x12。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14c.png" alt=""><br>dim 消息改变<code>jit.matrix</code>的维度</p><p>输入矩阵的尺寸是 320x240，但是接收 <code>jit.matrix</code> 的尺寸仅为 16x12，它尽可能显示接收的矩阵，但必须丢弃大部分信息。这会导致图像像素化（指用低分辨率 - 较小的像素 - 来显示图像时产生的马赛克效果）。即使 <code>jit.window</code> 能够显示全分辨率 320x240 的图像，它接收的矩阵现在只有 16x12。出于显示目的，它按需复制像素，将 16x12 矩阵「扩展」为 320x240。</p><p>拖动标有 “Change actual matrix dimensions” 的两个数字框，查看不同的像素化效果。</p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>现在将数字框设置回 16 和 12，然后单击标记为 <code>Interpolate in window to smooth pixelation</code> 的开关将 <code>interp 1</code> 消息发送到 <code>jit.window</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14d.png" alt=""><br>在 <code>jit.window</code> 中打开插值</p><p>现在由 <code>jit.window</code> 在输入矩阵和扩展到 320x240 之间插值，而不是复制 16x12 像素来制作一堆 20x20 像素块。也就是说，当它扩展图像时，在每个单元格值与其输入矩阵中的相邻值之间，创建平滑的颜色渐变，因此 320x240 矩阵中从一个单元到另一个单元的所有变化都尽可能渐进发生。插值会产生极大的模糊，因为输入和输出矩阵的大小差异很大。</p><p>再次点击开关，发送 <code>interp 0</code> 消息给 <code>jit.window</code> 设置 interp 的属性为 0（关闭）。在标记为 <code>Change actual matrix dimesions</code> 的数字框中输入新的矩阵尺寸，减少图像像素化：例如，80 和 60（现在像素化块每个只有 4x4）。点开关重新开启插值。请注意，在这种情况下模糊减轻了，因为插值只发生在 4 个像素上。再次关闭插值。</p><p>现在点击标记为 <code>Interpolate in matrix to smooth pixelation</code> 的开关，打开 <code>jit.matrix</code>（而不是 <code>jit.window</code>）的插值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14e.png" alt=""><br>减小矩阵的大小时，插值就不明显</p><p>这没有太大变化。因为 <code>jit.matrix</code> 仍然只能发送 80x60 矩阵。在这种情况下的插值（缩小而不是放大矩阵时）可以忽略不计。</p><p>再次点开关关闭 <code>jit.matrix</code> 的插值。</p><h2 id="隔离矩阵的一部分"><a href="#隔离矩阵的一部分" class="headerlink" title="隔离矩阵的一部分"></a>隔离矩阵的一部分</h2><p>在 <code>preset</code> 中，选择配置 2。现在只能看到图片的一小部分。</p><p>这个配置将 <code>jit.matrix</code> 的尺寸恢复为 320x240。但是仍然可以使用一些属性来隔离矩阵的特定部分而不改变整个矩阵的实际尺寸： <code>srcdimstart​</code> ，<code>srcdimend​</code> 和 <code>usesrcdim</code>。</p><p>向 <code>jit.matrix</code> 发送三条新消息来设置这三个属性：<code>dimstart 40 150</code>，<code>dimend 119 209</code> 和 <code>usesrcdim 1</code>。这些消息指定输入矩阵的子集，并将这些值作为全尺寸（在本例中为 320x240）矩阵发送出去。输入矩阵的这个子集在 <code>jit.matrix</code> 「扩展」（按需复制单元格），以填充输出矩阵的大小。<code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性被忽略。</p><p>设置 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性的消息中，单词紧跟的是描述每个维度内起点和终点的单元索引。<code>dimstart 40 150</code> 和 <code>dimend 119 209</code> 消息告诉 <code>jit.matrix</code> 在水平维度中使用来自单元格 40~119 的特定 80x60 区域，在垂直维度中使用单元格 150~209。</p><blockquote><p>本章中讨论了三种指定矩形区域的方法！关键要明确每种情况下指定的内容。</p><ul><li><p>在 <code>jit.window</code> 中输入显示区域的坐标。在计算机的操作系统中，屏幕坐标原点在左上角，是 0,0; 往右两个像素（左起第三个像素）是 2,0; 该点向下 5 个像素（向下的第六个像素) 是 2,5。输入矩形的左-上-右-下的参数坐标描述屏幕的矩形区域。</p></li><li><p><code>jit.matrix</code> dim 属性指定维度大小（单元格数量）。</p></li><li><p><code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性指定单元格索引（包含）。单元格索引从 0 到单元格数量 - 1（平面的索引也类似）。对于 320x240 矩阵，第一维中单元格索引从 0~319，第二维索引从 0~239。对于 <code>jit.matrix</code> 的维度，用 <code>srcdimstart​</code> 后跟起始单元格索引，来指定每个维度的起点，用 <code>srcdimend​</code>  后跟结束单元格索引，来指定终点。</p></li></ul></blockquote><p>输入矩阵仅有 80x60 像素，而目标矩阵为 320x240。较小矩阵扩展为较大矩阵会导致像素化。但是现在扩展发生在 <code>jit.matrix</code> 内部（即在它的“源”区域和“目标”大小之间），而不是在 <code>jit.matrix</code> 和 <code>jit.window</code> 之间（正如之前减小 <code>jit.matrix</code> 尺寸）。如果想通过插值来平滑像素化，必须在 <code>jit.matrix</code> 中完成。在 <code>jit.window</code> 中启用插值没有意义，因为它已经从 <code>jit.matrix</code> 接收到 320x240 矩阵。</p><p>要验证这一点，请打 <code>interpolate in window...</code> 开关发送 <code>interp 1</code> 到 <code>jit.window</code>。因为我们试图将 320x240 矩阵插入到 320x240 显示区域，因此不会发生任何变化。关闭开关，将 <code>jit.window</code> 差值属性设置回 0。现在用另一个开关将 <code>interp 1</code> 消息发送到 <code>jit.matrix</code>。现在得到了我们想要的平滑效果。</p><p>尝试输入新值来更改 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性的参数。这样可以将图片的任何特定区域隔离为“源”区域。为源区域选择的尺寸将决定图片在扩展到填充 320x240 输出矩阵时的失真程度。</p><h2 id="翻转图像"><a href="#翻转图像" class="headerlink" title="翻转图像"></a>翻转图像</h2><p>你可能认为 <code>srcdimend​</code> 属性的参数（源区域的终点单元索引）应该大于 <code>srcdimstart​</code>。并非如此。</p><p>选择 <code>preset</code> 的配置 3 垂直翻转图片。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14f.png" alt=""><br>顶部和底部在第二维中翻转</p><p>如果在垂直维度中指定小于起始索引的结束单元格索引，<code>jit.matrix</code> 仍将这些索引与目标矩阵的垂直维度中的起点和终点相关联，从而有效地反转值的方向。</p><p>可以在水平维度中进行翻转以水平翻转图像。如果在两个维度上翻转源区域，会得到将图像旋转 180° 的视觉效果。</p><p>选择 <code>preset</code> 的配置 4。</p><p>这个例子在两个维度上翻转了源区域，将大小减小到 160x120 ，并打开 interp 属性来平滑像素化。</p><h2 id="调整输出矩阵的大小"><a href="#调整输出矩阵的大小" class="headerlink" title="调整输出矩阵的大小"></a>调整输出矩阵的大小</h2><p>既然可以指定矩阵的源区域，那么也可以指定目标区域。这仍然不会改变输出矩阵的大小，dim 属性为 320x240。但是会更改源区域所在的区域。输入矩阵的源区域，将被放置在输出矩阵的目标区域中（按需扩展/收缩）。位于目标区域之外的输出矩阵的单元将保持不变。</p><p>选择 <code>preset</code> 的配置 5。整个输入矩阵被挤压到输出矩阵中心的 80x60 矩形中。</p><p>首先要注意的是 <code>usesrcdim</code> 属性已被关闭，因此我们再次使用整个输入矩阵作为源（现在忽略 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性）。<code>usedstdim</code> 属性已打开，输入将被放在输出矩阵的任意指定部分。<code>dstdimstart</code> 和 <code>dstdimend</code> 属性指定矩阵中间的单元为目的地：<code>dstdimstart 120 90</code> 和 <code>dstdimend 199 149</code>。我们关闭了 interp 属性，因为现在正在收缩图像。</p><p>另外，我们已打开标记为 <code>Erase previous image</code> 的开关。这将数字 1 发送到 <code>if $2 then clear</code> 对象。该语句的 if 部分现在为 true ，因此每次对象在左入口处收到消息时，将发送 <code>clear</code> 消息。这会在显示图像后立即清除 <code>jit.matrix</code> 对象的内容，为将要接收的下一个 <code>jit.matrix</code> 准备。这样可以确保目标区域外的所有单元格的值都为 0，输出矩阵的未使用区域将显示为黑色。</p><p>更改指定目标尺寸的数字框中的值，在 Display 窗口中移动（并调整尺寸）图片。</p><p>关闭标记为 Erase previous image 的开关停止 <code>clear</code> 消息。更改 <code>dstdimstart</code> 和 <code>dstdimend</code> 的参数，注意这次有什么不同。之前的目标区域仍然在 Display 窗口中绘制，因为矩阵中的那些单元格尚未清除，如果它们位于新目标区域之外，将保持不变。这样产生了前面图像的残留效果，可进一步获得特定的视觉效果。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14g.png" alt="">            </p><h2 id="在矩阵中移动图像数据"><a href="#在矩阵中移动图像数据" class="headerlink" title="在矩阵中移动图像数据"></a>在矩阵中移动图像数据</h2><p>自动设置 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性过程，我们可以在矩阵中移动数据，使图像看起来在实时移动。</p><p>选择 <code>presets</code> 的配置 6。</p><p>这将启动 <code>move_around​</code> 子 patch 内部的自动过程，持续提供新的参数给 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性。用 patch 上方的开关启动，数字框为每次移动到新目的地指定时间（以毫秒为单位）。</p><p>双击 patch <code>move_around​</code> 查看子 patch 内容。目前为止我们只使用了子 patch​ 的右半部分。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14h.png" alt=""><br>子 patch [<code>move_around​</code>] 中的目标移动过程</p><p>右入口中的 rate 值是 <code>metro</code> 的时间间隔。定期触发 4 个 <code>random</code> 对象，随机选择新的左-上-右-下索引。这些目标点与时间值一起发送到 <code>line</code> 对象，再以每 50 毫秒间隔发出，把目标区域逐步转移到这些新的随机点（显示图像的速率）。在子 patch​ 之外，这些值用作 <code>jit.matrix</code> 的 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性的参数。</p><p>这个子 patch​ 包含一些值得注意的技巧。第一个技巧我们已经实现过，它让 <code>dstdimend</code> 的参数可以超过矩阵的 320x240 范围。例如，使用 <code>random 640</code> 对象作为水平维度，然后从结果中减去 160，得到从 -160~479 的结束单元格索引。这样做是为了增大目标区域，以便图像变化时看到较大的视图，这也意味着图像将更频繁地移动到窗口边缘。值得注意的是，可以指定超出矩阵实际单元格的目标边界，<code>jit.matrix</code> 能够在该区域内完整显示图像（当超出矩阵尺寸时裁剪）。</p><p>第二个技巧比较细节：使用 <code>sel 0</code> 对象来检测 <code>metro</code> 何时关闭，用它来触发每个 <code>line</code> 对象的 <code>stop</code> 消息，以便它们在自动流程关闭后不会继续发送值。</p><p>关闭 [move_around​]子 patch​ 窗口。</p><h2 id="更改，调整大小和移动源图像"><a href="#更改，调整大小和移动源图像" class="headerlink" title="更改，调整大小和移动源图像"></a>更改，调整大小和移动源图像</h2><p>现在我们也将更改源图像自动化。</p><p>选择 <code>presets</code>的配置 7。</p><p>与设置目标区域的方式大致相同，现在需要不断改变图像的源区域。我们现在看到源矩阵的一些矩形子集的动画视图（使用 <code>srcdimstart​</code> 和 <code>srcdimend​</code>），不断调整该视图的大小并在窗口中移动它（使用 <code>dstdimstart</code> 和 <code>dstdimend</code>）。由于[<code>move_around​</code>]子 patch​ 随机选择源矩形和目标矩形，因此图像有时也会被翻转。<code>jit.matrix</code> 的插值属性已经打开，平滑源图像被拉伸时出现的像素化。</p><p>要更清楚看到变化，打开标记为 <code>Erase previous image</code> 开关。</p><h2 id="关于尺寸的更多信息"><a href="#关于尺寸的更多信息" class="headerlink" title="关于尺寸的更多信息"></a>关于尺寸的更多信息</h2><p>本教程介绍了如何更改 <code>jit.matrix</code> 的维度，以及如何在对象中指定源和目标区域。为了便于讨论和可视化，我们在二维矩阵内指定源矩形和目标矩形。这也可以用于任意维度的矩阵。（<code>srcdimstart​</code> ，<code>srcdimend​</code> ，<code>dstdimstart</code> 和 <code>dstdimend</code> 的参数个数对应于 <code>jit.matrix</code> 的维度）。 例如，如果有一个三维矩阵，这些参数可用于指定矩阵的虚拟 3D 空间中的六面体。</p><blockquote><p>注意：某些专门处理 2D 矩阵的 Jitter 对象（例如 <code>jit.movi​​e</code>），源和目标区域将始终为矩形区域。在这些对象中，源区域和目标区域在名为 srcrect 和 dstrect 的单个属性中定义，这些属性用四个参数来指定矩形的边界（左上角和右下角）单元格。</p></blockquote><h2 id="Hue-Rotation"><a href="#Hue-Rotation" class="headerlink" title="Hue Rotation"></a>Hue Rotation</h2><p>为了增添一点多样性，在两个 <code>jit.matrix</code> 中间增加 <code>jit.hue</code> 对象。（<a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">教程 9 详细介绍了 <code>jit.hue</code></a>）</p><p>选择 <code>presets</code>配置 8 并查看正在运行的 <code>jit.hue</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14i.png" alt=""><br>修改色调角度</p><p>这个配置关闭 <code>usedstdim</code> 但打开 <code>usercdim</code>，并在 <code>jit.matrix</code> 中启用插值以模糊扩展的图像。rotate 子 patch 自动旋转 <code>jit.hue</code> 的色相角度。</p><p>双击打开 rotate 查看子 patch。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14j.png" alt=""><br>[rotate]子 patch​ </p><p>右入口的值指定完成 360° 色调旋转的时间（以毫秒为单位）。当 1 进入左入口时，数字 360 与该时间值组合，指示 <code>line</code> 对象在该时间内从 0 到 360，每 50 毫秒发出一个新的值。</p><p>请注意，<code>line</code> 的第一个 typed-in 参数包含一个小数点，说明 <code>line</code> 发送浮点数而不是整数以提高精度（而且 <code>jit.hue</code> 的 hue_angle 消息接收浮点数）。当<code>line</code> 到达 360，右出口发出 bang。用它将 <code>line</code> 设置回 0，然后 re-bang <code>pack</code> 对象开始下一个旋转。当左入口处接收到 0 时，<code>sel 1</code> 对象直接将其传递到 <code>line</code> 停止重置色调角度为 0。</p><p>关闭[rotate]子 patch​。</p><p>选择 <code>preset</code> 配置 9。它基本上整合了 patch​ 中所有自动化和图像处理技巧。这次 <code>jit.matrix</code> 的目标尺寸变化设置为 200 毫秒，以更快的速率产生效果。</p><h2 id="全屏显示"><a href="#全屏显示" class="headerlink" title="全屏显示"></a>全屏显示</h2><p>当你用 Max patch​ 创建了想要的图像，并想以更优雅的方式显示结果时，可以让 <code>jit.window</code> 全屏。它的 <code>fullscreen</code> 属性打开时，<code>jit.window</code> 使用整个屏幕作为显示区域。如果不勾选 inspector 中的 fsmenubar 属性，将隐藏菜单栏。</p><p>关于 <code>jit.window</code> 全屏功能，有几点需要注意。</p><p>首先，一旦全屏（特别是隐藏了菜单栏时），无法再使用鼠标退出全屏。所以需要在 Max patch​ 中设置让全屏属性恢复为 0 的方法。</p><p>其次，只有一个 <code>jit.window</code> 可以全屏。如果有多个 <code>jit.window</code> 对象争夺全屏访问权限，则最近将全屏属性设置为 1 的对象将填满屏幕。</p><p>此外，即使 <code>jit.window</code> 全屏，其分辨率也由其实际尺寸（即其 rect 属性的参数）决定。例如，如果 rect 属性指定了 320x240 的矩形，那会作为图像的分辨率，即使屏幕尺寸远大于此。</p><p>在 Window_options 子 patch​ 中，包含了使用空格键打开和关闭 <code>jit.window</code> 全屏属性的功能。<code>jit.window</code> 将 fsmenubar 设置为 0。这在全屏时隐藏顶部菜单栏（Mac）。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14a.png" alt=""><br>使用空格键切换到全屏显示</p><p>尝试使用空格键打开和关闭全屏。</p><p>要获得更抽象的视觉效果，请将 colorswatch.pict 图像导入到 patch 顶部的 <code>jit.matrix</code> 中，然后尝试不同的配置。</p><p>本教程使用静止图像作为源素材，以便查看演示效果，当然也可以使用视频。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>隔离和重新定位矩阵中的某些数据有不同的方法。<code>jit.matrix</code> 的 dim 属性设置矩阵的实际尺寸。<strong>打开 <code>jit.matrix</code> 的 <code>usesrcdim</code> 和 <code>usedstdim</code> 属性，可以使用输入和输出矩阵的指定区域</strong>，它们被称为源（source）和目的（destination）区域。</p><p>使用 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性指定这些区域的单元格边界（将起始和结束单元格设置为源区域的角点）和 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性（用于目标区域）。</p><p>这些属性不会改变矩阵的实际大小，当 <code>usercdim</code> 和 <code>usedstdim</code> 打开时，它们指定输入矩阵的某部分将显示在输出矩阵的哪个部分。如果源区域和目标区域的形状（大小）不同，<code>jit.matrix</code> 将扩展或收缩源区域以适合目标区域。这会导致重复或丢失数据，但可以产生有趣的拉伸或像素化效果。源区域和目标区域可以使用 Max patch​ 的其他部分的数字来动态更改，以便交互式或自动修改图像的大小、形状和位置。</p><p>interp 属性打开时，如果目标区域的尺寸大于源区域，<code>jit.matrix</code>  在它们之间插值（提供中间值）。这可以平滑像素化效果，并模糊相邻单元格的变化。</p><p><code>jit.window</code> 用已经指定的 rect 属性大小的矩形区域，显示它接收的任何尺寸的矩阵。如果输入矩阵的大小与显示区域的大小不同，图像将被 <code>jit.window</code> 扩展、缩小或扭曲。这也可以用于拉伸和像素化效果。 打开 <code>jit.window</code>  interp 时，可平滑拉伸和像素化。</p><p>要使用图像填充整个屏幕，可以打开 <code>jit.window</code> 全屏属性，并用 <code>fsmenubar 0</code> 消息隐藏菜单栏。（要留下一些方法让 Patch 窗口回到前台）</p><p>我们已经演示了调整矩阵数据的大小、重新定位、翻转和插值以生成视觉效果（如拉伸，扭曲，模糊和像素化）的技巧。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
</feed>
