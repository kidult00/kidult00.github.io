<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>00&#39;s Adventure</title>
  
  <subtitle>Why join the navy if you can be a pirate</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://uegeek.com/"/>
  <updated>2018-09-02T10:33:16.000Z</updated>
  <id>http://uegeek.com/</id>
  
  <author>
    <name>kidult00</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译10 - 交叉渐变</title>
    <link href="http://uegeek.com/180902-jitter-10.html"/>
    <id>http://uegeek.com/180902-jitter-10.html</id>
    <published>2018-09-02T10:29:21.000Z</published>
    <updated>2018-09-02T10:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-1.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter08" target="_blank" rel="noopener">Tutorial 8: Simple Mixing</a></p></blockquote><p>本教程介绍如何使用 <code>jit.xfade</code> 对象混合和淡入淡出两个图像。</p><h2 id="混合两个视频源"><a href="#混合两个视频源" class="headerlink" title="混合两个视频源"></a>混合两个视频源</h2><p>混合两个图像是视频处理中最常见和最有用的技巧之一。</p><p>最简单的视频混合是将两个图像叠加起来，可以调整任一图像的强度。逐渐淡出一个图像，同时淡入另一个图像，可以创建图像之间的平滑过渡淡入淡出效果。</p><p>Jitter 处理混合和过渡渐变的对象是 <code>jit.xfade</code>。</p><blockquote><p>技术细节：这种类型的混合，将一个矩阵中的每个值，加到另一个矩阵各单元和各平面的相应值上，并输出所有总和的矩阵。但这样让输出图像的值都大于任何一个输入图像，会比原始图像更亮（如果矩阵包含 char 数据，某些值甚至会在 255 处裁剪）。所以在它们相加之前应该减小一个或两个图像的强度。例如，为了按相同比例混合两个图像，在相加之前将它们缩小相等的量（例如，0.5 倍）。</p></blockquote><h2 id="jit-xfade"><a href="#jit-xfade" class="headerlink" title="jit.xfade"></a>jit.xfade</h2><p><strong><code>jit.xfade</code> 对象接收两个输入口的矩阵，缩放两个矩阵中的值，然后把两个矩阵相加并输出混合后的矩阵</strong>。两个输入矩阵缩放因子由 xfade 属性决定。xfade 是 1~0 之间单个（浮点） 数值，是右输入口矩阵的缩放因子。左输入口的矩阵按 1-xfade 的比例缩放。如果逐渐将 xfade 值从 0 增加到 1，输出矩阵将从左输入到右输入淡入淡出。</p><p>打开教程 patch。<code>loadbang</code> 对象自动读取两个源视频。开启<code>metro</code>。开始只会看到左侧视频。拖动滑块更改 xfade 值来控制左右矩阵的混合。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter08a.png" alt=""><br>值为 0.5 时左右矩阵以相同比例混合</p><h2 id="自动交叉渐变"><a href="#自动交叉渐变" class="headerlink" title="自动交叉渐变"></a>自动交叉渐变</h2><p>交叉渐变是最常见的图像转换方式之一。它可以非常缓慢 - 持续几秒 - 或者非常快速，只持续几分之一秒，只比突然跳帧略微平滑。</p><p>在 patch 左上角，有一个从视频 A 到 B （B 到 A）的自动渐变控制器。交叉渐变可以持续用数字框指定的任意过渡时间。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter08b.png" alt=""><br>自动发送不断变化的 xfade 值</p><p>用数字框设置一个比较长的渐变时间（例如 5000 ms），可以看到交叉渐变器的效果。单击 Go To 右侧的开关淡入视频 B。</p><p>Go To 开关实际上是一个范围为 2 的 <code>slider</code>和一个 <code>* 100</code>乘法器，所以只会发送 0 和 100 两个值。单击开关右侧发出值 100，<code>pack</code> 发出消息 <code>100 5000</code>，<code>line</code> 对象在五秒内发出 0~100 的连续值（每 50 毫秒一个新值）。然后将这些值乘以 0.01，得到平滑变化的从 0~1 的 xfade 值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>叠加两个矩阵是最简单的混合视频图像的方法。想要控制两个图像的混合比例，首先要按某个因子缩放每个矩阵。想从一个图像渐变到另一个图像，将一个图像的缩放因子从 1 减小到 0，另一个从 0 增加到 1。</p><p><code>jit.xfade</code> 对象专门混合和/或交叉渐变两个矩阵。xfade 属性指定两个矩阵之间的混合比例。<strong>将 xfade 值从 0 连续增大到 1 可实现平滑的交叉渐变。</strong>可以使用 <code>line</code> 或其他 Max 计时对象来自动化交叉渐变。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译09 - 调整图像颜色</title>
    <link href="http://uegeek.com/180901-jitter-09.html"/>
    <id>http://uegeek.com/180901-jitter-09.html</id>
    <published>2018-09-01T10:28:20.000Z</published>
    <updated>2018-09-01T10:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-9.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter07" target="_blank" rel="noopener">Tutorial 7: Image Level Adjustment</a></p></blockquote><p>本教程介绍如何调整 Jitter 矩阵中图像数据的亮度、对比度和饱和度，以及色调和色调旋转(hue rotation)的概念。</p><p>教程 patch 中有两个新对象：<code>jit.brcosa</code> ，控制矩阵中图像数据的亮度（brightness）、对比度（contrast）和饱和度（saturation），以及 <code>jit.hue</code>，旋转图像的色调。</p><h2 id="亮度，对比度和饱和度"><a href="#亮度，对比度和饱和度" class="headerlink" title="亮度，对比度和饱和度"></a>亮度，对比度和饱和度</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07a.png" alt=""><br>打开并查看图像</p><p>点击 <code>read colorwheel.pct</code> 消息框打开文件 colorwheel.pct。点击开关启动 <code>metro</code> 开始显示视频。</p><p>patch 底部 <code>jit.pwindow</code> 中会出现一个色轮：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07b.png" alt="">            </p><p><code>jit.pwindow</code> 展示了穿越过两个对象的图像。我们先谈谈 <code>jit.brcosa</code>，然后再到 <code>jit.hue</code>。</p><p><code>jit.brcosa</code> 对象将 4 平面 char 矩阵看作 ARGB 图像数据，可以调整矩阵数据的亮度、对比度、饱和度。三个属性的默认值是 1.0，这样矩阵保持不变：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07c.png" alt=""><br>使用 <code>jit.brcosa</code> 对象</p><p>更改 <code>jit.brcosa</code> 对象的属性并观察输出矩阵的变化。</p><p>与参考颜色（通常为黑色）相比，图像的亮度是指整体亮度/暗度。更改亮度属性相当于将矩阵中的值乘以该值。亮度值为 0 的图像是黑色；大于 1.0 的亮度值值将逐渐增加所有非 0 单元格直到白色（255）。值 0.5 使图像明显变暗，将值的范围从 0~255 降到 0~127。下面的色轮显示了一些亮度值：<br><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07d.png" alt=""><br>亮度值分别为 0.5，1.5 和 10 的色轮</p><p>用这种方式调整时，单元格的值会被裁剪为 0 和 255。这就是为什么亮度为 10 的那个图像基本上是白色，颜色只显示在原始矩阵中一/多个可见颜色平面（RGB 或平面 1,2 和 3）为 0 的区域。</p><p>图像对比度可以表示为<strong>图像中的颜色偏离整个原始图像的平均亮度的量</strong>（见下文）。当<code>jit.brcosa</code> 的对比度属性增加到 1.0 以上，高于整个矩阵平均亮度的单元变亮（增加），低于平均值的单元变暗（减少）。结果是矩阵图像 dynamic expansion，亮值更亮，暗值更暗。低于 1.0 的对比度设置则相反，较暗的色调变浅，较浅的色调变暗，直到对比度为 0.0，只保留整个图像的平均灰度。负值会以相同的总体对比度反转图像的颜色。</p><blockquote><p>技术细节：矩阵的平均亮度可以通过平均矩阵中所有单元格的值来计算，各平面互不干扰（获得 Alpha，red，green，blue 平面各自的平均值）。然后将三个平面乘以公式：</p><p><code>L = .299 * Red+ .587 * Green + .114 * Blue</code></p><p>L 值就是整个矩阵的平均亮度，<code>jit.brcosa</code> 用它来确定调整对比度时扩展的阈值。</p></blockquote><p>以下是一些对比度设置：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07e.png" alt=""><br>比度设定为 0.3，2，-1 和 100 的色轮</p><p>第一个例子中色轮的对比度急剧下降（单元格的值都接近矩阵的平均亮度）。第二个例子中对比度增加。请注意色轮中间较浅的色调开始接近白色。第三个示例显示了负值对比度。颜色与原始颜色相反，但矩阵的平均亮度与原始颜色相同。最后一个例子是大幅增强对比的结果。该示例中的单元值被极化为0 或 255。</p><p>图像饱和度反映了单元格中主要颜色与次要颜色的比率。随着饱和度值降至 1.0 以下，单元格中的所有颜色值将变得相似，变成去饱和的灰度。高于 1.0 的值将使颜色彼此远离，从而强化了主色。与对比度类似，饱和度属性的负值将反转颜色，但保留与原始颜色相同的亮度关系。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07f.png" alt=""><br>饱和度值为 0.2,2 和 -1 的色轮</p><p>第一个图像是去饱和的，矩阵中的每个单元格值都趋近于该单元格的亮度值。第二张图像过饱和，颜色比原始图像更亮（或更暗）。第三个图像保持色轮的原始亮度，但反转了颜色。</p><h2 id="Hue-and-Cry"><a href="#Hue-and-Cry" class="headerlink" title="Hue and Cry"></a>Hue and Cry</h2><p><code>jit.hue</code> 对象可以旋转输入矩阵的色调。设置 hue_angle 属性会将输入矩阵的色调旋转指定的度数（以度为单位）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07g.png" alt=""><br>hue_angle 属性旋转输入矩阵的色调</p><p>矩阵单元的色调可以看作是其基本颜色（例如，品红色）。图像色调在色轮上从红色变为绿色、蓝色，再变为红色。用 0-360 度数指定的色调值，以及图像的饱和度和亮度，可用描述特定的颜色，这与 RGB 值描述唯一颜色的方式非常相似。向前旋转图像的色调，我们移动颜色光谱的红色部分，使其显示为绿色，光谱的绿色部分显示为蓝色，蓝色部分显示为红色。饱和度和亮度不会改变。负色调旋转会将红色变为蓝色。以 120 度为增量的色调旋转将使图像与原始色调精确地移位一个（或多个）色彩平面。</p><blockquote><p>技术细节：我们的眼睛通过视网膜锥体的感知器来感知颜色（还有一种被称为 rods 的感知器专门探测微弱的光，但是不识别颜色）。我们眼睛的锥体响应三种不同波长的光来区分：L-senstive receptors 感知长波长的光（红色），M-senstive receptors 感知中波长光（绿色），以及 S-senstive receptors 感知短波长的光（蓝色）。跟听觉系统被加权以更好地感知人类语音范围内的频率一样，为了感知环境最关键的中间波长，我们的视锥细胞的分布也经过了加权处理。于是我们眼睛中的绿色感知器大约是其他两种颜色的两倍。所以上面的亮度公式将几乎 60％ 的感知亮度分配给图像中的绿色值。</p></blockquote><p>单击开关以自动化色轮的 hue_angle。请注意，当 hue_angle 达到 360 度时，会恢复原始矩阵图像。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07h.png" alt=""><br>色轮在各种色调之间旋转（0~360 度）</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.brcosa</code> 和 <code>jit.hue</code> 对象控制输入矩阵的亮度，对比度，饱和度和色调。你可以使用这两个对象调整动态水平（例如自动曝光），校正色彩或实现指定色调的位移。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译08 - 调整颜色</title>
    <link href="http://uegeek.com/180831-jitter-08.html"/>
    <id>http://uegeek.com/180831-jitter-08.html</id>
    <published>2018-08-31T11:04:49.000Z</published>
    <updated>2018-08-31T11:09:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-8.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter06" target="_blank" rel="noopener">Tutorial 6: Adjust Color Levels</a></p></blockquote><h2 id="jit-scalebias"><a href="#jit-scalebias" class="headerlink" title="jit.scalebias"></a>jit.scalebias</h2><p>本教程进一步讨论了<a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">上一章</a>的颜色话题，并介绍专门用于修改矩阵 ARGB 颜色平面的对象：<code>jit.scalebias</code>。</p><p>“scale” 是缩放因子，乘以给定的数值。”bias” 是加上一定的量来偏移某个值。组合乘法和加法，可以实现输入值到输出值的线性映射。</p><p>因为 <code>jit.scalebias</code> 修改图像中的 ARGB 颜色信息，所以它只处理 char 数据类型的 4 平面矩阵。（有关 ARGB 颜色和 char 数据的内容，请参阅 <a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">教程 7</a>）</p><h2 id="用-char-类型数据计算"><a href="#用-char-类型数据计算" class="headerlink" title="用 char 类型数据计算"></a>用 char 类型数据计算</h2><p><a href="https://www.uegeek.com/180830-jitter-06.html" target="_blank" rel="noopener">前一章讲到</a>，char （8位）数据可以表示 0~255 之间的整数值，或 0~1 之间的小数值。比如在<a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 中，我们用 <code>jit.print</code> 输出 0~255 的整数值。但是很多时候要修改矩阵的 char 值（更改其中一个属性）时，Jitter 对象只接收浮点数属性值。这可能有点费解，让我们来看看本教程的 patch。</p><p>打开教程 patch。双击打开中间的 <code>explain_scalebias</code>查看子 patch：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06a.png" alt=""><br>char 数据的浮点类型演示</p><p>在上面的例子中有一个非常小的矩阵。它有 4 个 char 平面，但只有一个单元。这样我们只需要注意矩阵中单个数值的变化。已将平面 2（绿色平面）的值设置为 100。在右侧，把整数值转换为 0~1 之间的小数值：用 100/255，得到 0~1 之间的值 0.392。</p><p><code>jit.scalebias</code> 对象乘上指定的缩放因子，然后再加上偏移因子。<code>jit.scalebias</code> 计算时会把所有值看做浮点数，然后再转换为 char 数据重新存储到矩阵中。</p><p>这里用 <code>scale 2.0</code> 和 <code>bias 0.2</code>消息来设置缩放和偏移因子。缩放因子（乘数）是 2.0，偏移因子（之后添加的偏移）是 0.2。为了了解 <code>jit.scalebias</code> 内部机制，将绿色值看做 <code>0.392 x 2.0 + 0.2</code>，等于 0.984。<code>jit.iter</code> 对象逐一输出每个单元中每个平面的值（矩阵只有一个单元），（以 char 类型存储在矩阵中）为 251（或是 0~1 范围的 0.984）。</p><p>（作为练习，请计算 <code>jit.scalebias</code> 在上面例子中在红色和蓝色平面中产生的值。在原矩阵中这些平面的值为 0，因此结果矩阵中的值将为 <code>0 x 2.0 + 0.2 = 0.2</code>，在 0~255 的范围内等于 51。因此底部的 <code>jit.pwindow</code> 对象显示的 RGB 值是 51 251 51）</p><h2 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h2><p>如果前一部分的讲解你已经理解得很清楚，可以跳过这部分。如果还是不太清楚 char 数据（特别是 <code>jit.scalebias</code>）的数学运算是如何工作的，这里还有一些例子。</p><p>从左到右逐个点击 <code>preset</code> 对象中的每个预设值。下面我们解释每个预设。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/tut%2006%20presets.png" alt=""></p><ol><li><p>原始矩阵的绿色平面中的值为 255.（相当于 0~1 范围的 1.0） <code>jit.scalebias</code> 将其乘以 0.5 得到 127.5; 但是将值存储为 char 时，<code>jit.scalebias</code> 会截断小数部分，将值存储为 127。</p><blockquote><p>这产生了相当不精确的结果。（0~255 范围的 127 等于 0~1 范围内的 0.498，而不是我们期望的 0.5）但用 8 位 char 数据只能这样了。如果需要更高的精度，char 数据就不适合，需要用 long，float32 或 float64 数据的矩阵，以及 <code>jit.op @op *</code> 和 <code>jit.op @op +</code> 对象。</p></blockquote></li><li><p>原始值为 100，将它加倍（缩放因子 2.0）会得到预期结果 200。这样不会有精度损失。</p></li><li>原始值为 100（0.392）。缩放 1.0 倍保持不变，然后加上 -0.2 （也就是减去 0.2）得到结果 49（即 0.192）。</li><li><code>0.392 x 2.0 + 0.2 = 0.984</code>。在 0~255 的范围内为 251。</li><li>此示例和下一个示例说明当乘法和加法运算的结果超过 8 位字符的容量时会发生什么。<code>jit.scalebias</code> 会直接裁剪结果为 char 的最大或最小值。这里，0.392 x 4.0  = 1.568（即 100x4 = 400），因此取上限为 255。</li><li>在另一个方向，0.392 - 0.5 = -0.108，因此结果为 0。</li></ol><p>注意，这些误差和裁剪只发生在将结果重新存储为 char 时。在此之前，这些值在内部用浮点数计算，可以保证精度。即使乘法使内部值超出0~1 范围，也不会做裁剪，而且加法运算可以让其回到范围。这里 0.392 x 3.0（= 1.176）- 0.5 = 0.676。存储为 char 时会产生小的误差。0.676 在 0~255 范围内等于 172.38，但是小数部分会被截断并存储为 172（即 0.675）。如果没有变化，比例因子应为 1，偏移量应为 0。</p><p>你可以尝试更多的值，直到完全了解 <code>jit.scalebias</code> 以及 8 位 char 数据产生的结果。完成后关闭 [explain_scalebias] 窗口。</p><h2 id="调整图像的颜色亮度"><a href="#调整图像的颜色亮度" class="headerlink" title="调整图像的颜色亮度"></a>调整图像的颜色亮度</h2><p>现在将 <code>jit.scalebias</code> 应用于彩色图像。在教程 patch 的左上角可以看到熟悉的配置：<code>jit.movi​​e</code> 对象，加载视频的 <code>read</code> 消息，和从 <code>jit.movi​​e</code> 触发 jit_matrix 消息的 <code>metro</code>对象。在这个 patch 中，<code>jit.scalebias</code> 用乘法和加法来修改矩阵。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06b.png" alt=""><br>加载图片或视频</p><p>点击 <code>read chilis.jpg</code> 读取 JPEG 静态图像（而非视频）到 <code>jit.movi​​e</code>。QuickTime 可以处理各种媒体格式，包括 PICT 或 JPEG 格式的静止图像。<code>jit.movi​​e</code> 将静止图像视为 1 帧长的视频。</p><p><code>jit.movi​​e</code> 的输出将传到 <code>jit.scalebias</code> 处理，然后显示在 <code>jit.pwindow</code> 中（现在先忽略 <code>jit.matrix</code> 对象。我们在本章后面讨论）。可以修改 <code>jit.scalebias</code> 的 scale 和 bias 属性来更改值。</p><p>点击开关启动 <code>metro</code>。拖动 <code>scale $1</code> 消息框上方的数字框，将 scale 属性值增加到 1.25。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06h.png" alt=""></p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06c.png" alt=""><br>增加图像亮度; scale 值越大亮度越大</p><p>这将使图像的 4 个平面的所有非零值放大到 1.25 倍（增加 25％）。请注意，乘法会让较大的被乘数增加更多值。例如，如果原始矩阵中某单元格的红色值为 200，它将增加到 250（净增加 50），而同一单元格的蓝色值可能从 30 增加到 37（净增加 7）。</p><ul><li>尝试将 scale 增加到非常大，如 20。原始矩阵中 13 或更大的值将被增大到最大值 255（甚至非常小的值也会增加到可见水平），产生人为的过度曝光。</li><li>尝试将 scale 降低到 0~1 之间。这会使图像变暗。scale ≤ 0 会将所有值设置为 0。</li><li>将 scale 属性恢复为 1。现在尝试调整 bias 属性，为矩阵中所有值添加常量。正值使图像变亮，负值使图像变暗。</li></ul><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06d.png" alt=""><br>以常量提升（或降低）亮度</p><p>还可以尝试几种更极端的 scale 和 bias 设置。设置 scale 为 40，bias 为 -20。这会将几乎所有值推到 255 或 0，除白色或黑色之外仅留下少数颜色。尝试设置 scale 为 -1，bias 为 1。高低值会互换，反转颜色。继续降低 scale（比如 -4 或 -8）会产生类似的反转，但只有原始值较低的值才会被正 bias 提升回 0~1 范围。</p><h2 id="单独调整平面"><a href="#单独调整平面" class="headerlink" title="单独调整平面"></a>单独调整平面</h2><p>你可以用 scale，abias，rscale，rbias 等属性在 <code>jit.scalebias</code> 中单独调整每个平面中的亮度。</p><p>将 scale 设置回 1，将 bias 设置回 0。然后提供新的值来独立调整每个颜色平面。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06e.png" alt=""><br>调整每个颜色平面的亮度</p><p>这里有一个可以同时调整三个颜色平面缩放比例的控制器，让过程更具交互性。单击或拖动 <code>swatch</code> 对象时，它发送一个表示鼠标所在位置 RGB 颜色值的列表。这些值之前以 0~255 范围表示，现在已经被改为 0.0~1.0 的值（如果需要，inspector 中有一个复选框可选择用旧样式输出）。用 <code>unpack</code> 拆分列表为三个单独的浮点数来改变 <code>jit.scalebias</code> 的 rscale，gscale 和 bscale 属性 。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06f.png" alt=""><br>用 <code>swatch</code> 的值作为 <code>jit.scalebias</code> 的属性</p><ul><li>拖动 <code>swatch</code> 同时缩放 RGB 三个平面。这会产生 0~1 范围内的缩放值来降低所有亮度，让图像稍微变暗。</li><li>可以在不同图像上尝试这些操作。读取其他彩色图像如 colorswatch.pict 或 wheel.mov， 并尝试调整颜色亮度。</li></ul><h2 id="重新分配矩阵的平面"><a href="#重新分配矩阵的平面" class="headerlink" title="重新分配矩阵的平面"></a>重新分配矩阵的平面</h2><p>在<a href="https://www.uegeek.com/180830-jitter-06.html" target="_blank" rel="noopener">上一个教程</a>中，我们使用 <code>jit.unpack</code> 和 <code>jit.pack</code> 来重新组合矩阵的平面。使用 <code>jit.matrix</code> 对象的<code>planemap</code> 属性也可以做到。在这个例子中，用 <code>jit.matrix</code> 传递 <code>jit.movi​​e</code>的输出来演示如何设置 <code>planemap</code> 属性。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06g.png" alt="">        </p><p>用 <code>jit.matrix</code> 重新分配矩阵的平面</p><p><code>jit.matrix</code> 的 <code>planemap</code> 属性可以映射（分配）输入矩阵的任何平面到输出矩阵的任何平面上。planemap 后面跟的数字表示矩阵中有多少平面（在本例中为 4）。列表中的每个位置代表输出平面（第一个代表输出平面 0，第二个代表平面 1，等等），数字表示分配给它的输入平面。默认情况下，平面值为 0 1 2 3（等），输入矩阵中的每个平面都分配给输出矩阵中的同一平面。可以随意更改这些映射。例如，如果发送消息 <code>planemap 0 3 2 1</code> 给 <code>jit.matrix</code> ，会把输入平面 3 分配给输出平面 1（3 位于输出平面 1 的列表位置），把输入平面 1 输出到平面 3。这样就调换了图像的红色和蓝色平面。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/tut%2006%20planemap.png" alt="">    </p><ul><li><p>点击 <code>read wheel.mov</code> 消息框并启动 <code>metro</code> 显示视频。（设置<code>jit.scalebias</code> scale 属性为 1，bias 属性为 0，就可以在 <code>jit.pwindow</code> 中看到未改变的图像）在 patch 的右下角，单击<code>planemap 0 3 2 1</code> 消息框交换矩阵的红色和蓝色平面。单击消息框 <code>planemap 0 1 2 3</code> 恢复正常的平面映射。如果设置所有 RGB 输出平面设置为相同的输入平面，将在三个 RGB 平面中得到相等的值，从而产生灰度图像。</p></li><li><p>单击消息框 <code>planemap 0 1 1 1</code> 查看效果。三个 RGB 平面在列表中的值都是 1，因此原始的红色平面用来输出矩阵的所有 RGB 平面。用一个 <code>coll</code> 对象存储所有平面映射的组合，发送到 <code>jit.matrix</code> 来更改 <code>planemap</code> 属性。</p></li><li><p>双击 patcher <code>rotatecolorplanes</code> 查看子 patch。里面有一个 1 到 6 的计数器，逐一执行主 patch 中 <code>coll</code> 对象中的不同映射。（当它关闭时会发出数字 1 重置为默认平面映射）<br>  <img src="http://7xjpra.com1.z0.glb.clouddn.com/tut-06-counter.png" alt=""></p></li><li><p>点击主 patch <code>rotatecolorplanes</code> 对象上方的开关，以每秒切换一次设置的速率，逐一执行不同的平面映射。将右输入口上方的数字框更改为较小的值（例如 80），查看快速重新分配平面的闪烁效果。</p></li></ul><p>在下一章节中，你将了解如何使用 <code>jit.hue</code> 以更微妙的方式调整图像色调，以及使用 <code>jit.brcosa</code> 调整颜色的其他方法。</p><h2 id="读取和导入图像"><a href="#读取和导入图像" class="headerlink" title="读取和导入图像"></a>读取和导入图像</h2><p>在本教程 patch 中，将三种不同类型的图像加载到 <code>jit.movi​​e</code> 中：PICT 和 JPEG 静止图像，以及 QuickTime 视频。在视频对象中读入静止图像看起来有点奇怪，但 QuickTime 确实可以播放多种类型的媒体文件，<code>jit.movi​​e</code> 知道如何读取它们。（<code>jit.movi​​e</code> 还可以读入 AIFF 音频文件，用 start 和 stop 消息播放，用 time 属性跳转到不同的位置等等。当然这时看不到矩阵的任何视觉内容）</p><p><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">如教程 5 所示</a>，用 <code>importmovie</code> 消息加载静止图像到 <code>jit.matrix</code> 中很方便。用这种方式导入 QuickTime 视频，只有一帧存储在 <code>jit.matrix</code> 中。</p><p>在这个 patch 中，我们用 <code>jit.movi​​e</code> 加载所有图像。原因一是我们要加载整个视频（不只是视频的一帧）。原因二是想演示 <code>jit.matrix</code> 的 planemap 属性。矩阵有实际输入（左入口传入 jit_matrix 消息）时，<code>planemap</code> 属性才起作用。如果用 <code>importmovie</code> 直接导入图像到 <code>jit.matrix</code> ，<code>planemap</code> 不起作用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.scalebias</code> 用乘法和加法来修改 4 平面 char 矩阵中指定的平面（或所有平面）的值。scale 是矩阵中的每个值要乘上的缩放因子；bias 是乘法之后被加到每个单元的值。scale 和 bias 属性影响矩阵的所有平面。如果想一次只影响一个平面，请使用特定的属性例如 ascale，abias，rscale，rbias 等。</p><p>必须用浮点数定义这些属性值。当执行乘法和加法运算时，<code>jit.scalebias</code> 将 char 值视为 0~1 范围内的小数值，使用 floats 执行数学运算，然后将结果转换回 char（0~255 之间的整数）并存储。超出 0~1 范围的结果，在转换回 char 之前截取为 0 或 1。</p><p>可以用 <code>jit.matrix</code> 的 <code>planemap</code> 属性重新分配矩阵的平面。<strong><code>planemap</code> 的参数按顺序列出输出平面，列表中的值是要分配给每个输出平面的输入平面</strong>。例如，要将输入矩阵的平面 1 分配给输出矩阵的所有四个平面，属性应设置为 <code>planemap 1 1 1 1</code>。</p><p><code>jit.scalebias</code> 提供了强大的工具来调整 4 平面 char（ARGB 颜色）矩阵中的颜色值。下一章节将介绍更多此类工具。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译07 - ARGB 颜色</title>
    <link href="http://uegeek.com/180830-jitter-07.html"/>
    <id>http://uegeek.com/180830-jitter-07.html</id>
    <published>2018-08-30T10:00:18.000Z</published>
    <updated>2018-08-31T11:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-7.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter05" target="_blank" rel="noopener">Tutorial 5: ARGB Color</a></p></blockquote><h2 id="Jitter-中的颜色"><a href="#Jitter-中的颜色" class="headerlink" title="Jitter 中的颜色"></a>Jitter 中的颜色</h2><p>本节将讨论如何在 Jitter 中处理颜色，主要讲解用数字表示颜色，而不涉及把数字可视化为颜色。用数字表示颜色有许多方法，而关于色彩理论的全面讨论 - 光和物质如何产生色彩感觉 - 远远超出了本教程的范围。如果想了解颜色相关的理论和/或颜色数值表示的更多信息，可以查看参考书目。</p><p>本节重点说明 Jitter 表示颜色的方法，以及如何在矩阵中实现。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/tut5%20patch.png" alt=""></p><h2 id="颜色组成：RGB"><a href="#颜色组成：RGB" class="headerlink" title="颜色组成：RGB"></a>颜色组成：RGB</h2><p>混合红色，绿色和蓝色可以产生任意颜色 - 每种颜色都有一定的亮度（intensity）。这是「加法合成（additive synthesis）」 - 添加一定量的三原色光来生成颜色（与此相反的是减法合成：混合有色颜料，如油漆，吸收某些颜色的光并反射其余部分）。这样就可以用红色，绿色和蓝色相对应的频率强度来描述任意颜色。</p><p>在 Jitter 中一般用红色，绿色和蓝色的精确亮度组合来描述颜色。对于图像的每个像素 - 无论是视频，图片还是其他 2D 矩阵 - 至少需要三个值表示三原色。屏幕上的彩色图像一般使用至少 3 个平面的 2D 矩阵。</p><h2 id="Alpha-通道"><a href="#Alpha-通道" class="headerlink" title="Alpha 通道"></a>Alpha 通道</h2><p>第 4 个平面一般是 alpha 通道 - 它存储像素的透明度信息。Jitter 矩阵中一般都会包含颜色透明度的 alpha 通道。多数情况下，<strong>alpha 通道存储在平面 0（矩阵平面从 0 开始编号），RGB 值存储在 1,2 和 3 平面中</strong>。</p><h2 id="颜色数据：char，long-或-float"><a href="#颜色数据：char，long-或-float" class="headerlink" title="颜色数据：char，long 或 float"></a>颜色数据：char，long 或 float</h2><p>在计算机中用 8 位信息来表示每个基本颜色值。8 位能够表达 256（2 的 8 次幂）个不同值。如果分别用 8 位表示红色、绿色、蓝色，总共可以表示 16,777,216（2 的 24 次方）种不同颜色，足以覆盖人眼能够区分的所有颜色渐变。</p><p>因为 8 位分辨率已经可以表示所有基本颜色值，所以颜色信息矩阵 4 个平面中的值用 8 位 char 类型就足够了。当然 Jitter 也允许用 long，float32 或 float64 类型，只不过这会浪费内存。全帧视频图像要处理大量的像素（640x480 图像有 307,200 像素），为了节省内存和加快处理速度，最好使用 char 数据类型。</p><p>8 位 char 数据可以表示 0~255 之间的数字，或者 0~1 之间的灰度。包含 char 数据的 Jitter 对象，通常以 0~1 范围内浮点数的形式从其他 Max 对象接收数值。然后在内部计算时将浮点数转换为对应的 char 值（有一些例外，例如 <code>jit.op</code> 可以接收 0~1 的浮点数或右入口的 0~255 的整数）。关于在 Jitter 矩阵中使用 char 数据类型的更多内容，请参阅教程<a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">什么是矩阵？</a></p><h2 id="分离矩阵的平面"><a href="#分离矩阵的平面" class="headerlink" title="分离矩阵的平面"></a>分离矩阵的平面</h2><p>在示例 patch 的顶部有两个视频。一个是街机游戏，另一个是视频校准的标准颜色条。打开 <code>metro</code>对象（用来反复触发矩阵对象）可以查看。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05a.png" alt=""><br>观看视频或静止图像</p><p>单击 <code>metro 30</code>对象上方标有 “show movie” 的按钮查看视频</p><p>示例 patch 用 <code>jit.unpack</code> 对象将颜色信息矩阵分解为 4 个平面，可以单独查看和修改每个平面。与 Max 对象 <code>unpack</code> 将列表拆开成单个数字类似，<code>jit.unpack</code> 将多平面矩阵分解为单平面矩阵。可以输入参数来指定矩阵中有多少个平面，默认是 4 个平面，这是颜色数据的标准。想看到红色，绿色和蓝色屏幕的内容，就将平面 1,2 和 3 发送到 <code>jit.pwindow</code>。因为这里不关心 alpha，所以不显示平面 0。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05b.png" alt=""><br>将多平面矩阵拆为单平面矩阵</p><p>可以用三个单色图像查看每个颜色平面的内容。较亮的像素表示该颜色值较大。将每个矩阵发送到 <code>jit.op</code> 可以单独控制每种颜色的强度，并改变颜色平衡。然后将单个（改变后的）矩阵发送到 <code>jit.pack</code>，重新组合为 4 平面矩阵在 <code>jit.pwindow</code> 中显示。</p><p>尝试将绿色和蓝色的强度降低到 0.12，生成更偏红色的图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05c.png" alt=""><br>降低某些颜色的亮度来改变颜色平衡</p><h2 id="颜色交换"><a href="#颜色交换" class="headerlink" title="颜色交换"></a>颜色交换</h2><p>为了演示另一种技巧，将每个颜色平面发送到 <code>gate</code> 对象，这样每个矩阵都可以 <code>route</code> 到 <code>jit.pack</code> 的不同入口（颜色平面）。这样就重新定义了每个平面，并且从 patch 左侧的 <code>coll</code> 对象中选择选项来尝试所有可能的颜色组合。</p><p>拖动标记为 “Rotate RGB planes” 的数字框，尝试重新分配三个颜色平面。（请注意，平面 0 直接从 <code>jit.unpack</code> 发送到 <code>jit.pack</code> ; 它是触发矩阵输出到 <code>jit.pwindow</code>的 <code>jit.pack</code>的左入口收到的 <code>jit_matrix</code> 消息）如果选择 coll 中的选项 3，会得到如下结果：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05d.png" alt=""><br>重新分配各个颜色平面; 红色和绿色平面相互交换</p><p>上面的示例显示原始的绿色和蓝色平面减少为原来的 0.12，并在发送到 <code>jit.pack</code>之前，用 <code>gate</code> 调换红色和绿色平面，得到更偏绿色的图像。<code>coll</code> 对象包含 RGB 平面所有可能的排列组合。</p><p>双击 <code>coll</code> 对象可以查看其内容：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05f.png" alt=""><br>RGB 平面分配的排列组合</p><p>来自 <code>coll</code> 列表中的元素被 <code>unpack</code> 并发送给 3 个 <code>gate</code> 对象。发送到 <code>coll</code> 的数字也会发送给 umenu（标签模式）用单词显示颜色状态 - 现在显示为 “Green-Red-Blue”。</p><h2 id="颜色自动变化"><a href="#颜色自动变化" class="headerlink" title="颜色自动变化"></a>颜色自动变化</h2><p>让我们再来做一个颜色修改练习：制作不断更改颜色的缩放和旋转的自动化流程。</p><p>点击标记为 “Automate color changes” 的开关。三个颜色平面的缩放因子都在不断变化。双击 patch <code>colorgames</code> 对象查看子 patch 的内容。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05e.png" alt=""><br>[colorgames]子 patch</p><p>子 patch 用 <code>line</code> 对象为每个颜色缩放因子发送 0.5~1 的值。红色系数每 3 秒变化一次，绿色每 4 秒变化一次，蓝色每 5 秒变化一次（这三个 line 对象每 60 秒同步一次）。每隔 60 秒，<code>metro</code> 计数器会选择一个新的颜色组合。</p><p>你可以在不同的源图像上尝试所有颜色组合。回到主 patch，点击标记为 “Show movie” 的开关停止 <code>metro</code>。（也可以用这个开关来启动和停止 <code>jit.movi​​e</code> 播放视频。如果不需要观看，就没必要持续播放）现在点击标有 “Show colorbars ” 的开关来显示颜色栏。试着更改此图像上的 scale 和 rotation 系数。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当 <code>jit.window</code> 或 <code>jit.pwindow</code> 接收<strong>单平面</strong> 2D 矩阵时，会显示为单色（灰度）图像。当接收到 <strong>4 平面</strong> 2D 矩阵时，会将平面解析为 alpha，red，green 和 blue 值并显示相应颜色。<strong>Jitter 最常用 ARGB 4 平面矩阵来表示颜色。</strong></p><p>Jitter 颜色数据以 char 数据类型存储，因为所有基本颜色只需要 8 位精度就可以完全覆盖。大多数与 QuickTime 相关的对象（例如 <code>jit.movi​​e</code>）和许多专门用于操作颜色的对象（例如 <code>jit.brcosa</code> 和 <code>jit.colorspace</code>）都使用 4 平面 char 数据的 2D 矩阵。（许多对象会自适应其他数据类型。如有疑问请查看相应文档）。<strong>char 数据的范围是 0~255 的证书，或者 0~1 的浮点数</strong>。大多数情况下，包含 char 数据的对象从其他 Max 对象接收 0~1 的浮点数值。</p><p><strong><code>jit.unpack</code> 可以拆分多平面矩阵为单平面矩阵。<code>jit.pack</code> 打包单平面矩阵成一个多平面矩阵。</strong>单独处理每个平面可以控制图像的色彩平衡，甚至可以重新定义各个平面。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译06 - 控制视频播放</title>
    <link href="http://uegeek.com/180829-jitter-06.html"/>
    <id>http://uegeek.com/180829-jitter-06.html</id>
    <published>2018-08-29T13:15:21.000Z</published>
    <updated>2018-08-29T13:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-6.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter04" target="_blank" rel="noopener">Tutorial 4: Controlling Movie Playback</a></p></blockquote><p>本教程讲解在 Jitter 中播放 QuickTime 视频的进阶知识。我们将学习如何获得正在播放的视频的信息，以及如何更改速度、音量和循环点来控制视频的播放。</p><p>你应该已经熟悉 patch 中的两个 Jitter 对象： <code>jit.movi​​e</code> 和 <code>jit.pwindow</code>。其余部分尝试改变已加载到 <code>jit.movi​​e</code> 对象中的视频的播放行为。</p><p>patch 的左边部分我们很熟悉了：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04a.png" alt=""><br>打开并播放视频</p><p>点击消息框 <code>read crashtest.mov</code>，打开文件。</p><p><code>jit.movi​​e</code> 一读入视频就开始播放。这个视频有配乐，因此视频加载后会立即听到音乐。视频配乐由计算机内置音响而不是 MSP 播放。如果不希望听到声音，可以将消息框 <code>vol $</code> 的数字 1 改为 0。</p><p>即使视频正在播放，<code>jit.pwindow</code> 没有显示任何东西，因为 <code>jit.movi​​e</code> 需要 bang 消息才能发送矩阵到 <code>jit.pwindow</code>。单击连接到其入口的开关，启动 <code>metro</code> 对象。这时视频图像出现在 <code>jit.pwindow</code> 中。先忽略 <code>gettime</code> 消息，等会我们会提到。</p><h2 id="获取视频信息"><a href="#获取视频信息" class="headerlink" title="获取视频信息"></a>获取视频信息</h2><p><code>jit.movi​​e</code> 打开新的视频时，会读取视频的大量信息（包含在视频的标题中），包括视频的长度、有多少帧、播放速度等。我们用这些元数据来控制视频播放。</p><blockquote><p>要点：与许多可手动设置或由对象本身设置的 Jitter 属性不同， <code>jit.movi​​e</code> 的许多属性都依赖于当前的视频文件。不同视频生成不同的设置。</p></blockquote><p>要对 QuickTime 视频做的第一件事是读取元数据属性。可以向 <code>jit.movi​​e</code> 发送 <code>get</code> 消息来检索。然后解析对象最右输出口的响应消息。我们需要的信息是帧速率，时间单位(time scale)（一秒钟内 “QuickTime 时间单位” 的数量），持续时间（QuickTime 的单位），播放速率和音量。这些都通过带有 <code>getfps, gettimescale, getduration, getrate, getvol</code>的消息框获得。</p><p>让 <code>jit.movi​​e</code> 打开一个视频并播放时（发送<code>read</code>消息），它会向右输出口发送一条消息，告诉你它已找到视频并知道如何播放。如果要将打印对象连接到 <code>jit.movi​​e</code> 的右输出口并重新加载影片，会在 Max Console 中看到：<code>read crashtest.mov 1</code>。</p><p>在这个 patch 中，<code>jit.movi​​e</code> 的右输出口连接了一个 <code>route</code> 对象。加载成功后它收到 <code>read</code> 消息并传递给 <code>unpack</code> 和 <code>select</code>，再触发 <code>get</code>消息。如果无法找到 crashtest.mov 文件，会在文件名后看到 1 以外的数字，并且不会发出请求。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04b.png" alt=""><br>自动查询 <code>jit.movi​​e</code> 对象</p><p>除了捕获 <code>read</code> 消息之外，<code>route</code> 对象在接收到视频信息后做分发。Jitter 属性一般都由在 patch 中设置为相同格式的对象输出：属性的名称，后跟需要设置的信息。<code>route</code> 出口连接了数字框，以显示分发的值。虽然还不知道那些值代表什么，但是每次 <code>jit.movi​​e</code> 成功加载新视频时都会显示属性。</p><h2 id="开始，停止和减速"><a href="#开始，停止和减速" class="headerlink" title="开始，停止和减速"></a>开始，停止和减速</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04c.png" alt=""><br>一些简单的视频播放控件</p><p>patch 的顶部有一些可以更改 <code>jit.movi​​e</code> 回放行为的控件。向 <code>jit.movi​​e</code> 发送 <code>stop</code>消息，将在视频当前帧停止播放。发送 <code>start</code> 消息将从上次停止的位置恢复播放。视频播放停止时，视频文件中的所有音轨也都将停止。停止和启动视频对 <code>jit.movi​​e</code> 对象的矩阵输出没有影响，该输出仍然由 <code>metro</code> 对象控制。如果在开启 <code>metro</code> 的情况下停止播放视频，仍将以 <code>metro</code> 的速度收到新的矩阵对象（这里是每秒 25 次），虽然所有矩阵都是相同的。</p><p>更改视频的速率将改变音视频内容的播放速度。正的速率值使视频向前播放，值为 1 表示正常播放速度。负值将使视频倒退，速率为 0 将停止播放。<code>jit.movi​​e</code> 的速度属性以浮点数为参数，因此值 0.5 会使视频播放速度减半，值 -2.3 以超过两倍的速度向后回放。调整这个值时，音轨会加速、减速、向后播放，跟视频保持同步。一旦视频到达其最后一帧（或回放时的第一帧），它将循环到文件的另一端。将 <code>jit.movi​​e</code> 的 loop 属性设置为 0（无循环），1（常规循环）或 2（回文循环），可以更改此行为。</p><p><code>vol</code> 属性控制视频音轨的音量（响度）。1 为全音量，0 将关闭声音。</p><p>加载视频时，速率和音量属性都由 pathc 中间的消息框初始化。它们会给出每个 QuickTime 影片中存储的值。</p><h2 id="时间属性"><a href="#时间属性" class="headerlink" title="时间属性"></a>时间属性</h2><p>之前查询了三个属性：duration，timescale 和 fps，告诉我们视频文件如何处理时间。Duration 说明了视频的总长度。这个值不以毫秒或帧表示，而是以 QuickTime 时间单位表示。每个时间单位的实际长度，取决于视频的时间单位。视频的 timescale 是每秒视频的分辨率。视频的duration / timescale 会得出视频的大致长度，以秒为单位。例如， crashtest.mov 文件有一个持续时间为 2836 个时间单位和 600 的 timescale。视频大约持续 4.73 秒。如果想要用 2 秒钟播放视频，可以将 <code>jit.movi​​e</code> 设置 <code>time 1200</code>（1200 时间单位除以 600 单位/秒的时间刻度得到 2 秒）。</p><p>视频中的 fps （或每秒帧数）说明每秒显示多少单独的视频图像。fps 越高，视频播放就越平滑（假设每帧都不一样）。常见的 fps 速率是15, 24, 29.97 和 30. 这个例子中的视频以每秒 15 帧的速度播放，也就是每 40 个时间单位，或大约每 66.7毫秒，会更新一个视频帧。如果用 crashtest.mov 的持续时间，除以视频中每帧的 time units，可以得到视频文件有 70 帧。如果需要，可以用 <code>getframecount</code> 消息查询 <code>jit.movi​​e</code> 视频中的总帧数。</p><h2 id="截取和循环"><a href="#截取和循环" class="headerlink" title="截取和循环"></a>截取和循环</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04d.png" alt=""><br>显示和设置当前播放帧</p><p>patch 底部区域包含两个进一步操作视频播放的控件。左侧的数字框显示视频当前正在播放的帧。该值由 patch 顶部的 <code>metro</code> 对象发送到 <code>jit.movi​​e</code> 的 <code>gettime</code> 消息更新; 每次输出新的一帧时，时间都会更新。如果停止视频传输（向 <code>jit.movi​​e</code> 发送 <code>stop</code>消息），可以拖动数字框来“截取”视频。视频会跳转到 <code>frame</code> 消息指定的参数那一帧。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04e.png" alt=""><br>设置视频中的循环点</p><p>用两个整数参数设置 <code>looppoints</code>属性，可以将循环点（指定循环开始和结束的时间值）发送到 <code>jit.movi​​e</code>。教程 patch 中的 rslider 可以指定 <code>jit.movi​​e</code> 的循环区间。在加载视频时查询属性，将 rslider 的大小设置为视频的时长。可以发送不带参数的  <code>looppoints</code> 消息重置循环点。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.movi​​e</code> 提供了一些简单的属性来改变 QuickTime 播放内容的方式。可以使用这些消息停止和开始播放视频。速度属性可以改变播放速度和视频播放的方向。使用 vol 属性控制视频音轨的音量。</p><p>查询 duration，time scale 和 fps 等属性可获取加载到 <code>jit.movi​​e</code> 中视频的属性。用 <code>frame</code> 消息可跳转到视频中的特定帧，并且可以设置和检索循环点。发送 <code>gettime</code> 消息可以查询视频的当前时间位置​​。</p><p>更多强大的功能（例如编辑和保存视频）将在后面的教程中讨论。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译05 - 矩阵的数学运算</title>
    <link href="http://uegeek.com/180828-jitter-05.html"/>
    <id>http://uegeek.com/180828-jitter-05.html</id>
    <published>2018-08-28T11:37:40.000Z</published>
    <updated>2018-08-29T13:22:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-5.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter03" target="_blank" rel="noopener">Tutorial 3: Math Operations on a Matrix</a></p></blockquote><p>本教程介绍如何对存储在 Jitter 矩阵中的数据做简单的数学运算，使用 <code>jit.op</code> 对象来缩放矩阵单元格或单个平面。</p><p>教程分为三个​​简单的例子，你可以使用 <code>jit.op</code> 对象执行这些操作。<code>jit.op</code> 对矩阵的所有对象而不是单个数字执行数学运算。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03a.png" alt=""><br>向矩阵中的所有单元格添加常量</p><p>第一个示例显示了连接到 <code>jit.op</code> 的 <code>jit.matrix</code> 对象，其输出可由 <code>jit.pwindow</code> 查看。每次改变连接到 <code>jit.op</code> 右输入口的数字框，都会从 <code>jit.matrix</code> 输出一个新的矩阵。从参数中可以看出，<code>jit.matrix</code> 生成一个 4x3 的单平面 char（0-255） 矩阵。<code>jit.pwindow</code> 把这个矩阵可视化为一个灰度图像。拖动数字框将改变显示的灰度级别（黑色 0 ~ 白色 255）。</p><p>请注意，<code>jit.matrix</code> 输出了一个所有单元格都为 0 的矩阵。如果将 <code>jit.matrix</code> 和 <code>jit.pwindow</code> 对象绕过 <code>jit.op</code> 连接在一起，无论向 <code>jit.matrix</code> 发送多少次 bang 消息，都只能看到黑色图像。<code>jit.op</code> 向 <code>jit.matrix</code> 和 <code>jit.op</code> 之间的矩阵的所有单元都加上了一个值（由数字框给定）。</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="@ 操作符"></a>@ 操作符</h2><p><code>jit.op</code> 根据参数指定的运算（用 @op 表示）向矩阵加了一个值（不是乘或除）。@op 之后的参数是一个符号（或符号列表），它定义了 <code>jit.op</code> 在输入矩阵上执行的数学运算。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03a.png" alt=""></p><p>在这个例子中，op 属性设置为 + ，它对从左入口输入的任何矩阵都执行加法操作。右侧入口中的整数值会加到矩阵中的所有单元格。这个值被称为标量（scalar），因为它向整个矩阵添加了相同的值（在教程 11 中我们会展示 <code>jit.op</code> 如何使用两个矩阵进行数学运算）。</p><blockquote><p>要点：更改 <code>jit.op</code> 右侧入口中的标量值不会输出新矩阵。如果断开数字框和按钮之间的接线，<code>jit.pwindow</code> 将停止显示任何新内容。原因在于，大多数 Jitter 对象与大多数 Max 对象一样，仅在数据进入其最左侧入口时才会输出数据。</p><p>在上面的例子中，每次更改数字框时 <code>jit.op</code> 都会存储新的标量值。此时按钮发送一个 bang 给 <code>jit.matrix</code>，让它将新的矩阵（所有值设置为 0）发送到 <code>jit.op</code> 的左入口，触发输出矩阵。</p><p>如果在按钮上方的接线上放置一个断点，然后 shift-cmd-T 逐步执行消息，就能看到它是如何运作的。（有关如何使用断点功能跟踪 Max 消息，请参阅教程：消息顺序和调试）</p></blockquote><p>使用 <code>jit.op</code> 的 val 属性，标量值也可以作为常量。例如，如果想要为矩阵的所有单元格添加 134，可以使用 val 属性并省去数字框：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03b.png" alt="">            </p><p>类似地，如果想要更改由任何给定的 <code>jit.op</code> 对象执行的数学运算，可以用消息 <code>op</code> 后跟数学符号，发送到对象的左入口。</p><h2 id="多平面数据的数学运算"><a href="#多平面数据的数学运算" class="headerlink" title="多平面数据的数学运算"></a>多平面数据的数学运算</h2><p>第二个示例显示了使用 <code>jit.op</code> 将值传入矩阵的更复杂的例子。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03c.png" alt=""><br>为矩阵的每个平面使用单独的标量</p><p>这个 patch 跟第一个类似，区别在于现在使用的是 4 平面矩阵。这由 <code>jit.matrix</code> 的第一个参数给出。<code>jit.pwindow</code> 现在有颜色了，它正在解析矩阵 α/红/绿/蓝 4 个单独存储颜色通道的平面。这个例子中的 <code>jit.op</code> 包含 op 属性的四个符号的列表：每个符号设置输入矩阵的一个平面的数学运算。在这个 patch 中，保留第一个（alpha）平面不做改动，而为其他 3 个平面做加法运算。</p><p><code>pak</code> 对象向 <code>jit.op</code> 右输入口传送四个打包的整数。<code>pak</code> 和 <code>pack</code> 的唯一区别是，当更改任何数字时，<code>pak</code> 都会输出一个新列表（<code>pack</code> 需要一个新数字或左侧入口的一个 bang 来触发输出新列表）。由 <code>pak</code> 生成的四个数字决定了传入 <code>jit.op</code> 矩阵的每个平面的标量值。</p><p>在上面的示例中，平面 0 没有添加任何内容（op 属性的第一个参数是 pass）。平面 1,2 和 3 将分别添加 161,26 和 254。<code>jit.pwindow</code> 将输出矩阵的单元格解析为洋红色（即使只看到一种颜色，矩阵中实际上有 12 个单元格，都设置为相同的值）。</p><blockquote><p>要点：如果<code>jit.op</code> 对象的 op 属性只有一个值（只使用一个数字作为标量），<code>jit.op</code> 将在输入矩阵的所有平面都使用该运算符号和标量值。</p></blockquote><h2 id="修改图像中的颜色"><a href="#修改图像中的颜色" class="headerlink" title="修改图像中的颜色"></a>修改图像中的颜色</h2><p>第三个例子说明如何在矩阵中使用 <code>jit.op</code>，这个矩阵已经存储了相关数据：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03d.png" alt=""><br>将单个平面与标量相乘</p><p>单击消息框 <code>importmovie colorbars.png</code>，<code>jit.matrix</code> 的 <code>importmovie</code> 消息将图像或 QuickTime 视频文件中的单帧图像加载到对象存储的矩阵中。它会将原图像缩放到矩阵的尺寸（320 x 240）。</p><p>单击按钮，<code>jit.pwindow</code> 中显示图像校准颜色条。这时 <code>jit.op</code> 的算术运算符设置为：alpha 平面不做修改（pass）， 其他平面设置为 *（乘）。这个矩阵有 4 个平面，因此使用 4 个浮点数列表设置每个标量。平面 1~3 中的值都是 1.，结果是显示原始的图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03e.png" alt=""><br>所有标量均为 1</p><p>如果将标量设置为 1.0，0 和 0.，会看到以下图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03f.png" alt=""></p><p>包含颜色条的矩阵的所有平面（平面 1 除外）都乘以 0。这将消除矩阵的α，绿色和蓝色平面，仅留下红色（平面 1）。</p><p>将中间值（例如 0.,0.,1. 和 0.5）设置为 <code>jit.op</code> 的标量，会得到颜色栏看起来不同的图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03g.png" alt=""></p><p>在这种情况下，忽略 alpha 通道并将红色通道归零。蓝色平面的值是它们的一半。绿色通道（平面 2）保持不变。</p><blockquote><p>要点： <code>jit.op</code> 中的一些数学标量使用浮点数，有些则使用整数。这取决于相关运算符（由 op 属性定义）以及输入矩阵的类型。本教程所有示例都使用了 char 矩阵，因此在添加时可以使用整数（任何浮点数都将被截断，因为矩阵数据保留 0-255 范围内的整数）。</p><p>如果使用 float32 矩阵作为输入，就需要添加浮点数。同样，用 char 乘以浮点标量的矩阵也可以（240 * 0.5 = 120，整数）。但是，由于 <code>jit.op</code> 输出的矩阵仍然是 char 矩阵（参见下面的注释），因此仍然只能获得 0-255 范围内的值。</p></blockquote><p>如果你尝试使用标量值，容易看到某些颜色条消失或与相邻条形图合并。这是因为颜色条都设置为范围相似的标准颜色值。如果一次只显示一个通道（设置一个平面为 1，其余为 0），顶部七个条形中的四个将显示颜色。</p><p>本教程中只演示了 + 和 * 运算符，实际上 <code>jit.op</code> 对象可以执行许多其他的数学运算。运算符的完整列表请查看参考文档，或双击 <code>jit.op</code> 帮助文件中的 p op_list 子 patch。</p><h2 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h2><p>创建 <code>jit.pwindow</code> 对象时，它默认显示为 80 像素宽，60 像素高。它可以像 Max 中的许多 UI 对象一样改变大小。如果要精确地指定大小，可以使用 inspector 或向其发送尺寸消息，后跟宽度和高度（以像素为单位）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03h.png" alt=""><br>更改 <code>jit.pwindow</code> 的大小</p><p>如果给某个固定尺寸（像素）的 <code>jit.pwindow</code> 发送不同的尺寸的矩阵，<code>jit.pwindow</code> 会按自身的大小来缩放传入的矩阵。如果将非常小的矩阵发送到非常大的 <code>jit.pwindow</code> ，会做像素化处理（图像中颜色完全相同的矩形区域）。如果发送大矩阵到一个小的 <code>jit.pwindow</code>，可能会丢失不同程度的细节。</p><blockquote><p>要点：在上面的示例中，含有颜色块的 <code>jit.matrix</code> 的大小（由其维度决定）为 320 x 240 个单元格，planecount 为 4，类型是 char。<code>jit.op</code> 对象（以及大多数 Jitter 对象）识别出信息并自动适配计算、输出相同规格的矩阵。</p><p>如果要更改 <code>jit.matrix</code> 的大小， <code>jit.op</code> 将立即识别变化并重新适应。<code>jit.pwindow</code> 也适配传入的矩阵，但方式略有不同。如果输入矩阵小于其自身的尺寸，则使用重复数据填充所有像素。（这会产生前一段中描述的像素化效果）如果输入矩阵大于其自身的维度，则必须忽略某些数据，只显示它可以显示的内容。因此，即使教程 patch 中的 <code>jit.pwindow</code>跟输入矩阵的大小不同，它们也会尽可能适配 <code>jit.op</code> 矩阵。</p><p>最后一个例子中的 <code>jit.pwindow</code> 尽可能显示了 <code>jit.op</code> 输出的整个矩阵，但它必须忽略所有其他行和列，以使其接收的 320x240 矩阵适合自己的 160x120 显示区域。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.op</code> 对矩阵上的所有数据进行数学运算。可以分别对矩阵单元格中的整体或每个平面执行计算。<code>jit.op</code> 的 op 属性决定要执行什么数学运算，可以输入 <code>@op [operator]</code> 属性参数，或者由左入口中的 <code>op [operator]</code> 消息提供。</p><p>对于多平面矩阵（例如彩色图片和视频），可以给出运算符列表（例如，op pass <em> </em> *）来指定每个平面的操作，并且可以为每个平面提供不同的标量值。在教程 11 中我们会看到如何使用矩阵来代替简单的标量。</p><p>你可以使用 <code>size [width] [height]</code> 消息设置 <code>jit.pwindow</code> 的大小。<code>jit.pwindow</code> 将尽可能适应接收到的矩阵的大小。如果输入矩阵小于其维度，它将复制数据；如果输入矩阵大于其自身维度，它将忽略某些数据。大多数 Jitter 对象都尽量适应它们接收的矩阵的维度、类型和平面数量。对 <code>jit.op</code> 而言，它没有自己的维度，所以它自动适配传入的矩阵大小。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="数学" scheme="http://uegeek.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译04 - 创建矩阵</title>
    <link href="http://uegeek.com/180826-jitter-04.html"/>
    <id>http://uegeek.com/180826-jitter-04.html</id>
    <published>2018-08-26T10:59:41.000Z</published>
    <updated>2018-08-29T13:22:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-4.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter02" target="_blank" rel="noopener">Tutorial 2: Create a Matrix</a></p></blockquote><h2 id="什么是矩阵？"><a href="#什么是矩阵？" class="headerlink" title="什么是矩阵？"></a>什么是矩阵？</h2><p>本教程讲解处理矩阵数据的方法。可以先回顾一下 <a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></p><p>矩阵用虚拟的网格来存储和修改大批的数值数据。数据存储在矩阵中，就可以通过网格位置查找，并指定整个矩阵或部分矩阵来批量修改多个值。</p><p>在<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">上一篇教程</a>中，我们使用 <code>jit.window</code> 对象打开一个窗口，并将矩阵的内容显示为彩色像素。</p><p>显示的矩阵来自 <code>jit.movi​​e</code> 对象，它用 QuickTime 视频的当前帧连续填充矩阵。<code>jit.window</code> 之所以能显示视频，只不过因为被告知要显示哪些矩阵的内容; 事实上，矩阵中的任何数值都可以显示。本教程通过一个更简单的例子帮助你理解矩阵，它是 Jitter 的核心思想。</p><p>以下是本节完整的 patcher 截图</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/02patcher.png" alt=""></p><h2 id="jit-matrix-对象"><a href="#jit-matrix-对象" class="headerlink" title="jit.matrix 对象"></a>jit.matrix 对象</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02a.png" alt=""><br>为单个 8 位值创建 16x12 存储空间</p><p><code>jit.matrix</code> 对象创建矩阵并在内存中声明存储空间，以便我们存储和检索数值，并打印或显示出来。 <code>jit.matrix</code> 的参数包括：</p><ul><li>[name]（可选，本例中未包含）</li><li>[planecount]（在矩阵的每个单元格中存储多少个值）</li><li>[type]（用多少个字节来表示每个数字）</li><li>[dim]（维度，描述矩阵的大小）</li></ul><p>括号 [] 里面应填入实际的赋值。上面的例子创建了 1 个平面（每个矩阵单元包含 1 个数字）、尺寸为 16x12（共 192 个单元格）的 char 型（单字节值）矩阵。由此可以推断出矩阵能够保存 192 个单独的数值，每个值的范围是 0~255（单个字节的范围）。</p><blockquote><p>注意：在 Max 中用 x，y（宽度，高度）格式描述二维矩阵的维数，先给出水平维度的范围，然后是垂直维度。这跟视频和计算机屏幕坐标处理尺寸的方式一致（例如，640x480 视频图像）。即，先说明有多少列（宽），再说明有多少行（高）。需要注意，Jitter 描述行和列，与线性代数中描述矩阵的惯例（先表示行，然后是列）不同。</p></blockquote><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02a.png" alt=""></p><p>回到例子中，一个按钮连接到 <code>jit.matrix</code> 的入口。当 Jitter 对象在左入口接收到 <code>bang</code> 消息时会发送矩阵名称，这个按钮会触发 <code>jit.matrix</code> 发送它的矩阵名称（以 <code>jit_matrix</code> 消息的形式）。</p><h2 id="jit-print对象"><a href="#jit-print对象" class="headerlink" title="jit.print对象"></a>jit.print对象</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02b.png" alt=""><br>打印 <code>jit.matrix</code> 的内容</p><p>在 <code>jit.matrix</code> 下面有一个新的 Jitter 对象：<code>jit.print</code>。它在入口处接收矩阵名称（<code>jit_matrix</code> 消息）并格式化矩阵的值，以便在 Max Console 中打印。它将格式化的值打印到 Max Console，就像 Max 的 <code>print</code> 对象一样，然后在 <code>jit_matrix</code> 消息中以矩阵名称的形式传递出来。</p><p>单击标记为 “output” 的按钮，这会让 <code>jit.matrix</code> 传递矩阵名称给 <code>jit.print</code>，后者格式化值并在 Max Console 中显示：<code>jit_matrix [somename]</code>。左边的单词表示这是由 <code>jit.print</code>  对象打印的，这是 <code>jit.matrix</code> 出口的结果。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/max%20console.png" alt=""></p><p>因为我们没有指定矩阵的名称（没有指定 <code>jit.matrix</code> 的第一个输入参数），所以 <code>jit.matrix</code> 自己会生成唯一名称（类似 “u330000007”）。这里我们并不关心名称是什么，但它能够告诉 <code>jit.print</code> 对象要显示哪个矩阵的数据。</p><p>上图显示了来自 <code>jit.print</code> 矩阵中的所有值，按 16 列和 12 行整齐排列。它们现在都是 0，因为我们还没有在矩阵中填充任何内容。</p><h2 id="在矩阵中设置和查询值"><a href="#在矩阵中设置和查询值" class="headerlink" title="在矩阵中设置和查询值"></a>在矩阵中设置和查询值</h2><p>在<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">上一章</a>中，我们知道如何使用 QuickTime 视频中的彩色数据帧自动填充整个矩阵。还可以将数值放置在矩阵的特定单元格中，并从特定位置检索。</p><p>在下面的例子中，<code>jit.matrix</code> 上方有一些消息框，可以设置和获取矩阵中的值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02c.png" alt=""><br>消息 setcell 和 getcell 可以访问矩阵中的特定值</p><p>使用 <code>setcell</code> 消息可以在特定的矩阵位置中存储值。语法是： <code>setcell [cell coordinates] val [value（s）]</code>。</p><p>例如， <code>jit.matrix</code> 消息 <code>setcell 0 0 val 127</code> 会将矩阵的第一个单元格（即左上角的单元格）的值设置为 127。每个维度中对单元格坐标的编号从 0 开始，最大值比维度小 1。在此矩阵中，x 维度中的位置编号为 0~15，y 维度中的位置编号为 0~11。因此右下角的单元格坐标是 15 11.</p><p><code>pack 0 0 0</code> 对象组合多个数字提供给<code>setcell</code> 消息发送给 <code>jit.matrix</code>。首先设置想要存储值的 x 和 y 位置，然后指定要存储在那里的值。当 x 和 y 位置为 0 0 时，用标有“value” 的数字框发送 127 到 <code>pack 0 0 0</code> 的左侧入口。这将触发消息 <code>setcell 0 0 val 127</code> 发送给  <code>jit.matrix</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02d.png" alt=""><br>消息 <code>setcell 0 0 val 127</code> 设置单元位置 0,0 的值为 127</p><p>（如果矩阵中有多个平面，可以在单元格的特定/所有平面中设置值）</p><p>为了演示之前提过的单元格位置编号，现在尝试将消息 <code>setcell 15 11 val 255</code> 发送到 <code>jit.matrix</code>。在 “X position” 下面的数字框输入 15，在 “Y position” 下面的数字框输入 11 ，在 “value” 下面的数字框输入 255。然后点击 “output” 按钮查看矩阵的变化。<code>jit.print</code>在 Max 控制台中打印出整个矩阵。请注意，单元格位置 0,0 和 15,11 中的值已变为 127 和 255。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02e.png" alt=""><br>消息 <code>setcell 15 11 val 255</code>将单元格位置 15,11 的值设置为 255</p><p>在 Patch 窗口中，你可能已经注意到黑色矩形区域的变化。它的左上角和右下角已经改变了。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02f.png" alt=""><br><code>jit.pwindow</code> 对象显示的数值为颜色（或灰度值）</p><p>该区域是一个名为 <code>jit.pwindow</code> 的用户界面对象。在添加对象面板中可以找到它：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02g.png" alt=""><br>对象选项板中的 <code>jit.pwindow</code> 图标</p><p>在添加对象面板中单击或将其拖动到 patch 窗口时，它会创建一个小的矩形对象（可以拖动对象右下角调整尺寸）。它在功能上与 <code>jit.window</code> 非常相似，区别是它在 Patch 窗口中显示矩阵数据，而不是在一个单独的窗口。</p><p>于是我们看到数值显示为颜色（char 数值范围是 0~255）。矩阵中只有一个平面，所以是单色（即灰度）。0 表示黑色，其他值是某种灰度，最大值255 是白色。因此，单元格 15,11 的 255 值显示为白色，0,0 的 127 值显示为黑色和白色之间的 50％ 灰色。</p><p>你可能会觉得这样填充矩阵相当繁琐。没错。所以 Max 允许我们编写程序来自动填充。</p><h2 id="以算法方式填充矩阵"><a href="#以算法方式填充矩阵" class="headerlink" title="以算法方式填充矩阵"></a>以算法方式填充矩阵</h2><p>双击 <code>patcher  fillmatrix</code> 对象打开子 patch。它将不同的数字传入数学表达式，生成 192 个不同的值到矩阵中的每个单元。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02h.png" alt=""><br>通过算法生成值来填充矩阵的单元格</p><p>当 <code>uzi 12</code> 对象收到 <code>bang</code>（点击主 Patch 窗口中标记为 “fill” 的按钮）时，它会快速从右侧出口进行 1 到 12 计数，并向左侧出口发送每个计数的 bang。</p><p>那些 bang 触发了<code>uzi 16</code>对象，因此它每次都会发出 1~16 的数字。然后把这些数字减去 1，这样值的范围就限定在 0~11 和 0~15，输出的结果作为矩阵中的 y 和 x 位置。对于 12 个 y 位置中的每一个，<code>uzi 16</code>对象指定所有 x 位置，然后在数学表达式（expr）中使用这些数字来计算要存储在该位置的值。这些数字从 outlet 发送给主 patch 创建定义好的 <code>setcell</code> 消息，就像我们之前手动做的那样。</p><p>这里不需要关注具体的数学表达式。它可以生成任何公式。刚才我们用一个公式在每列中产生亮度的正弦梯度，这将让列的整体亮度从左向右增加（即随 x 增加）。</p><p>关闭 <code>patcher fillmatrix</code> ，然后单击标记为 “fill” 的按钮。矩阵在 Max 的 scheduler 的每个时钟节拍中填充值（由子 patch 中的 uzi 对象生成）。现在单击标有 “output” 的按钮查看矩阵的内容。数值将打印在 Max Console 中，并显示在 <code>jit.pwindow</code> 中。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/max%20console%20fill.png" alt=""></p><p>即使对于像 16x12 这样的小型矩阵，仅仅查看 Max Console 中的数字打印输出，我们很难看到数值数据的趋势。而 <code>jit.pwindow</code> 中的显示能够清楚而直观地展示值在矩阵中的变化情况。这是数据可视化的好处。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/output%20display.png" alt=""></p><p>你可以想象在 Max 中以算法方式填充矩阵的其他方法，我们将在后面的教程中演示。</p><h2 id="jit-matrix-可以响应的其他消息"><a href="#jit-matrix-可以响应的其他消息" class="headerlink" title="jit.matrix 可以响应的其他消息"></a>jit.matrix 可以响应的其他消息</h2><p><code>jit.matrix</code> 还可以接收许多其他消息。例如可以使用相同的值填充所有 <code>jit.matrix</code>。发送给<code>jit.matrix</code> 的 <code>clear</code>消息将所有值设置为 0，<code>setall</code> 消息（setall 后跟一个值）将矩阵中的所有单元设置为同一个值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02i.png" alt=""><br>查询矩阵位置 8,6 处的值; 报告单元格 8 6 val [value(s)]</p><p>还有 <code>getcell</code>消息。单词 <code>getcell</code> 后跟矩阵中的位置（x和y）会让 <code>jit.matrix</code> 将单元格坐标和该位置的值发送到右侧出口。</p><p>在 <code>getcell $1 $2</code> 消息框上方的数字框中输入 y 值，然后输入 x 值，并观察 Max Console 中打印的内容。请注意，该矩阵位置的值在 <code>jit.matrix</code> 的右侧出口输出。</p><p>在后面的教程中，你将看到从矩阵中检索值的各种方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.matrix</code> 对象可以为任何尺寸、平面数和数据类型的矩阵数据创建存储空间。该矩阵可以填充来自另一个 Jitter 对象（例如 <code>jit.movi​​e</code> ）的数据，或者用 <code>setall [value]</code>之类的消息来设置所有单元格中的值，或者 <code>setcell [position] val [value（s）]</code>来设置特定单元。可以使用 patch 中其他位置的算法根据公式或一组规则来填充矩阵。</p><p>要获取特定单元格中的数据，可以使用 <code>getcell [position]</code>消息。要查看在 Max Console 中打印的所有数值数据，请使用 <code>jit.print</code> 对象格式化矩阵数据并打印。要查看显示为颜色的矩阵数据，请使用 <code>jit.pwindow</code> 对象。这类似于<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">教程1</a>中演示的 <code>jit.window</code> 对象。</p><p>在本教程中，我们查看了自己生成的数据，而不是上一篇中的数字视频。两种情况下的存储原理是相同的。无论矩阵是存储来自数字视频帧的每个像素的颜色信息，还是表示颜色的数字，它们都存储在二维矩阵中，并且通过 <code>jit.window</code> 或 <code>jit.pwindow</code> 显示。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译03 - 播放 QuickTime 视频</title>
    <link href="http://uegeek.com/180825-jitter-03.html"/>
    <id>http://uegeek.com/180825-jitter-03.html</id>
    <published>2018-08-24T16:05:34.000Z</published>
    <updated>2018-08-29T13:22:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-3.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter01" target="_blank" rel="noopener">Tutorial 1: Playing a QuickTime Movie</a></p></blockquote><p>这个教程教你使用 Jitter 执行最简单但最有用的任务之一：在窗口中播放 QuickTime 视频。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01a.png" alt=""><br>打开 QuickTime 电影文件</p><p>这个 Patch 中有两个 Jitter 对象：<code>jit.movi​​e</code> 和 <code>jit.window</code>。<code>jit.window</code> 会自动打开电脑屏幕上的窗口。<code>jit.movi​​e</code> 则打开 QuickTime 视频并开始播放。</p><p>单击 <code>read countdown.mov</code> 的消息框，<code>jit.movi​​e</code> 就会打开 QuickTime 视频文件 countdown.mov 并开始读取。</p><p>默认情况下，<code>jit.movi​​e</code> 会在打开文件后立即播放。但是请注意，即使 <code>jit.movi​​e</code> 对象正在播放电影，窗口中却没有显示，因为：</p><p>Jitter 中的每个对象都执行特定任务——可能非常简单，也可能相当复杂。播放 QuickTime 视频实际上被分解为两个任务：</p><ol><li>从硬盘上的文件中将每帧视频数据读入 RAM</li><li>获取 RAM 中的数据，并将其显示为屏幕上的彩色像素</li></ol><p>第一个任务由 <code>jit.movi​​e</code> 执行，第二个任务由 <code>jit.window</code> 执行。为了让 <code>jit.window</code> 知道要显示什么，这两个对象需要进行通信。</p><h2 id="Jitter-对象如何通信"><a href="#Jitter-对象如何通信" class="headerlink" title="Jitter 对象如何通信"></a>Jitter 对象如何通信</h2><blockquote><p>重要概念：Jitter 对象相互通信的关键是<strong>矩阵的名称</strong> —— 它指定了数据在内存中的位置。Jitter 对象输出其他 Jitter 对象能理解的消息（<code>jit_matrix</code>，后跟空格和存储数据的矩阵名称）。此消息通过接线在对象之间传递。</p><p><strong>接收的对象从入口接收消息，从内存中的指定位置获取数据，以某种方式修改数据，并发送修改后的名称数据，输出到对象的左侧出口。</strong></p><p>这样每个对象查看内存中相应的位置来获取所需的数据，执行各自的任务，而不必知道其他对象正在做什么。大多数 Jitter 对象只有从另一个对象获取 jit_matrix 消息，得知该查看相应的矩阵，才会对那里的数据做一些事情。</p></blockquote><p>在多数情况下，Jitter 对象自己会生成唯一的名称。你也可以指定名称（最好是这样）。显式地命名矩阵，不同对象就可以使用相同的内存空间。</p><h2 id="由-Jitter-对象触发动作"><a href="#由-Jitter-对象触发动作" class="headerlink" title="由 Jitter 对象触发动作"></a>由 Jitter 对象触发动作</h2><p>是什么让一个 Jitter 对象将 <code>jit_matrix</code> 消息发送给另一个对象呢？大多数 Jitter 对象在收到消息 <code>outputmatrix</code> 或 <code>bang</code> 时，会发出 <code>jit_matrix</code> 消息。另外，一个对象收到消息并修改了数据后，它会自动发出一条 <code>jit_matrix</code> 消息，通知其他包含相同矩阵名称的对象。</p><p>也就是说，当一个对象收到 <code>jit_matrix</code> 消息时，它会做一些事情并发出自己的 <code>jit_matrix</code> 消息。当一个对象收到 <code>outputmatrix</code> 或 <code>bang</code> 时，它会发送一个 <code>jit_matrix</code> 消息，而不做任何其他事情。</p><p>因此在示例中，<code>jit.movi​​e</code> 对象正在播放 QuickTime 视频，不断存储当前的视频帧，但 <code>jit.window</code> 对象只会在从 <code>jit.movi​​e</code> 对象接收到 <code>jit_matrix</code> 消息时显示内容。只有当 <code>jit.movi​​e</code> 收到消息<code>bang</code>（或 outputmatrix）时才会发生这种情况。那时，<code>jit.window</code> 将显示当前正在电影中播放的任何视频帧。</p><p>为了使 <code>jit.window</code> 以一定速度更新并不断显示视频帧，就需要以同样的速度发送 <code>bang</code> 消息给 <code>jit.movi​​e</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01b.png" alt=""><br>视频在 jit.movi​​e 中播放，每当要显示一帧时都要发送 bang 消息</p><ul><li>单击标记了 play 的开关，<code>metro</code> 对象就会启动。这将以每秒 25 次（每 40 毫秒）的速度发出 <code>bang</code> 消息。这个速度足以显示该视频的每一帧。只要 <code>bang</code> 继续，我们就能看到窗口中显示的视频。</li></ul><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01c.png" alt=""><br>jit.window 显示矩阵的内容</p><ul><li><p>点击开关停止 <code>metro</code>。<code>jit.window</code> 对象停止更新电影窗口，现在只会看到最后显示的静止图像。电影仍在播放 - <code>jit.movi​​e</code> 仍在逐帧更新内存 - 但 <code>jit.window</code> 会忽略这些更新，因为 <code>jit.movi​​e</code> 不再发送消息。</p></li><li><p>你可以单击 <code>metro</code> 下方的按钮，来验证电影是否仍在播放。这会让 <code>jit.movi​​e</code> 将 <code>jit_matrix</code> 消息发送到 <code>jit.window</code>，当前帧会更新 Movie 窗口。连续点几次，会看到电影在鼠标点击之间有变化。</p></li></ul><p>总而言之，<code>jit.movi​​e</code> 以视频正常速率逐帧读取 QuickTime 文件的一帧。当 <code>jit.movi​​e</code> 收到 <code>bang</code> 消息时，会将该数据的位置传达给 <code>jit.window</code>，然后 <code>jit.movi​​e</code> 收到 <code>bang</code> 时所包含的任何帧都由 <code>jit.window</code> 显示出来。</p><h2 id="对象中的参数"><a href="#对象中的参数" class="headerlink" title="对象中的参数"></a>对象中的参数</h2><p>本教程中的 <code>jit.movi​​e</code> 的两个参数 320 和 240，指定了对象在内存中保留单帧视频时的宽度和高度。它会声明足够的 RAM 来存储这些帧。因此，使用 read 消息输入希望读入的视频的尺寸是 ok 的。这样我们知道 QuickTime 视频的尺寸是 320x240。</p><p>如果输入的维度小于读入的视频的尺寸，<code>jit.movi​​e</code> 没法声明足够的存储空间，就不得不忽略每帧的一些像素。相反，如果输入的维度大于读入的视频尺寸，则每一帧中都没有足够的像素来填充已分配的内存空间，因此 <code>jit.movi​​e</code> 会平均分发数据，并用重复数据填充空余的内存。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01b.png" alt="">    </p><p><code>jit.window</code> 对象有五个输入的参数：<code>Movie 5 41 325 281</code>。第一个参数是 <code>jit.window</code> 显示的矩阵的名称。它也会出现在视频窗口的标题栏中。它可以是任何单词（用引号括起来的话，可以是多个单词）。接下来的两个参数，表示视频窗口显示区域左上角的 x，y 屏幕坐标，后两个参数是显示区域右下角的坐标（左-上-右-下）。选择了这些数字是因为</p><ul><li>它们定义了一个 320x240 的显示区域，与视频尺寸相同</li><li>当考虑操作系统默认的窗口边框、标题栏和菜单栏的尺寸时，窗口刚好隐藏在桌面的左上角。（当然也可以设置标题栏不显示）</li></ul><p>输入 <code>metro</code> 的参数 40，使其每秒发出 25 次 <code>bang</code>消息。QuickTime 视频的帧速率是每秒24帧，因此这个 <code>metro</code> 持续触发 <code>jit.movi​​e</code> 对象，确保每帧都能显示。</p><p>要播放 QuickTime 视频，请使用 <code>jit.movi​​e</code> 打开文件并将视频的连续帧读入 RAM，然后使用 <code>jit.window</code> 在单独的窗口中显示视频。使用输入的参数指定视频的尺寸，以及屏幕上显示区域的精确坐标。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Jitter 对象通过相互发送矩阵的名称，来传递特定视频帧的信息——该信息在内存中的位置。 Jitter 对象获得矩阵名称时，它使用该位置的数据执行指定的任务，然后将修改后的数据名称，发送给其他 Jitter 对象。几乎所有 Jitter 对象在收到<code>bang</code>消息 （或 outputmatrix）时都会发出一个名称（包含在<code>jit_matrix</code>消息中）。因此，为了显示视频的连续帧，以某个速率向 <code>jit.movie</code> 发送 <code>bang</code> 消息，然后​​连接到<code>jit.window</code>显示。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01d.png" alt=""><br>跟踪每个对象的消息和角色</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译02 - Jitter 对象的属性(attributes)</title>
    <link href="http://uegeek.com/180822-jitter-02.html"/>
    <id>http://uegeek.com/180822-jitter-02.html</id>
    <published>2018-08-22T09:20:13.000Z</published>
    <updated>2018-08-29T13:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title2.jpg" alt=""></p><a id="more"></a><p><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></p><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter00b_whatareattributes" target="_blank" rel="noopener">Attributes: Editing Jitter object parameters</a></p></blockquote><p>属性是指定 Max 对象行为的方法。大多数 Jitter 对象使用属性来指定当前状态的变量。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_a.png" alt="">            </p><p>许多 Max 对象使用多个参数来确定行为。对象名称后面的这些参数的顺序，决定了对象如何解析它们。在上面的例子中，<code>counter</code> 的第一个参数设置了计数的方向；第二个和第三个参数确定最小值和最大值。</p><p>这些值都是数字，参数个数可能会影响对象的行为，所以它们的顺序很重要。如果 <code>counter</code> 只有两个参数，它们会作为最小和最大值，而不是方向和最小值。参数的位置和数量最为关键，在 <code>counter</code> 的例子中，如果只有两个参数，就没办法创建能够指定方向和最大值的 <code>counter</code> 对象。</p><p>给定的对象参数，通常被视为初始值，可以从其他入口或发送特殊消息给对象来修改这些值。例如，分别发送整数到第 2 个和第 5 个入口，来更改 <code>counter</code> 对象的方向和最大值，它们会替代默认值。同样，你可以向左入口发送消息 <code>min</code> 后跟一个整数，来更改对象的最小值。</p><p>当 Max 对象只有两、三个参数时，天下太平。但是 Jitter 对象通常有很多很多变量（甚至几十个）。如果所有变量都依赖于入口和对象参数的顺序，那么光看文档就够你忙的……</p><h2 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h2><p>与 Max 对象不同，Jitter 对象可以用<strong>属性</strong>来设定行为。将属性与 Jitter 对象的名称一起输入对象框，或者在创建对象后用消息设置（和检索）属性：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_b.png" alt=""><br>具有对象名称后的属性的Jitter对象</p><p>上面是 <code>jit.brcosa</code> 的例子，它有三个属性。使用 <code>@ 符号 + 属性名称 + 一个或多个参数</code>（可以是任意数​​据类型：int，float，symbol 或 list），在对象框中设置属性。</p><p>可以在对象的名称之后，以任意顺序输入个数不限的属性。你可能不知道 <code>jit.brcosa</code> 对象的功能，但可以根据属性的名称以及数据类型来推断。</p><blockquote><p>提示：@符号与属性名称之间没有空格</p><p>同样重要的是：Jitter 对象可以同时具有输入的属性和输入的参数。请参阅下面的 Jitter 对象参数 部分。</p></blockquote><p>与 Max 对象一样，创建 Jitter 对象并设置初始值以后，可以向对象发送消息随时更改这些属性值：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_c.png" alt=""><br>使用 Max 消息更改属性</p><p><code>jit.brcosa</code> 对象的亮度属性初始值为 0.5（在对象框中输入 <code>@brightness 0.5</code>），然后可以发送消息 <code>brightness [float]</code>到对象的左入口来更改。发送带有属性名称的消息（后跟相关参数）到 Jitter 对象的左入口，就可以更改几乎任何属性。</p><p>与 Max 对象一样，Jitter 对象有参数的默认值。上面的 <code>jit.brcosa</code> 对象只设置了亮度的初始值，其他属性都使用默认值。在上面的示例中，使用消息更改对象的对比度(contrast)和饱和度(saturation)属性的值，从而替换对象的默认值。</p><p>下面说明如何设置对象的属性值。</p><h2 id="Jitter-对象参数"><a href="#Jitter-对象参数" class="headerlink" title="Jitter 对象参数"></a>Jitter 对象参数</h2><p>大多数 Jitter 对象有四种<code>输入属性</code>或<code>输入参数</code>。实际上它们都是属性，只不过 Jitter 对象会自动判断应该用作属性还是参数。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_d.png" alt=""><br>Jitter 对象也可以有参数</p><p>上面 <code>jit.rota</code> 对象有两个初始化的属性：<code>anchor_x</code> 和 <code>anchor_y</code>。但其他数字是什么意思呢？</p><p>如果 Jitter 对象处理的是矩阵数据，则参数将被理解为：</p><ol><li>输出矩阵的 planecount</li><li>输出矩阵的类型</li><li>输出矩阵的大小或维度</li></ol><p>现在我们知道，上面的 <code>jit.rota</code> 对象将输出一个由 4 个 char（8位整数）数据平面组成的矩阵，每个平面的维度是 320x240。</p><blockquote><p>注意：如果要指定 Jitter 对象的参数，参数必须出现在任意属性之前。否则 Jitter 对象会将参数误解为属性的值，而不是对象的参数。</p></blockquote><p>所有可以输出矩阵数据的 Jitter 对象，都有几个共同的属性，它们可以设置参数：<strong>planecount，type 和 dim</strong>。可以通过输入属性（不需要指定顺序），也可以用消息触发更改。例如，下面的三个对象是等价的：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_e.png" alt=""><br>参数或属性？你来定</p><ul><li>第一个对象的输出矩阵，直接使用<code>输入的参数</code>来设置。</li><li>第二个对象使用<code>输入的参数</code>设置了 <code>planecount</code> 和 <code>type</code>，但使用了<code>输入的属性</code>设置了 <code>dim</code> 的数量。</li><li>第三个对象使用<code>输入的属性</code>来设置所有内容。</li></ul><p>你也可以用 <code>loadbang</code> 对象触发的消息来初始化对象属性：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_f.png" alt=""><br>另一种初始化属性的方法</p><h2 id="查询属性和对象状态"><a href="#查询属性和对象状态" class="headerlink" title="查询属性和对象状态"></a>查询属性和对象状态</h2><p>查找对象属性设置的最快方法，是查看检查器（inspector）。选中对象，按 <code>cmd/alt + i</code> 或单击右侧工具栏上的 i 图标就可以打开。在窗口底部附近可以找到当前属性设置。</p><p>属性的另一个功能是显示 Jitter 对象属性的当前值。用一个 <code>get</code> 开头的消息，紧跟想要查询的属性名（与get之间没有空格）来触发。比如下图的 <code>getdim</code> 可以触发动作，获取 <code>jit.grab</code> 对象的 dim 当前参数。结果值由 Jitter 对象以消息形式从右输出口输出（以属性的名称 dim 开头）。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_g.png" alt=""><br>查询 Jitter 对象的属性</p><p>使用 <code>get</code> 可以查询出属性的当前值，即使之前从未设置过。例如，下面的 patch 获取了 <code>jit.plur</code> 对象的一些默认值。用 <code>route</code> 对象可以轻松分离每个属性的值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_h.png" alt=""><br>获取属性的默认值</p><p><strong>你可以发送给任何 Jitter 对象<code>getattributes</code> 和 <code>getstate</code> 消息，来获得对象的所有属性。</strong></p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_i.png" alt="">        </p><p><code>getAttributes</code> 消息令 Jitter 对象输出它包含的所有属性列表。查看几个 Jitter 对象，很快就会发现几个频繁出现的属性（例如outputmode，type 和 dim）。其他（例如 jit.brass 对象中的 mask）则是某些对象独有的。</p><p><code>getstate</code> 消息可以一次性输出 Jitter 对象所有属性的值：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_j.png" alt=""><br>查询对象的状态</p><p>这样我们就可以用 <code>route</code>，<code>unpack</code>和其他对象来按需查找属性值了。在后续的教程中会遇到几个 Jitter 对象，其属性基于输入矩阵（或被对象打开的文件）执行的计算而更改。想要找出对象计算结果，就需要查询相关属性值。</p><h2 id="ATTR"><a href="#ATTR" class="headerlink" title="ATTR"></a>ATTR</h2><p>你还可以使用 <code>attrui</code> 对象读取属性值。这是一个 UI 控件，它与对象的入口是双向连接的。<code>attrui</code> 对象有两个部分，左边部分是所有可用的属性的下拉菜单。选择属性后，右侧会显示属性的当前值，并可编辑。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_k.png" alt=""><br>查找对象的状态</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Jitter 对象的属性，让我们可以很好地管理复杂的对象参数。你可以使用属性来初始化、更改和查找存储在 Jitter 对象中的当前值。直接在属性名称后赋值，就免去了记忆参数功能和顺序的麻烦。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p><hr><p>MakeNoise 系列</p><ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li><li><a href="https://www.uegeek.com/180703-make-noise-08.html" target="_blank" rel="noopener">MakeNoise08 - 振荡器和滤波器</a></li><li><a href="https://www.uegeek.com/180706-make-noise-09.html" target="_blank" rel="noopener">MakeNoise09 - 压缩 Compression</a></li><li><a href="https://www.uegeek.com/180708-make-noise-10.html" target="_blank" rel="noopener">MakeNoise10 - 延时和混响 Delay &amp; Reverb</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译01 - 什么是矩阵？</title>
    <link href="http://uegeek.com/180821-jitter-01.html"/>
    <id>http://uegeek.com/180821-jitter-01.html</id>
    <published>2018-08-21T15:57:01.000Z</published>
    <updated>2018-08-29T13:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title1.jpg" alt=""></p><a id="more"></a><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档： <a href="https://docs.cycling74.com/max7/tutorials/jitterchapter00a_whatisamatrix" target="_blank" rel="noopener">What is a Matrix?</a></p></blockquote><p>矩阵即网格，网格的每个格子都包含一些信息。例如，棋盘是一个矩阵，每个方格包含特定的信息：有某个棋子，或没有棋子。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_a.png" alt=""></p><p>方便起见，假设矩阵中每个格子的「信息」都是数字。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_b.png" alt=""><br>电子表格是二维矩阵</p><p>水平的数据组称为<code>行</code>，垂直的数据组称为<code>列</code>。在路线图、棋盘或电子表格中，通常会使用字母和数字标记行和列，这样就可以表示任意一个单元格的位置。在上面例子中，单元格 C3 的数值为 0.319。</p><p>上面的矩阵例子是二维的——宽度和高度。在 Jitter 中，矩阵维度范围在 1~32 维之间。（一维矩阵对应编程中的数组 array。Max 中有一些对象用于存储数组，例如 <code>table</code> 和 <code>multislider</code>。不过有时候 Jitter 中的一维矩阵更适用）虽然在纸上描绘起来有点困难，但我们仍然可以想象一个有宽度/高度/深度的立方体三维矩阵。（例如，矩阵宽/高/深 分别有 3 个单元，总共 3x3x3 = 27个单元）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_c.png" alt=""></p><p>一个 3x3x3 维矩阵共有 27 个单元</p><p>四维或更高维度的矩阵，相当挑战我们的视觉想象力和描述能力，但它们确实存在。</p><h3 id="视频屏幕作为矩阵"><a href="#视频屏幕作为矩阵" class="headerlink" title="视频屏幕作为矩阵"></a>视频屏幕作为矩阵</h3><p>视频屏幕由微小的单个像素组成，每个像素都显示特定的颜色。在计算机显示器上，屏幕的分辨率通常是 1024 像素宽，768 像素高，也可能是800x600 或 640x480。在电视监视器中，分辨率大约为 640×480。上述屏幕的宽高比为 4:3。</p><p>在较宽的 DV 格式中，宽高比为3:2，图像通常为 720x480 像素。高清晰度电视（HDTV）指定了另一种宽高比 16:9。在教程中通常使用 4:3 的宽高比，最常见的尺寸小于 320x240 甚至 160x120，这样可以节省 Max patch 的大小。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_d.png" alt=""></p><p>常见的像素尺寸</p><p>单帧标准视频由 640×480 = 307,200 个像素组成。每个像素显示一种颜色。为了用数字表示眼睛可分辨的像素的颜色，我们需要范围非常大的颜色值。</p><p>用数字表示颜色值有许多方式。描述计算机中每个像素颜色的标准方法，是将颜色分解为红色、绿色和蓝色（也称为RGB），以及透明度（称为Alpha通道）。因此，大多数计算机程序将单个像素的颜色，存储为四个单独的数字，分别表示 α，红色，绿色和蓝色。这种四通道颜色表示方案通常称为 ARGB 或 RGBA。</p><p>Jitter 也遵循这个惯例。为了使矩阵的每个单元表示一个颜色像素，每个单元都包含四个数值（α/红/绿/蓝）。因此存储视频帧数据的矩阵，实际上在每个单元格中包含四个数值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_e.png" alt=""><br>矩阵的每个单元格包含多个数字</p><p>因此，视频帧在 Jitter 中是二维矩阵，每个单元表示帧的像素，并且每个单元包含 α/红/绿/蓝 四个值，范围从 0 到 255。为了区分多单元格与矩阵维度的概念，Jitter 引入了平面(plane)的概念。</p><h3 id="什么是-plane？"><a href="#什么是-plane？" class="headerlink" title="什么是 plane？"></a>什么是 plane？</h3><p>为矩阵中的数字分配内存时，Jitter 需要知道每个维度的范围 - 例如，320x240 - 以及每个单元格中要保存的值的数量。为了跟踪单元格中的不同值，Jitter 把<strong>单元格看做位于某个单独平面上，因此我们将视频帧视为四个数据平面的二维矩阵</strong>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_f.png" alt=""></p><p>矩阵每个单元中的值存在于四个虚拟平面上</p><p>使用这个概念框架，我们可以在需要时单独处理每个平面（以及颜色信息的每个通道）。例如，想要增加图像的红色，只需增加矩阵红色平面中的所有值，保持其他值不变。</p><p>一般在 Jitter 中用四个矩阵的数据-α/红/绿/蓝的 表示视频。这些平面的编号从 0 到 3，因此 Alpha 通道位于平面 0 中，RGB 通道位于平面 1,2 和 3 中。</p><h3 id="矩阵中的数据"><a href="#矩阵中的数据" class="headerlink" title="矩阵中的数据"></a>矩阵中的数据</h3><p>计算机用不同格式来存储数字。如果知道想要存储的数字类型，就可以仅为每个数字分配真正需要的空间来节省内存。例如，用 ASCII 0~255 存储字母字符，只需要 8 位（2 的 8 次方）的空间来存储每个字符。如果想要存储更大范围的数字，可能会使用 32 位（包含的整数范围从 -2,147,483,648 到 2,147,483,647）。为了表示带小数部分的数字，例如 3.1416，我们使用浮点数二进制系统，32 位或 64 位数字的某些位表示值的尾数，其他位表示指数。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/main-qimg-0c6f60196dbaaaa7a2f9178fff29d64d-c.jpg" alt=""></p><p>用 Max 编程的大多数情况下，不需要知道 Max 如何存储数字。但是用 MSP 处理数字音频时，最好了解 MSP 什么情况下使用浮点数（如果不小心用整数替代了浮点数，程序可能会报错）。在 Jitter 中，了解计算机的存储类型非常有帮助。</p><p>Jitter 矩阵可以将数字存储为 64 位浮点（也称为双精度浮点或双精度），32 位浮点（简称浮点数），32 位整数（称为long int，或者只是int）和 8 位字符（称为char）。某些 Jitter 对象仅以一种格式存储，因此不必指定存储类型。但是其他 Jitter 对象允许多种方式存储，因此必须指定数据类型为 char / long / float32 / float64 等。</p><blockquote><p>重要概念：在使用 Jitter 操作视频时，需要了解矩阵中数据存储的知识。矩阵默认以 ARGB 格式保存视频数据，每个单元的数值范围是 0~255 （一般在四个平面中）。最常见的数据存储类型是 char，并不是因为存储的是字符。最常存储的值通常是数字，只需要 256 个不同的可能值来表示，因此 8 位的 char 就足够了。视频数据量一般较大，所以 Jitter 中大多数矩阵对象默认使用 char 存储类型，以减少存储空间。对于单色（灰度）图像或视频，单个 char 数据平面就足够了。</p></blockquote><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p><hr><p>MakeNoise 系列</p><ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li><li><a href="https://www.uegeek.com/180703-make-noise-08.html" target="_blank" rel="noopener">MakeNoise08 - 振荡器和滤波器</a></li><li><a href="https://www.uegeek.com/180706-make-noise-09.html" target="_blank" rel="noopener">MakeNoise09 - 压缩 Compression</a></li><li><a href="https://www.uegeek.com/180708-make-noise-10.html" target="_blank" rel="noopener">MakeNoise10 - 延时和混响 Delay &amp; Reverb</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>破解 AI 时代的焦虑 —— 从人机交互到人机协同创作</title>
    <link href="http://uegeek.com/180717-human-computer-symbiosis.html"/>
    <id>http://uegeek.com/180717-human-computer-symbiosis.html</id>
    <published>2018-07-17T15:11:58.000Z</published>
    <updated>2018-08-22T09:40:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.001.jpeg" alt=""></p><a id="more"></a> <p>这是 4 月做的一次分享。大概是我做过的分享中，现场讨论气氛最热烈的一次了。</p><p>最近抽空整理成文章，希望大家可以继续讨论这个有趣、有争议的话题。</p><p>为什么分享这个话题呢？</p><p>我做了好多年交互设计的工作，所以学习和工作一直有一个离不开的主题——人机交互（Human-Computer Interaction）。</p><h2 id="人机关系的演进"><a href="#人机关系的演进" class="headerlink" title="人机关系的演进"></a>人机关系的演进</h2><p>什么是人机交互？我把它简单理解为：</p><blockquote><p>人如何与机器或是某个复杂系统的沟通和互动过程。</p></blockquote><p>更为完整的版本，请看我在知乎上的回答 <a href="https://www.zhihu.com/question/19788122/answer/119319267" target="_blank" rel="noopener">什么是交互设计？</a></p><p>比如，鼠标就是一个解决人和机器互动问题的经典产品。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.003.jpeg" alt=""></p><p>现在大家都觉得鼠标再平常不过了，但是在当年，Douglas Engelbart 的这一项发明，极好地解决了人们在图形化计算机界面操纵屏幕元素的问题。为了表彰这项发明以及在人机交互领域的开拓式贡献，Douglas Engelbart 在 1997 年获得了「计算机界的诺贝尔奖」——图灵奖。</p><blockquote><p>For an inspiring vision of the future of interactive computing and the invention of key technologies to help realize this vision. – Turing Award Citation</p></blockquote><p>人和机器的对话、交互一直在演进。这也从一个侧面反映了人创造工具的历史：</p><p><img src="http://killerinfographics.com/wp-content/uploads/2014/12/DickiesIGjess.edits12-211.jpg" alt=""></p><p>人创造的工具越来越多样、复杂、强大。想想看，今天我们在手机上能完成多少事情。</p><p>于是，有人慢慢感到这种发展速度似乎不大对劲……奇点要来了，AlphaGo 也出现了。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/human-progress.png" alt=""></p><p>随着深度学习热潮的演进，大家发现，以前为了让机器智能化而不得不做的很多工作，比如，符号化、标准化、模块化、输入大量专家知识、需要庞大的训练数据集、要做苦脏累的特征工程等等，现在都简化了。基本上，只要目标足够清晰、可操作，训练数据和计算资源足够，机器学习产生的结果就可以满足要求。</p><p>我个人也经历了一次切身的体验。</p><p>今年年初在上 Udacity 的 <a href="https://github.com/kidult00/deep_learning_nanodegree_projects" target="_blank" rel="noopener">Deep Learning Nano Degree 课程</a>的时候，最后一个实践项目，是基于人脸图像库，用生成对抗网络（GAN）算法自动生成人脸。</p><p>虽然在学习过程中，早已对算法能实现的结果有所预期。但是当我把程序放到 AWS 的 GPU 上面跑了不到二十分钟，看到结果时还是忍不住隐隐感到机器的强大和压迫。</p><p>这是最开始几个训练迭代生成的模糊不清的轮廓：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/face-gen-before.png" alt=""></p><p>这是十几分钟训练结束后生成的人脸：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/face-gen-after.png" alt=""></p><p>说一点儿都不焦虑是假的。</p><p>何况各种媒体还铺天盖地强化这种焦虑，今天是一百零八种会被机器取代的工作，明天是哪个比赛机器又战胜了人……</p><p>于是大家经不住会问：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.010.jpeg" alt=""></p><p>似乎只有像诗词、小说、爵士乐、即兴表演这些领域，机器看起来就是不太擅长。</p><p>但，也不好说。</p><p>Paul 是一个专门给人画肖像画的机器。从 2011 年至今已经创做了非常多的作品。看起来非常有艺术感，不是吗？</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.011.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/emoji-desperate.png" alt=""></p><p>有时候在焦虑之余，又忍不住会想：这种焦虑到底从何而来？</p><p>如果看过莱考夫「我们赖以生存的隐喻」的同学都知道，隐喻 Metaphor 对我们的影响有多么大。仔细想想，感到机器的威胁，是不是也源于人机关系的一些基本隐喻？</p><p>我们基本上都是以一种对立或一分为二的方式来看待这些基本词汇：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.014.jpeg" alt=""></p><p>看到这些词汇，我们会下意识地觉得它们是对立关系。逻辑、精确、冰冷的工程思维，怎么跟想象、感性、个性、创作融为一炉呢？</p><p>这大概就是问题所在了。</p><h2 id="隐喻和可能"><a href="#隐喻和可能" class="headerlink" title="隐喻和可能"></a>隐喻和可能</h2><p>语言有边界。这是语言能高效传递信息的代价之一。</p><p>所以，打破语言或者说概念的界限，也许就是找到新出路的起点。</p><p>（PS. 在心理咨询中，咨询师很重要的一部分工作，是帮助来访者呈现问题、reframe 问题，而不是直接插手去替他解决问题。）</p><p>其实早在 50 多年前，就有人探讨过人机关系的「未来简史」。</p><p>美国心理学家和计算机科学家 Licklider 在 Man-Computer Symbiosis 这篇论文中，讨论人跟机器的关系存在什么样的可能性，提出「人机共生」的概念。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.016.jpeg" alt=""></p><p>快 60 年过去了，技术的发展让「蠢机器」第一次有可能成为人类的「好基友」，我们为什么首先感到的是焦虑而不是兴奋呢？</p><p>还记得 2016 年，在 AlphaGo 战胜李世石后，跟安猪老师在大理有过一次讨论。当时我的感慨是，为 AlphaGo 的胜利感到挺开心的，但并不是因为我是技术的脑残粉，而是因为我觉得到了这个时候，人不得不去面对这样一个问题：</p><blockquote><p>人到底擅长什么？</p></blockquote><p>也就是说，当接受生物智能无法跟上非生物智能的发展时：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.018.jpeg" alt=""></p><p>人到底有哪些可以让机器「羡慕」（当然，机器不会有这种情绪）的天赋呢？</p><p>至今我还没有答案，但我想，大概会包括：直觉、洞察力、探索和意外的创造。人欣赏「意外」的审美、运用「意外」的创造力，应该会长期秒杀机器。</p><blockquote><p>人跟机器最大的区别到底是什么？</p></blockquote><p>我一直在问自己这个问题。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.021.jpeg" alt=""></p><p>意图，可能是现阶段人跟机器最大的差别。</p><p>人因为时间、空间、认知方面的三大局限，因为生命时长极其有限、可触达的空间极其有限、工作记忆（内存）极其有限，决定了人类的一些基本 drive 和价值观。人的美妙与荒谬，可能都来自于两行二选一的核心代码：</p><blockquote><p>Be numb/sober and Duplicate</p><p>Be insane/self-distroying and Love</p></blockquote><p>所以我（naive地）认为，突破时间、空间、认知限制，渴望无限，是人类物种永恒的追求，换一个词来概括，那就是——意图。</p><p>我们在基本意图上发展出复杂的能力，会体会微妙的情感，会追求意义，会审美、表达、共情，会讲故事和构建社会关系……</p><p>而机器，无所不能，但就是没有意图！</p><p><strong>这样看来，现在难道不是人类最好的时代吗？有一个毫无私心、任劳任怨、潜力无限的助手，为什么我们担心的是被助手取代，而不是兴高采烈地放开手脚去创造呢？</strong></p><h2 id="人机关系的新阶段"><a href="#人机关系的新阶段" class="headerlink" title="人机关系的新阶段"></a>人机关系的新阶段</h2><p>无论技术如何发展，人类从来没有停止过创造。</p><p>这是用 Google DeepDream 算法生成的作品：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/DeepDream2.jpg" alt=""></p><p>DeepDream 网站的首页，已经为人机关系的新时代做了注脚：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Human-ai-collaboration.png" alt=""></p><p>艺术家们一直在尝试探索人机关系，可能是这样的：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Alex%20Kiessling.jpg" alt=""></p><p>也可能是这样的：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/di_2016_ars_11-1024x684.jpg" alt=""></p><p>上图是一位叫做 Dragan iLiC 艺术家的项目，人充当机器的笔刷，由机械臂控制着人去作画。</p><p>在分享的现场，这张图引发了热烈的讨论。有的小伙伴表示，这样做的目的到底是什么，她看不出任何意义。有的小伙伴认为这是对人机关系一种悲观的表达。有的小伙伴的态度则更为中立而开放……</p><p>我想，这恰恰就是艺术家的目的吧：激发人们的反思与讨论。并不存在对与错，只是 raise questions，这也许就是最大的善意。</p><h2 id="音乐，人机协同即将爆发的领域？"><a href="#音乐，人机协同即将爆发的领域？" class="headerlink" title="音乐，人机协同即将爆发的领域？"></a>音乐，人机协同即将爆发的领域？</h2><p>最近关注音乐和技术结合的领域比较多，越来越觉得音乐也许会迎来人机共创的繁荣时期。</p><p>音乐本身是符号化、形式化非常强的「语言」。音乐的规律经过数百年的研究和沉淀，几乎已经没有太多规律上的「未知和秘密」，更多的变化会来自文化思潮影响下的风格探索。</p><p>算法作曲早已不是什么新鲜事，基于 AI 自动生成音乐已经有很多成熟的应用。甚至是在对即兴表演要求相当高的爵士乐，也已经有人机共同即兴表演的尝试。比如 Al Biles 教授的 GenJam 项目，从 2005 年至今，已经演出过数十场。</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=z0712pdmu7n&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/z0712pdmu7n.html" target="_blank" rel="noopener">GenJam’s Journey_腾讯视频</a></p><p>而去年的 Qosmo AI DJ 项目也展示了人类 DJ 和 AI DJ 一起 Jam 的效果~</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=t0602v8uxp2&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/t0602v8uxp2.html" target="_blank" rel="noopener">AI DJ Project 人工智能 DJ 与人类合作打碟_腾讯视频</a></p><h2 id="何以解忧？"><a href="#何以解忧？" class="headerlink" title="何以解忧？"></a>何以解忧？</h2><blockquote><p>这是最坏的时代</p><p>也是最好的时代</p></blockquote><p>这取决于我们现在每做的一个决定、每投入的分分秒秒。</p><p>回到主题，如何破解 AI 时代的焦虑呢？</p><p>以下是 00 给（自己）的解药：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.031.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.032.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.033.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.035.jpeg" alt=""></p><p>回归创造者的使命，装备上创造所需要的心、眼、脑、手，去看去爱去体验。知识可以学习，但智慧更多是一种体验。把技术当成伙伴和切磋的对手，去行动，去试验，去创造。</p><p>最后</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.037.jpeg" alt=""></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://web.stanford.edu/dept/SUL/library/extra4/sloan/MouseSite/1968Demo.html" target="_blank" rel="noopener">Doug Engelbart 1968 Demo</a></li><li><a href="http://patricktresset.com/new/" target="_blank" rel="noopener">PATRICK TRESSET |</a></li><li><a href="http://worrydream.com/refs/Licklider%20-%20Man-Computer%20Symbiosis.pdf" target="_blank" rel="noopener">Licklider - Man-Computer Symbiosis.pdf</a></li><li><a href="http://www.draganilic.org/" target="_blank" rel="noopener">www.draganilic.org</a></li><li><a href="http://igm.rit.edu/~jabics/GenJam.html" target="_blank" rel="noopener">GenJam</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.001.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计" scheme="http://uegeek.com/categories/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="交互设计" scheme="http://uegeek.com/tags/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="AI" scheme="http://uegeek.com/tags/AI/"/>
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Deisgn" scheme="http://uegeek.com/tags/Deisgn/"/>
    
      <category term="人工智能" scheme="http://uegeek.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="HCI" scheme="http://uegeek.com/tags/HCI/"/>
    
      <category term="人机交互" scheme="http://uegeek.com/tags/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
      <category term="人机共生" scheme="http://uegeek.com/tags/%E4%BA%BA%E6%9C%BA%E5%85%B1%E7%94%9F/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="跨界" scheme="http://uegeek.com/tags/%E8%B7%A8%E7%95%8C/"/>
    
      <category term="创新" scheme="http://uegeek.com/tags/%E5%88%9B%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise10 - 延时和混响 Delay &amp; Reverb</title>
    <link href="http://uegeek.com/180708-make-noise-10.html"/>
    <id>http://uegeek.com/180708-make-noise-10.html</id>
    <published>2018-07-08T04:50:44.000Z</published>
    <updated>2018-08-22T09:40:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li><li><a href="https://www.uegeek.com/180703-make-noise-08.html" target="_blank" rel="noopener">MakeNoise08 - 振荡器和滤波器</a></li><li><a href="https://www.uegeek.com/180706-make-noise-09.html" target="_blank" rel="noopener">MakeNoise09 - 压缩 Compression</a></li></ul><p>音乐是时间的艺术。</p><p><strong>时间也是信号的天然属性。而声音设计，同时还是空间的艺术。</strong></p><p>声音必定产生在某个空间当中，人对声音的印象和记忆，多少都包含了对空间线索的直觉和感受。比如，密友之间的低语声，比较可能发生在一个小房间里；而轮船驶过的汽笛声，大概是在一个临海、开阔的码头，夹杂着繁忙的机械马达声和喧闹的人声。如果是清晨的港湾，大概又是不同的景象了。</p><embed src="http://www.xiami.com/widget/58846_1770984629,_300_146_cccccc_dddddd_0/multiPlayer.swf" type="application/x-shockwave-flash" width="300" height="146" wmode="opaque"><p>调整声音信号的方式有很多，延迟（delay）是必不可少的一种。混响（reverb）是塑造声音的空间感的秘密。今天我们就来一探究竟吧。</p><h2 id="Delay-延时"><a href="#Delay-延时" class="headerlink" title="Delay 延时"></a>Delay 延时</h2><blockquote><p>Delay is an audio effect and an effects unit which records an input signal to an audio storage medium, and then plays it back after a period of time. — Wiki￼</p></blockquote><p>延时可以在时间上平移一个信号。延迟效果器储存并保留音频信号一段时间后再将其释放。</p><p><img src="https://wiki.audacityteam.org/w/images/5/53/Delay.png" alt=""></p><p>延时是很多音效的核心，比如混响 Reverb、滤波 Filters 、和唱 Chorusing、Flanger（镶边，利用原音叠上稍微延迟的音，产生出金属感的回旋声）。</p><p>通过控制多条延迟的声音，可以产生回声效果。以一定顺序衰减并释放每条延迟声音，可以模拟出真实的回声效果。</p><p>延迟效果有很多种形式。比如在 Pink Floyd 的 <a href="https://open.spotify.com/track/5HNCy40Ni5BZJFw1TKzRsC" target="_blank" rel="noopener">Comfortably Numb</a> 里面，第一句歌词「Hello…Hello…Hello」是一个长延迟的效果。</p><iframe width="100%" height="166" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/4126197&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true"></iframe><p><img src="https://is4-ssl.mzstatic.com/image/thumb/Music49/v4/0f/f8/be/0ff8be03-465c-c0ce-4fe1-2db52ea50753/886445635850.jpg/1200x630bb.jpg" alt=""></p><p>Delay 的参数：</p><ul><li>Time/tap: the amount of time between the dry, unprocessed signal and the wet, processed signal.</li><li>Repeat/feedback: controls how many repeats of a delayed sound</li></ul><h2 id="Reverb-混响"><a href="#Reverb-混响" class="headerlink" title="Reverb 混响"></a>Reverb 混响</h2><p>混响可以帮助我们营造合适的空间「场所感」。</p><blockquote><p>混响(reverberation)是声源发音停止后，声音继续存在的声学现象。—wiki</p></blockquote><p>声音在空间中传播，会遇到不同的物体，发生反射（reflection）、吸收（absorption）和扩散（diffusion）。混响产生于声波的传播被墙壁或周围障碍物反射而滞后于发声。<br>￼<br><img src="http://www.prestigeacoustics.com.au/wp-content/uploads/2015/01/About-Sound5-copy3.png" alt=""></p><p>不同的材料对声音的吸收效果不同，常常需要精密的计算和搭配，才能营造出理想的声音效果。</p><p><img src="https://www.acousticpanelsreview.com/wp-content/uploads/2014/09/Sound-Absorption-Coefficient.png" alt=""></p><p>混响时间是指从其最初的反射声强度衰落 60 dB (降低到 -60dB)所花费的时间。<br>￼<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Reverberation_time_diagram.svg/440px-Reverberation_time_diagram.svg.png" alt=""></p><p>延时时间的最小值，应该至少为混响时间的四分之一，而且延时的长度应为质数（或各延时时长是互质的）。合理的混响效果建议每秒有 1000 个回声。</p><p>室内环境的声学效果涉及非常复杂的声学知识，尤其是录音棚和音乐厅。</p><p><img src="http://www.constructioncanada.net/wp-content/uploads/2016/02/Fig-4.jpg" alt=""></p><p>下图是 00 所拍摄的上海交响乐团音乐厅的一角，舞台上方使用了很多木质材料，来获得最佳的混响和其他声音效果。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/SSO.jpg" alt=""></p><h3 id="在-Ableton-Live-里处理混响"><a href="#在-Ableton-Live-里处理混响" class="headerlink" title="在 Ableton Live 里处理混响"></a>在 Ableton Live 里处理混响</h3><p>下面来看看 Ableton Live 里面是如何调整音频的混响的。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5Dreverb.png" alt=""></p><p>混响的参数：</p><ul><li>Dry/Wet: 没有混响/最大混响</li><li>Input: 控制对多少原始信号做混响处理</li><li>Reflect: 混响初期（early reflection），对混响感知影响更大</li><li>Diffuse: 混响末期（late reflection）</li><li>Size: 模拟不同大小的空间的混响 (对 Reflect 的影响大于 Diffuse)</li><li>Decay time: 混响消失所需时间</li><li>Predelay: 原始信号做混响处理之前的等待时间</li></ul><p>以下视频详细讲解了 Reverb 效果器的使用：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=a0714gvoo1l&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/a0714gvoo1l.html" target="_blank" rel="noopener">Reverb in Ableton Live_腾讯视频</a></p><h2 id="Max-MSP-里的延时和混响"><a href="#Max-MSP-里的延时和混响" class="headerlink" title="Max/MSP 里的延时和混响"></a>Max/MSP 里的延时和混响</h2><p>Max/MSP 有丰富的控制延时的方法和对象。</p><p><code>delay~</code></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Ddelay~.png" alt=""></p><p><code>tapin/tapout</code></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dtapin-tapout.png" alt=""></p><p><code>teeth~</code></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dteeth~.png" alt=""></p><p>还有处理非信号的延时器：<code>pipe</code></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dpipe.png" alt=""></p><p>如果对如何从信号层面实现混响有兴趣，可以到 Max/MSP 里面拆开 BEAP 组件里面的 Reverb2，看看到底是怎么实现的。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dreverb2.png" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dreverb2-patch.png" alt=""></p><p>(小编 0 已晕…… 后会有期)</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://book.douban.com/subject/7069885/" target="_blank" rel="noopener">Audio Engineering 101 - A Beginner’s Guide to Music Production</a></li><li><a href="https://www.wikiwand.com/en/Reverberation" target="_blank" rel="noopener">Reverberation - Wikiwand</a></li><li><a href="https://www.acousticpanelsreview.com/acoustic-sound-absorption/" target="_blank" rel="noopener">Acoustic Sound Absorption - Acoustic Panels Review</a></li><li><a href="https://www.wikiwand.com/en/Delay_(audio_effect" target="_blank" rel="noopener">Delay (audio effect) - Wikiwand</a>)</li><li><a href="https://www.wikiwand.com/en/Comb_filter" target="_blank" rel="noopener">Comb filter - Wikiwand</a></li><li><a href="http://aquoibon.li/mixing_guide/" target="_blank" rel="noopener">混音指南（2016） | À quoi bon</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Delay" scheme="http://uegeek.com/tags/Delay/"/>
    
      <category term="Reverb" scheme="http://uegeek.com/tags/Reverb/"/>
    
      <category term="混响" scheme="http://uegeek.com/tags/%E6%B7%B7%E5%93%8D/"/>
    
      <category term="延迟" scheme="http://uegeek.com/tags/%E5%BB%B6%E8%BF%9F/"/>
    
      <category term="音效" scheme="http://uegeek.com/tags/%E9%9F%B3%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise09 - 压缩 Compression</title>
    <link href="http://uegeek.com/180706-make-noise-09.html"/>
    <id>http://uegeek.com/180706-make-noise-09.html</id>
    <published>2018-07-06T03:31:22.000Z</published>
    <updated>2018-08-22T09:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li><li><a href="https://www.uegeek.com/180703-make-noise-08.html" target="_blank" rel="noopener">MakeNoise08 - 振荡器和滤波器</a></li></ul><p>在音频处理中，压缩可以指数据压缩格式（如 mp3 格式），如何压缩可以减少文件大小。本文学习的则是动态范围（Dynamic range）的压缩。<br>￼<br><img src="http://artsites.ucsc.edu/ems/music/equipment/signal_processors/processors_intro/comp.gif" alt=""></p><p>EQ（均衡器） 和 Compressor（压缩器）是 Sound engineering 里面最基础最常用的效果器。压缩器是动态处理器的一种。动态处理器最简单的形式就像一个<strong>自动的音量控制器</strong>（gain control），当音量太大时减低音量，当音量太小时调高音量。</p><p>想象一下，你家的电视有两个不同的频道。一个频道总是很小声，需要用遥控器调整到 20 才听得清楚。另外一个频道却很大声，必需用遥控器调到 12 才不会吵到邻居。</p><p>Compressor 的作用，就相当于每次切换这两个频道的时候，自动帮你调整声音大小，使之保持在合适的范围。<br>￼<br><img src="http://www.yamahaproaudio.com/global/en/Images/pa_beginners_comp12_2.jpg" alt=""></p><p>在音频处理中，<strong>压缩的目的是让乐器、人声或录音的动态范围保持在我们想要的范围</strong>：</p><ul><li>控制动态性能</li><li>填补漏洞</li><li>声音包络控制/塑形</li><li>调控音色</li><li>调整峰值和失真</li><li>Sidechain compression(ducking/dipping/pumping)</li></ul><p>￼<img src="https://www.howtogeek.com/wp-content/uploads/2011/04/clipping_compared_to_limiting.png" alt=""></p><p>更直观来说，压缩处理可以：</p><ul><li>使音频的动态范围更平整（even out）</li><li>融合两种乐器的声音（如bass 和底鼓），听起来更为整体</li><li>提亮音量比较小的声音</li><li>控制太响的声音</li><li>使声音获得特定的音色效果</li><li>创造特别的声音</li></ul><p>所有的动态处理器基本上都是指定一个开始工作的信号电平，然后对信号做出某种形式动态变化。</p><p><img src="https://www.residentadvisor.net/images/features/2012/tech-compress-dynamic-range.jpg" alt=""></p><p>不同压缩方法对 dynamic range 的影响：<br>￼<br><img src="https://dt7v1i9vyp3mf.cloudfront.net/styles/header/s3/imagelibrary/P/Pcomp-02-scales-5vGDFjBDltP2gtc.qx_VD3N2xWxwZHMy.jpg" alt=""></p><p>在 <a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise 06 中我们学习了均衡器(EQ)</a>。那么在处理音频时，应该是先调 EQ 还是先调 Compressor 呢？</p><blockquote><p>Placing an EQ before a compressor can have the effect of  exaggerating the applied EQ. Placing an EQ after a compressor you can often attain more audible results with less EQ, producing results that often do not “sound EQ’s EQ” – Chuck Zwicky</p></blockquote><p>一般来说，EQ 在 Compressor 之前，主要为了调整 Compressor 的反应；EQ 在 Compressor 之后，是为了调整波形达到更好的混音效果。当然也要<a href="http://a85115230.pixnet.net/blog/post/313698829-%E5%85%88eq%EF%BC%9F%E9%82%84%E6%98%AF%E5%85%88compressor%EF%BC%9F" target="_blank" rel="noopener">取决于声音素材和想要的效果</a>。</p><h2 id="在-Ableton-Live-里压缩不同的音轨"><a href="#在-Ableton-Live-里压缩不同的音轨" class="headerlink" title="在 Ableton Live 里压缩不同的音轨"></a>在 Ableton Live 里压缩不同的音轨</h2><p>进入 Ableton Live，在效果库里面找到 Compressor，拖到音轨上，就看到 Compressor 面板中调整压缩的参数：</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5Dcompressor.jpg" alt=""></p><ul><li>Threshold/Input：控制何时触发压缩</li><li>Gain reduction (GR)：有多少 dynamic range 被去掉</li><li>Output/Makeup gain：补偿因压缩导致的音量减小，设定输出的最高电平</li><li>Attack：当信号达到阈值时，压缩器在多少时间内开始处理。Fast attcak 0.01~10 ms, slow attack &gt; 50 ms</li><li>Release：当压缩时，原始信号被保留多久。通常以音频的 tempo 为基准</li><li>Ratio：以输入为基础，按比例设定输出值</li><li>Link：连接双声道/单声道压缩器到另外一个单声道，形成立体效果</li><li>Side chain：使用信号而不是主输入来控制压缩</li><li>Bypass：压缩过滤</li></ul><p>如何调整不同乐器音轨的压缩器，请看下面视频里的详细讲解：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=d0711gj2yf2&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/d0711gj2yf2.html" target="_blank" rel="noopener">Compressor in Ableton Live_腾讯视频</a></p><h2 id="用-Max-MSP-实现-Compressor"><a href="#用-Max-MSP-实现-Compressor" class="headerlink" title="用 Max/MSP 实现 Compressor"></a>用 Max/MSP 实现 Compressor</h2><p>更进一步，我们到 MSP 里拆解 Compressor 是如何实现的。</p><p>官方文档里提供了详细的说明和例子。00 调整和补充了一些注释：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dcompression.png" alt=""></p><p>压缩器主要有三部分构成：参数、压缩流程和处理算法。下面分别看看每一部分的实现。</p><p>可控制的参数主要有 Input gain, Threshold, Ratio, Attack time, Release time，之前我们在 Ableton Live 的 Compressor 面板里都看到了：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dcompression-para.png" alt=""></p><p>压缩处理的主流程：先实时监测 input level，把信号从 amplitude 转换为 dB，然后跟阈值参数比较，判断是否进行压缩：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dcompression-compressor.png" alt=""></p><p>如果达到阈值后开始压缩，需要降低的 gain 由以下部分计算。公式是 <code>(Threshold - Level) * (1 -  1/ratio)</code>：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dcompression-math.png" alt=""></p><p>然后将计算值再换算为 amplitude，输出到 compression 的主流程中，最后再加一道 <code>rampsmooth~</code> 来平滑 gain 的变化。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://book.douban.com/subject/7069885/" target="_blank" rel="noopener">Audio Engineering 101 - A Beginner’s Guide to Music Production</a></li><li><a href="https://zhuanlan.zhihu.com/p/32562033" target="_blank" rel="noopener">什么是动态处理器？</a></li><li><a href="https://docs.cycling74.com/max7/tutorials/17_msp_compress_00" target="_blank" rel="noopener">MSP Compression Introduction: What is Compression?</a></li><li><a href="https://www.soundonsound.com/techniques/parallel-compression" target="_blank" rel="noopener">Parallel Compression |</a></li><li><a href="https://www.residentadvisor.net/features/1595" target="_blank" rel="noopener">RA: Understanding compression</a></li><li><a href="http://a85115230.pixnet.net/blog/post/313698829-%E5%85%88eq%EF%BC%9F%E9%82%84%E6%98%AF%E5%85%88compressor%EF%BC%9F" target="_blank" rel="noopener">先EQ？還是先Compressor？ @ Balanced Audio Lab 平衡音訊實驗室 :: 痞客邦 ::</a></li><li><a href="https://www.kadenze.com/courses/sound-production-in-ableton-live-for-musicians-and-artists-v/sessions/compression-and-dynamics" target="_blank" rel="noopener">Session 6: Compression and Dynamics</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="EQ" scheme="http://uegeek.com/tags/EQ/"/>
    
      <category term="Compressor" scheme="http://uegeek.com/tags/Compressor/"/>
    
      <category term="动态压缩" scheme="http://uegeek.com/tags/%E5%8A%A8%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise08 - 振荡器和滤波器</title>
    <link href="http://uegeek.com/180703-make-noise-08.html"/>
    <id>http://uegeek.com/180703-make-noise-08.html</id>
    <published>2018-07-03T10:35:56.000Z</published>
    <updated>2018-08-22T09:39:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li></ul><p>制造声音，总的来说有两种思路：加性和减性。加性的方法逐步叠加多个声源，减性的方法逐步剔除声音中不想要的部分。</p><p>所以，<strong>声音设计的过程，无外乎是发出声音，修剪、调整为想要的效果</strong>。</p><p>对应的，振荡器是最主要的发声对象，而滤波器是最主要的过滤修整对象。所以这一篇的内容比较多，也会需要回顾之前所讲的一些概念。</p><p><img src="https://is3-ssl.mzstatic.com/image/thumb/Purple5/v4/ce/b8/62/ceb862e4-b96e-912a-cca2-c4169002a0f7/pr_source.png/643x0w.jpg" alt=""></p><h2 id="振荡器和谐振器"><a href="#振荡器和谐振器" class="headerlink" title="振荡器和谐振器"></a>振荡器和谐振器</h2><p>在所有能够产生声音的东西（包括所有乐器）中，绝大部分都是振荡器 (Oscillators)、共振器 (Resonators) 或是两者的组合。</p><h3 id="OSC-振荡器"><a href="#OSC-振荡器" class="headerlink" title="OSC 振荡器"></a>OSC 振荡器</h3><p>电子振荡器是用来产生具有周期性的模拟信号（通常是正弦波或方波）的电子电路。音频振荡器产生频率约为 16 Hz~20 kHz。</p><p>振荡器（OSC）产生原始波形与音高，是所有合成器发声的源头。合成器一般由多个 OSC 或 Wavetable 的声音叠合而成一个音色。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/OSC_2.jpg" alt=""></p><p>如果没有 OSC 振动发出原始音高，其他元件也就没有存在的意义了。（还记得大明湖畔 440 Hz 的中央 A 音高吗？）</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=l0699omxbcq&tiny=0&auto=0" allowfullscreen></iframe><p><a href="http://v.qq.com/x/page/l0699omxbcq.html" target="_blank" rel="noopener">MakeNoise02-frequency_in_max</a></p><p>在 <a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a> 中介绍过基础的波形，它们都产生于基础的振荡器：<br>￼<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Waveforms.svg/700px-Waveforms.svg.png" alt=""></p><h3 id="Resonator-共振器-谐振器"><a href="#Resonator-共振器-谐振器" class="headerlink" title="Resonator 共振器/谐振器"></a>Resonator 共振器/谐振器</h3><blockquote><p>In physics, resonance is a phenomenon in which a vibrating system or external force drives another system to oscillate with greater amplitude at specific frequencies. —Wiki</p></blockquote><p>振荡器和共振器的区别在于，它们出现在能量流动链的什么位置，<strong>是作为原初的波源还是作为被振动源驱动（受力）的系统</strong>。 </p><p>如果两个点有相同的固有频率，则相互冲突的力就变为零。即，由一个点提供给对方的阻抗变为 0 ，这被称为共振/谐振 (resonance)。共振通过在特定频率上施力，来增加震动的幅度 。</p><p>这么说真的好抽象哦……还是直接到 Ableton Live 里面体验一下吧。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5DResonators.png" alt=""></p><p>拖进一段 beats，然后对比开启和关闭 Resonators 的效果：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=j0710ontjtv&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/j0710ontjtv.html" target="_blank" rel="noopener">Resonator in Ableton Live_腾讯视频</a></p><h3 id="低频振荡器-LFO"><a href="#低频振荡器-LFO" class="headerlink" title="低频振荡器 LFO"></a>低频振荡器 LFO</h3><blockquote><p>Low-frequency oscillation (LFO) is an electronic signal which is usually below 20 Hz and creates a rhythmic pulse or sweep. – Wiki</p></blockquote><p>低频振荡器发出低于 20Hz 的信号，主要用来<strong>驱动其他参数、调制合成器/延迟等形成周期性响应</strong>，以此来制造出特定的音效，而不是作为主频发声振荡器。</p><p><img src="https://impmoocmath.files.wordpress.com/2013/04/lfo.png" alt=""></p><p>LFO 的主要参数：</p><ul><li>Shape：Sine、Square、Pulse、Triangle、Sawtooth 等波形</li><li>Rate：控制振动時間的快慢，可以调为预设的 BPM</li><li>Amount/Depth：控制振动的强度</li><li>Phase/Offset：波形起始位置</li></ul><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5DAuto_filter.png" alt=""></p><p>LFO的使用范围很广泛，当需要<strong>制造往复变化的周期性效果</strong>，如音高一高一低的 Vibrato，相位一左一右的 AutoPan，音量一强一弱的 Tremolo…等等，都可以利用 LFO 来生成。在一部强大的合成器上，方便且多功能的 LFO 是不可或缺的。</p><h2 id="滤波器-Filter"><a href="#滤波器-Filter" class="headerlink" title="滤波器 Filter"></a>滤波器 Filter</h2><p>声音由振荡器/谐振器产生以后，<strong>声音塑形的第二个关键，就是调整其频率分布</strong>。Filter 起到限制信号的频率范围的作用，它其实就是<a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">最简单的 EQ</a>。</p><p><img src="https://static.kvraudio.com/i/b/sanfordsuperfilter.jpg" alt=""></p><p>按过滤的频率来区分，滤波器可分为以下几类：</p><ul><li>Low Pass Filter 低通滤波（LP）：允许低于其中心频率的信号更多的通过（过滤掉高频信号）</li><li>High Pass Filter 高通滤波（HP）：允许高于其中心频率的信号更多的通过（过滤掉低频信号）</li><li>Band Pass Filter 带通滤波（BP）：允许指定频段的频率通过，过滤掉两侧的频率</li><li>Band Reject 带阻（陷波）（BR）：在频谱中过滤掉一部分频率，保留其他频段</li></ul><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/basic%20filters.jpg" alt=""></p><p>在 Ableton Live 的 EQ Eight 中，八个调节点都可以选择采用哪种滤波形式：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5DEQ8.png" alt=""></p><p>按响应方式来区分，滤波器有两类：</p><ul><li>FIR：输出仅取决于输入的过往数值，称为有限冲激响应 Finite Impulse Respons</li><li>IIR：输出取决于过往的输入值和过往的输出值，围绕延时元件有一个反馈环路，称为循环（recursive）或无限冲激响应（Infinite Impulse Response）滤波器。可用作累加器，如果反馈很高，当前输入会被加到所有先前输入值上。</li></ul><p>Filter 的主要参数包括 Cutoff / Freq 和 Resonance / Res。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5DAuto_filter.png" alt=""></p><p>选定 Filter 波形后，需要指定过滤的频率界点(Cutoff)。比如选择低通滤波，将 Cutoff freq 指定为 800Hz，那么高于 800Hz 的频率将被滤除。通过指定 Cutoff 的落点，达到调整音色的目的。Res 的作用则主要是为了凸显 Cutoff 所在的频率位置（放大 db）。</p><h2 id="Max-MSP-里的滤波器"><a href="#Max-MSP-里的滤波器" class="headerlink" title="Max/MSP 里的滤波器"></a>Max/MSP 里的滤波器</h2><p>Max/MSP 提供了一系列滤波器任君选择。</p><p><code>Onepole~</code>: 单系数滤波器，也是最简单的 IIR(Infinite Impulse Response) 低通滤波器，常用来减少刺耳的高频信号，或者用来平滑信号。</p><p>虽然<code>onepole~</code>的基础用法是低通滤波，不过只要做一个简单的信号减法操作，就可以起到高通滤波的效果：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Donepole.png" alt=""></p><p>单系数不够？那么 <code>Biquad~</code> 双系数过滤器 了解一下~</p><p>为什么叫双系数呢？因为滤波公式为：</p><blockquote><p>y[n] = a0 <em> x[n] + a1 </em> x[n-1] + a2 <em> x[n-2] - b1 </em> y[n-1] - b2 * y[n-2]</p></blockquote><p>其中 a0, a1, a2, b1, b2 都是可调参数。</p><p>双系数不够？那么了解一下：<code>cascade~</code> 级联滤波器（多个<code>biquad~</code>）</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dcascade~.png" alt=""></p><p>级联可调性较差？那么 <code>filtergraph~</code> 了解一下：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dfiltergraph~2.png" alt=""></p><p>如果还是无法满足需求，请尽情折腾更为灵活的<code>filterdesign</code>……</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dfilterdesign.png" alt=""></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://book.douban.com/subject/27057297/" target="_blank" rel="noopener">设计声音</a></li><li><a href="https://www.wikiwand.com/en/Resonance" target="_blank" rel="noopener">Resonance - Wikiwand</a></li><li><a href="https://www.coursera.org/lecture/technology-of-music-production/lfo-low-frequency-oscillator-zBCiz" target="_blank" rel="noopener">LFO (Low Frequency Oscillator) - Synthesis | Coursera</a></li><li><a href="https://www.zuirens.com/%E6%8E%A2%E7%B4%A2%E5%90%88%E6%88%90%E5%99%A8%E7%9A%84%E5%A5%A7%E5%A6%99/" target="_blank" rel="noopener">探索合成器的奧妙 | Zuirens 燧人氏</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="EQ" scheme="http://uegeek.com/tags/EQ/"/>
    
      <category term="Oscilator" scheme="http://uegeek.com/tags/Oscilator/"/>
    
      <category term="Filter" scheme="http://uegeek.com/tags/Filter/"/>
    
      <category term="LFO" scheme="http://uegeek.com/tags/LFO/"/>
    
      <category term="过滤器" scheme="http://uegeek.com/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</title>
    <link href="http://uegeek.com/180701-make-noise-07.html"/>
    <id>http://uegeek.com/180701-make-noise-07.html</id>
    <published>2018-07-01T09:57:02.000Z</published>
    <updated>2018-08-22T09:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li></ul><p>在 <a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03</a> 中，我们区分了第一捆容易混淆的概念：振幅/响度/音量/增益。</p><p>今天来捋一捋第二捆概念们——Sample rate / Bit depth / Dynamic range / Bit rate，它们影响了声音的分辨率。</p><p>图像的分辨率是大家比较熟悉的概念。在一个固定尺寸的图像里包含多少像素，决定了图像的分辨率。</p><p><img src="http://www.andor.com/Portals/0/Intro_10_Small.jpg" alt=""></p><p>由此可以类比声音的「分辨率」。</p><p><strong>一个声音信号的质量由两个变量决定：采样速率 Sample rate 和 比特深度（位深度）Bit depth。</strong></p><p>图像分辨率由横纵坐标的像素数量所决定。对应到声音，Sample rate 设定了能够捕捉音频信号的最高频率，可以看做横坐标；Bit depth 决定了每一个 sample 的精度，可以看做纵坐标。两者在两个维度上共同决定了音频的分辨率。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/bit-depth-low.png" alt=""><br>￼<br><img src="http://7xjpra.com1.z0.glb.clouddn.com/bit-depth-high.png" alt=""></p><h2 id="采样率-Sample-rate"><a href="#采样率-Sample-rate" class="headerlink" title="采样率 Sample rate"></a>采样率 Sample rate</h2><blockquote><p>The sampling frequency or sampling rate, fs, is the average number of samples obtained in one second (samples per second) — wiki</p></blockquote><p>采样率决定了每一秒内会从音频信号中采集多少样本。</p><p>在现实世界中的音频采样，是不连续或离散的信号，每个梯级值都是一个数值，表示一个单一时间点上的幅度。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/50/Signal_Sampling.png/600px-Signal_Sampling.png" alt=""></p><p>多少采样点算是足够多，能够精确编码一个声音信号呢？这就要提到 The Nyquist Theorem （尼奎斯特定理）了：</p><blockquote><p>States that the signal’s sample rate must be at least two times greater than the highest desired frequency. </p></blockquote><p>采样率/2是一个特殊数字，被称为奈奎斯特点 Nyquist point，它是在任何声音中能够被一个给定采样率所编码的最高频率。 也就是说，每秒的采样至少是信号中的最高频率的 2 倍，就可以完美地还原声音信号。</p><p>所以，为了覆盖<a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">人类的听觉范围（20Hz~20kHz）</a>，每秒需要 40000 个采样点。</p><p>那么问题来了，既然 40 kHz 就够了，为什么现在音频 CD 的标准采样率是 44.1 kHz 呢？</p><p>一方面原因是工程的需要。</p><p>现实中，麦克风所能接收、采集到的空气振动的频率范围非常大，远远超过人耳听力。如果直接采样会出现混叠。所以要先使用一个低通滤波器，把高于阈值的信号过滤掉。超过 40 kHz 的频段，给低通滤波器留出空间，使得那一段不怎么完美的下降曲线落在 20KHz 之外，不影响音频效果。</p><p>另一方面是技术历史问题。</p><p>在数字存储媒介被发明之前，早期的数字音频录制在模拟录像带上。当时世界上的录像机主要有二大制式：欧洲的 PAL 和美国日本的 NTSC。当时的 CD 是 SONY（美日制式）与 PHILIPS（欧洲制式）合作的。适用于 PAL 制式录像机的编码器采样频率是 44.1kHz。适用于 NTSC 制式录像机的编码器采样频率是 44.056。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/cd.png" alt=""></p><p>那么 44.1 和 44.056kHz 这两个数字是怎么来的呢？</p><blockquote><p>44,100=294 x 50 x 3</p><p>44,056=245 x 59.94 x 3</p></blockquote><p>50Hz 和 59.94Hz 分别是 PAL 和 NTSC 的场频， PAL 制式下可用扫描线数是 294 线，而 NTSC 则是 245 线。至于x3，则是在一条视频扫描线的磁迹中，纪录三个数码音频数据块。44.056KHz 标准并不能很好地被 NTSC 系统兼容，有一定的误差，所以没有被市场接受。索尼提出了以  44.1KHz/16bit 的方式录制，在数字信号和模拟信号的过渡期，大获全胜。哪怕最后出现了数字CD，也没有敌得过用户的使用惯性。</p><p>更多这个话题的讨论，可以参考知乎问题：<a href="https://www.zhihu.com/question/27644914" target="_blank" rel="noopener">人耳 20kHz 封顶，为什么数字音频都要记录和解析到更高的频率上去？</a></p><p>那该用什么样的采样率呢？</p><blockquote><p>The Audio Engineering Society recommends 48 kHz sampling rate for most applications but gives recognition to 44.1 kHz for CD and other consumer uses, 32 kHz for transmission-related applications, and 96 kHz for higher bandwidth or relaxed anti-aliasing filtering. — wiki</p></blockquote><h2 id="比特深度-Bit-Depth"><a href="#比特深度-Bit-Depth" class="headerlink" title="比特深度 Bit Depth"></a>比特深度 Bit Depth</h2><blockquote><p>In digital audio using pulse-code modulation (PCM), bit depth is the number of bits of information in each sample, and it directly corresponds to the resolution of each sample.  — Wiki</p></blockquote><p>在 CD 的采样标准中，44.1 kHz 的 Sample Rate 我们有所了解了。那么 16 Bit Depth 又是什么意思呢？</p><p>在音频采样中，每个采样的 amplitude 用二进制数字编码。这个编码的分辨率就是比特深度。</p><p>把数据存储成二进制，意味着如果用 n 个二进制位来存储每个幅度值，总共可以表示的数值数量为 2 的 n 次方-1。1 bit 代表采样的值: 0 或 1。如果是 2 bit，采样值范围就是 0, 1, 2, 3。2 的 16 次方是 65536，所以 16 bit 的采样深度分辨率是 -32768~32768。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/bit%20depth.png" alt=""></p><p>Bit depth 实际上决定的是 dynamic range 的分辨率。</p><h2 id="动态范围-Dynamic-Range"><a href="#动态范围-Dynamic-Range" class="headerlink" title="动态范围 Dynamic Range"></a>动态范围 Dynamic Range</h2><blockquote><p>Dynamic range is the ratio between the largest and smallest values that a certain quantity can assume. It is measured either as a ratio or as a base-10 (decibel) or base-2 (doublings, bits or stops) logarithmic value of the difference between the smallest and largest signal values.</p></blockquote><p>声音的 dynamic range 由信号的最大值和最小值所决定。</p><p>在音频处理中，dynamic range 与最大振幅和 noise floor 的比值有关：</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/calculate-dynamic_range.png" alt=""></p><p>假设 1 bit 表示听觉的门限，16 位 bit depth 可以给出 98 dB 的 dynamic range，32 位为 192 dB，64 位为 385 dB。现在很多数字音频系统都用 64 位。</p><h2 id="比特率-Bit-Rate"><a href="#比特率-Bit-Rate" class="headerlink" title="比特率 Bit Rate"></a>比特率 Bit Rate</h2><p>还有一个容易与采样率、比特深度混淆的概念，叫比特币，哦不对，比特率。</p><blockquote><p>在数字多媒体领域，比特率是单位时间播放连续的媒体(如压缩后的音频或视频)的比特数量，常用码流或码率表示，单位是kbps（千位每秒）。——wiki</p></blockquote><p>高音质 MP3 的 Bit rate 可达 256-320 kbps ，低音质的 MP3 大概在 100 kbps 。</p><p>音频数据的比特率文件大小计算公式如下：</p><blockquote><p>Bit rate = sample rate <em> bit depth </em> channels</p><p>Size in bits = sample rate <em> bit depth </em> channels * length of time</p></blockquote><p>所以，Sample rate 和 Bit depth 会影响 Bit rate 和文件大小。</p><p>一般原始的多媒体文件都比较大，为了便于使用需要对其进行压缩，而码流就对应了压缩时的取样率。单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件也会越大。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天我们又梳理了一捆容易混淆的概念们：</p><ul><li>Sample rate：每秒采集的音频信号样本</li><li>Bit depth：每个信号样本的幅度范围分辨率</li><li>Dynamic range：信号的范围极限值区间</li><li>Bit rate：单位时间传送的媒体信号量</li></ul><p>以后，看见 DAW 里面相关的选项，就心里有数啦：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5Dexport.png" alt=""></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>在数字音频领域，常用的采样率有：</p><table><thead><tr><th>Sample Rate</th><th>Use</th></tr></thead><tbody><tr><td>8,000 Hz</td><td>电话所用采样率，对于人的说话已经足够</td></tr><tr><td>22,050 Hz</td><td>无线电广播所用采样率</td></tr><tr><td>32,000 Hz</td><td>miniDV数码视频camcorder、DAT（LP mode）所用采样率</td></tr><tr><td>44,100 Hz</td><td>音频CD,也常用于MPEG-1音频（VCD, SVCD, MP3）所用采样率</td></tr><tr><td>47,250 Hz</td><td>Nippon Columbia（Denon）开发的世界上第一个商用PCM录音机所用采样率</td></tr><tr><td>48,000 Hz</td><td>miniDV、数字电视、DVD、DAT、电影和专业音频所用的数字声音所用采样率</td></tr><tr><td>50,000 Hz</td><td>二十世纪七十年代后期出现的3M和Soundstream开发的第一款商用数字录音机所用采样率</td></tr><tr><td>50,400 Hz</td><td>三菱X-80数字录音机所用所用采样率</td></tr><tr><td>96,000或者192,000 Hz</td><td>DVD-Audio、一些LPCM DVD音轨、Blu-ray Disc（蓝光碟）音轨、和HD-DVD（高清晰度DVD）音轨所用所用采样率</td></tr><tr><td>2.8224 MHz</td><td>SACD、索尼和飞利浦联合开发的称为Direct Stream Digital的1位sigma-delta modulation过程所用采样率。</td></tr></tbody></table><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://book.douban.com/subject/7069885/" target="_blank" rel="noopener">Audio Engineering 101 - A Beginner’s Guide to Music Production</a></li><li><a href="https://book.douban.com/subject/27057297/" target="_blank" rel="noopener">设计声音</a></li><li>Max_MSP<em>Jitter for music </em> a practical guide to developing interactive music systems for education and more</li><li><a href="https://www.wikiwand.com/en/Sampling_(signal_processing" target="_blank" rel="noopener">Sampling (signal processing) - Wikiwand</a>#/Sampling_rate)</li><li><a href="https://www.wikiwand.com/en/Audio_bit_depth" target="_blank" rel="noopener">Audio bit depth - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Dynamic_range" target="_blank" rel="noopener">Dynamic range - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Bit_rate" target="_blank" rel="noopener">Bit rate - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Nyquist_rate" target="_blank" rel="noopener">Nyquist rate - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh-hans/%E9%87%87%E6%A0%B7%E7%8E%87" target="_blank" rel="noopener">采样率 - Wikiwand</a></li><li><a href="https://www.zhihu.com/question/27644914" target="_blank" rel="noopener">人耳 20kHz 封顶，为什么数字音频都要记录和解析到更高的频率上去？- 知乎</a></li><li><a href="https://www.zhihu.com/question/22027722/answer/119031221" target="_blank" rel="noopener">CD为什么采用44.1kHz采样频率? - 知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Sample rate" scheme="http://uegeek.com/tags/Sample-rate/"/>
    
      <category term="采样率" scheme="http://uegeek.com/tags/%E9%87%87%E6%A0%B7%E7%8E%87/"/>
    
      <category term="Bit rate" scheme="http://uegeek.com/tags/Bit-rate/"/>
    
      <category term="Bit depth" scheme="http://uegeek.com/tags/Bit-depth/"/>
    
      <category term="Dynamic range" scheme="http://uegeek.com/tags/Dynamic-range/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise06 - 音色和均衡器(EQ)</title>
    <link href="http://uegeek.com/180629-make-noise-06.html"/>
    <id>http://uegeek.com/180629-make-noise-06.html</id>
    <published>2018-06-29T11:15:41.000Z</published>
    <updated>2018-08-22T09:39:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li></ul><h2 id="音色-timbre-tone"><a href="#音色-timbre-tone" class="headerlink" title="音色 timbre/tone"></a>音色 timbre/tone</h2><blockquote><p>The character or quality (like attack, spectrum, spectral evolution) of a musical sound or voice as distinct from its pitch and intensity.</p></blockquote><p>音色对应一个静态的频谱，它带有基频和一系列泛音。</p><p>泛音其实就是物理学上的谐波，但次数的定义稍有不同，基波频率 2 倍的音频称为一次泛音，基波频率 3 倍的音频称为二次泛音，以此类推。谐波是指周期函数或周期性的波形中能用常数、与原函数的最小正周期相同的正弦函数和余弦函数的线性组合表达的部分。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Moodswingerscale.svg/500px-Moodswingerscale.svg.png" alt=""></p><p>音色跟<a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">频谱（spectrum）和波形（waveform）相关</a>。</p><p>明亮的声音比暗淡的声音包含更多的高频泛音。最好的度量是找到它的频谱重心或频谱质心（spectral centroid）。灰暗的音色频谱质心较低，或是在语音范围内没有确定的谐波结构。</p><p>一些对音色的「形容词」：<br>￼<br><img src="http://7xjpra.com1.z0.glb.clouddn.com/Describing%20sound.png" alt=""></p><h2 id="均衡器-EQ"><a href="#均衡器-EQ" class="headerlink" title="均衡器 EQ"></a>均衡器 EQ</h2><p>调整（Boost/cut/flat）EQ，即通过增高或降低<a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">声音在某个频率范围的频率，来影响整体的音色</a>。</p><p>现在不妨回到信号处理领域，从物理背景来理解 Equalizer。由于信号在传送路径到接收器接收的过程中，会受到多路径干扰、路径中遮蔽物阻挡造成遮蔽效应，这些码间干扰会导致接收讯号错误率上升。为了降低通讯系统传输的错误率，要作通道估测，根据结果对通道响应做补偿而降低传送错误率。</p><p>对声音处理而言，EQ 是一种可以<strong>分别调节各种频率成分电信号放大量</strong>的电子设备，通过调节不同频率的电信号，来补偿扬声器和声场的缺陷，补偿和修饰各种声源及其它特殊作用。</p><p>在各种软硬件和 DAW 里面，EQ 简直可以说是千人千面了。</p><p><img src="https://1mc51l3v9iyu3otpsg36nnvf-wpengine.netdna-ssl.com/wp-content/uploads/2017/01/fabfilter-pro-q_1.jpg" alt=""></p><p><img src="https://s3.amazonaws.com/izotopedownloads/docs/neutron2/images/equalizer/eq-softsaturation-module.png" alt=""></p><p>iTunes 里的 EQ：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/iTunes-eq-electronic.png" alt=""></p><p>调整声音的 EQ 可以：</p><ul><li>平衡混音中的各种声音</li><li>让声音分布在特定的频段</li><li>调出想要的音色</li><li>提升整体的听觉效果</li><li>补偿环境声场</li><li>减少回响</li><li>制作音效</li></ul><p>当我们调节 EQ 时，经常需要控制调节点所影响的频率范围，它可以由 Q（Slop / Bandwidth / Resonance）来控制。<br>￼<br><img src="http://7xjpra.com1.z0.glb.clouddn.com/Slope-Q.jpg" alt=""></p><h2 id="用-Max-MSP-制作-EQ"><a href="#用-Max-MSP-制作-EQ" class="headerlink" title="用 Max/MSP 制作 EQ"></a>用 Max/MSP 制作 EQ</h2><p>调整声音的均衡效果，实际上就是调整不同频段频率的高低。所以理论上可以用 Max/MSP 实现任意的 EQ 效果。</p><p>下面来看看 Max/MSP 里自带的 <code>buffir-eq</code> 的例子，实现了简单的高-中-低均衡器效果：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=u070585zk2x&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/u070585zk2x.html" target="_blank" rel="noopener">EQ in Max/MSP_腾讯视频</a></p><h2 id="在-Ableton-Live-里用-EQ-修饰声音"><a href="#在-Ableton-Live-里用-EQ-修饰声音" class="headerlink" title="在 Ableton Live 里用 EQ 修饰声音"></a>在 Ableton Live 里用 EQ 修饰声音</h2><p>Ableton Live 里面最常用的 EQ 是 EQ Three 和 EQ Eight。</p><p>Three 和 Eight 分别表示有 3 个和 8 个调节点。EQ Three 只能分成高、中、低频三个范围进行调节：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5DEQ3.png" alt=""></p><p>EQ Eight 则可以添加多达 8 个控制点，更为灵活：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5DEQ8.png" alt=""></p><p>在下面的视频中，尝试调节每一个控制点的滤波方式，并且移动到不同频率的位置，查看调节频段产生的均衡效果：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=v0706uf6mil&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/v0706uf6mil.html" target="_blank" rel="noopener">EQ Eight in Ableton Live_腾讯视频</a></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://book.douban.com/subject/7069885/" target="_blank" rel="noopener">Audio Engineering 101 - A Beginner’s Guide to Music Production</a></li><li><a href="https://www.wikiwand.com/zh-hans/%E7%AD%89%E5%8C%96%E5%99%A8" target="_blank" rel="noopener">均衡器 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh/%E8%B0%90%E6%B3%A2" target="_blank" rel="noopener">谐波 - Wikiwand</a></li><li><a href="https://www.kadenze.com/courses/sound-production-in-ableton-live-for-musicians-and-artists-v/sessions/sculpting-frequencies-equalization" target="_blank" rel="noopener">Session 4: Sculpting Frequencies: Equalization</a></li><li><a href="https://www.wikiwand.com/en/Harmonic" target="_blank" rel="noopener">Harmonic - Wikiwand</a></li><li><a href="https://www.youtube.com/watch?v=2oH4YcpyWSs" target="_blank" rel="noopener">EQ Tutorial: The Basics of How to EQ Properly - YouTube</a></li><li><a href="https://www.youtube.com/watch?v=LRQQxoG6rDY" target="_blank" rel="noopener">What Are Harmonics? I Full Spectrum Science I Exploratorium - YouTube</a></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="EQ-points-of-interest"><a href="#EQ-points-of-interest" class="headerlink" title="EQ points of interest"></a>EQ points of interest</h3><ul><li>Subs (&lt; 80 Hz), low freq</li><li>Big/fat(20~100 Hz), low freq</li><li>Muddy(100~300 Hz), low-low-mid freq: if a sound isn’t very clear, or muddy, try subtracting between 100 and 300 Hz.</li><li>Boxy/hollow(300~700 Hz), low-mid freq</li><li>In your face(1.5~4 kHz), Mid-mid-upper-mid freq: punk rock music accentuates this freq, too much here can cause ear fatigue, whereas not enough here can make a mix or sound appear dark and distant</li><li>Presence and clarity(4~10 kHz), upper-mid-high freq</li><li>Airy(&gt; 10 kHz), high freq</li></ul><p>via <a href="https://book.douban.com/subject/7069885/" target="_blank" rel="noopener">Audio Engineering 101 - A Beginner’s Guide to Music Production</a></p><h3 id="一些常用频点"><a href="#一些常用频点" class="headerlink" title="一些常用频点"></a>一些常用频点</h3><ul><li>50hz，常用的最低频段，是强劲的地鼓声的频段，也是能够让人为之起舞的频段。通过适当提升将得到令人振奋的地鼓声音。但是，一定要将人声里面所有的 50hz 左右的声音都切掉，那一定是喷麦的声音。 </li><li>70～100hz，获得浑厚有力的BASS的必要频点，也是需要将人声切除的频点。BASS和地鼓不要提升相同的频点，否则地鼓会被掩没掉的。 </li><li>200～400hz，主要用途，首先是军鼓的木质感声音频段；其次是消除人声脏的感觉的频段；第三，对于吉它，提升这个频段将会使声音变的温暖；第四，对于镲和 PERCUSSION，衰减这个频段可以增加清脆感。其中，在 250hz 这个频点，对地鼓作适当的增益，可以使地鼓听起来不那么沉重，很多清流行音乐中这样使用。 </li><li>400～800hz，获得更加清晰的BASS，并且可以使通鼓变得更加温暖。另外，通过增益或衰减这个频段内的某些频点，可以调整吉它音色的薄厚程度。</li><li>800～1khz，这个频段可以调整人声的“结实”程度，或者用于增强地鼓的敲击感，比较适用与舞曲的地鼓。 </li><li>1k～3khz，这是一个“坚硬”的频段。其中，1.5k~2.5k的提升可以增加吉它或BASS的“锋利”的感觉；在2～3k略作衰减，将会使人声变得更加平滑、流畅，否则，有些人的声音听起来唱歌象打架。反过来，在这个频段进行提升也会增加人声或者钢琴的锋利程度。总的来说，这个频段通常被成为噪声频段，太多的话，会使整个音乐乱成一团，但在某种乐器上适当的使用，会使这种乐器脱颖而出。 </li><li>3k～6khz，声音在3k的时候，还是坚硬的。至于6k，提升这个频点可以提升人声的清晰度，或者让吉它的声音更华丽。</li><li>6k～10khz，这个频段可以增加声音的“甜美”感觉。并且增加声音的空气感，呼吸感。并可增加吉它的清脆声音。PERCUSSION、军鼓和大镲都可以在这个频段里美化。并且，弦乐和某些的合成器综合音色，可以在这个频段得到声音的“刀刃”的感觉。</li><li>10k～16khz，提升这个频段会使人声更加华丽，并且能够提升大镲和PERCUSSION 的最尖的那个部分。但是，一定要首先确认这个频段内是有声音存在的，否则所增加的肯定是噪声。</li></ul><h3 id="各音源的频率范围"><a href="#各音源的频率范围" class="headerlink" title="各音源的频率范围"></a>各音源的频率范围</h3><table><thead><tr><th>乐器</th><th>音色丰满度</th><th>音色明亮度</th><th>音色力度</th><th>音色表现力</th><th>其他</th></tr></thead><tbody><tr><td>小提琴</td><td>200Hz~400Hz</td><td>6~10KHz</td><td></td><td></td><td>1~2KHz 是拨弦声频带 </td></tr><tr><td>中提琴</td><td></td><td></td><td>150Hz~300Hz</td><td>3~6KHz</td><td></td></tr><tr><td>大提琴</td><td>100Hz~250Hz</td><td>3KHz</td><td></td></tr><tr><td>贝斯提琴</td><td>50Hz~150Hz</td><td>1~2KHz</td><td></td></tr><tr><td>长笛</td><td>250Hz~1KHz</td><td>5~6KHz</td><td></td></tr><tr><td>黑管</td><td>150Hz~600Hz</td><td>3KHz</td><td></td></tr><tr><td>双簧管</td><td>300Hz~1KHz</td><td>5~6KHz</td><td></td><td></td><td>1~5KHz 提升使音色明亮华丽</td></tr><tr><td>大管</td><td>100Hz~200Hz 深沉感强</td><td>2~5KHz</td><td></td></tr><tr><td>小号</td><td>150Hz~250Hz</td><td></td><td></td><td>5~7.5KHz</td><td>是明亮清脆感频带</td></tr><tr><td>圆号</td><td></td><td></td><td></td><td></td><td>60Hz~600Hz 提升会使音色和谐自然；强吹音色光辉，1~2KHz 明显增强</td></tr><tr><td>长号</td><td>100Hz~240Hz</td><td></td><td></td><td></td><td>500Hz~2KHz 提升使音色变辉煌</td></tr><tr><td>大号</td><td>30Hz~200Hz</td><td></td><td></td><td></td><td>100Hz~500Hz 提升使音色深沉、厚实。</td></tr><tr><td>钢琴</td><td></td><td></td><td></td><td></td><td>27.5~4.86KHz 是音域频段。音色随频率增加而变的单薄；20Hz~50Hz 是共振峰频率。</td></tr><tr><td>竖琴</td><td></td><td></td><td></td><td></td><td>32.7Hz~3.136KHz 是音域频率。小力度拨弹音色柔和；大力度拨弹音色丰满。 </td></tr><tr><td>萨克斯管</td><td></td><td>600Hz~2KHz 提升此频率可使音色华彩清透</td><td></td><td></td></tr><tr><td>吉它</td><td>100Hz~300Hz</td><td></td><td></td><td>2~5KHz</td><td></td></tr><tr><td>低音吉它</td><td>60Hz~100Hz 低音丰满</td><td></td><td>60Hz~1KHz</td><td></td><td>2.5KHz 是拨弦声频</td></tr><tr><td>电吉它</td><td>240Hz</td><td>2.5KHz</td><td></td><td></td><td>3~4KHz 拨弹乐器的性格表现的更充分</td></tr><tr><td>电贝司</td><td>80Hz~240Hz</td><td></td><td>600Hz~1KHz</td><td></td><td>2.5KHz 是拨弦声频</td></tr><tr><td>手鼓</td><td></td><td></td><td></td><td></td><td>200Hz~240Hz 共鸣声频；5KHz 影响临场感</td></tr><tr><td>小军鼓</td><td>240Hz</td><td></td><td>2KHz</td><td></td><td>5KHz 是响弦音频（泛音区） </td></tr><tr><td>通通鼓</td><td>360Hz</td><td></td><td></td><td></td><td>8KHz 为硬度频率；泛音可达 10~15KHz </td></tr><tr><td>低音鼓</td><td></td><td></td><td></td><td></td><td>60Hz~100Hz 为低音力度频率；2.5KHz 是敲击声频率；8KHz 是鼓皮泛音声频。 </td></tr><tr><td>地鼓</td><td>60Hz~150Hz 是力度音频</td><td></td><td></td><td></td><td>5~6KHz 是泛音声频</td></tr><tr><td>镲</td><td></td><td></td><td></td><td></td><td>250Hz 强劲、坚韧、锐利；7.5~10KHz 音色尖利；1.2~15KHz 镲边泛音“金光四溅”。 </td></tr></tbody></table><table><thead><tr><th>人声</th><th>频段效果</th></tr></thead><tbody><tr><td>歌声（男）</td><td>150Hz~600Hz 影响歌声力度，提升此频段可以使歌声共鸣感强，增强力度。</td></tr><tr><td>歌声（女）</td><td>1.6~3.6KHz 影响音色的明亮度，提升此段频率可以使音色鲜明通透。</td></tr><tr><td>语音</td><td>800Hz 是“危险”频率，过于提升会使音色发“硬”、发“楞” </td></tr><tr><td>沙哑声</td><td>提升 64Hz~261Hz 会使音色得到改善</td></tr><tr><td>喉音重</td><td>衰减 600Hz~800Hz 会使音色得到改善 </td></tr><tr><td>鼻音重</td><td>衰减60Hz~260Hz，提升 1~2.4KHz 可以改善音色。</td></tr><tr><td>齿音重</td><td>6KHz 过高会产生严重齿音。 </td></tr><tr><td>咳音重</td><td>4KHz 过高会产生咳音严重现象</td></tr></tbody></table><p>via <a href="http://www.360doc.com/content/09/1109/13/421497_8668986.shtml" target="_blank" rel="noopener">均衡器的各个频段所增益的乐器和人声效果调节对照表</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="EQ" scheme="http://uegeek.com/tags/EQ/"/>
    
      <category term="均衡器" scheme="http://uegeek.com/tags/%E5%9D%87%E8%A1%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise05 - Envelope 包络（ADSR）</title>
    <link href="http://uegeek.com/180628-make-noise-05.html"/>
    <id>http://uegeek.com/180628-make-noise-05.html</id>
    <published>2018-06-28T11:39:41.000Z</published>
    <updated>2018-08-22T09:39:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://image.freepik.com/free-vector/set-of-vinyl-record-and-envelope-for-plate-retro-sound-carrier-mock-up-isometric-view-vector-illustration_7714-316.jpg" alt=""><br><a id="more"></a> </p><ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a><br>￼</li></ul><p>Envelope 是什么？信封吗？</p><p>🤷‍♀️</p><blockquote><p>Envelope of an oscillating signal is a smooth curve outlining its extremes.<br>Via <a href="https://www.wikiwand.com/en/Envelope_(waves" target="_blank" rel="noopener">Envelope (waves) - Wikiwand</a>)</p><p>The envelope of a sound describes the way it’s amplitude varies over time.<br>Via <a href="https://www.youtube.com/watch?v=Q-ot9AaJx-Y" target="_blank" rel="noopener">What is the envelope of a sound? (ADSR explained) - YouTube</a></p></blockquote><p>在声学中，envelope 是非常重要的概念，它描述声音振幅（能量）的变化。一波一波的声音，就像互联网上面根据网络协议传送的数据包一样，不断被发送出去，用 envelope 来形容倒是很形象。</p><h2 id="ADSR"><a href="#ADSR" class="headerlink" title="ADSR"></a>ADSR</h2><p>在声音设计中通常用四个词来描述一个声音的 envlope (包络)：ADSR - Attack, Decay, Sustain, Release。</p><p><img src="https://blog.landr.com/wp-content/uploads/2016/10/ASDR-01.jpg" alt=""><br>￼</p><h3 id="Attack-起音"><a href="#Attack-起音" class="headerlink" title="Attack 起音"></a>Attack 起音</h3><blockquote><p>The area that rises from silence to its peak volume。</p></blockquote><p>声音从零开始上升到最大能量处，也可以理解为从产生这个声音开始到最响时，需要的时间。</p><p>敲击型声音的起音段非常短，比如钢琴（见下图）。而一根被温和拉响的琴弦，来自琴弦的恢复力和施加到琴弓上的立达到受摩擦限制是的最大动态平衡，这个过程可以长达几秒。另外，物体越小，初始能量就会被吸收的越快。</p><p>不同乐器的 ADSR 曲线大致可以简化如下：<br>￼<br><img src="http://www.muzines.co.uk/images_mag/articles/EMM_apr_1985_back_to_basi_6_large.jpg" alt=""></p><h3 id="Decay-衰减"><a href="#Decay-衰减" class="headerlink" title="Decay 衰减"></a>Decay 衰减</h3><blockquote><p>The area goes from the peak to a medium level of decline。</p></blockquote><p>衰减出现在那些瞬变阶段（transient）以后有能量持续供应的系统中，系统初始的输入能量超过后续延音阶段的电平。也就是说，在起音阶段后，音源还持续产生能量一段时间。</p><p>Decay 就是音量下降到稳定时需要的时间，对于钢琴而言，整个音符都处在 Decay 阶段。</p><h3 id="Sustain-延音"><a href="#Sustain-延音" class="headerlink" title="Sustain 延音"></a>Sustain 延音</h3><blockquote><p>The portion of the envelope that is constant in the declining stage。</p></blockquote><p>这个阶段，系统的输入能量等于输出能量，达到某种类型的稳定动态平衡，所以产生声音的这部分能量也维持稳定，结果通常是有一个稳定的声音输出。</p><p>Sustain 一般对于管乐器和弦乐器适用。钢琴没有稳定的 Sustain 阶段，因为按下琴键之后就没有更多机械能了，音量持续减小，可以说 decay 和 sustain 没有明显的区分。</p><h3 id="Release-释音"><a href="#Release-释音" class="headerlink" title="Release 释音"></a>Release 释音</h3><blockquote><p>Last point in the envelope where the sound returns back to silence</p></blockquote><p>当停止为系统提供能量，被保存的能量以一个恒定的速率被释放，继续产生一段时间的声音，这就进入释音阶段。</p><p>Release 是音源停止震动后仍然发声的阶段，钢琴在不踩踏板的时候 Release 非常短，踩踏板的时候 Release 非常长。释音始终趋向于 0，这是一个声音的最后阶段。</p><h3 id="ADSR-的作用"><a href="#ADSR-的作用" class="headerlink" title="ADSR 的作用"></a>ADSR 的作用</h3><p>ADSR 也可以叫做「声音的生老停死」…………<br>￼<br><img src="https://libremusicproduction.com/sites/default/files/answers/adsrenvelope.png" alt=""></p><p>再来感受一下不同乐器的 ADSR 形状：<br>￼<br><img src="http://7xjpra.com1.z0.glb.clouddn.com/different_adsr.png" alt=""></p><ul><li>Fast Attack + Fast Release = 吉他Pick、木琴、木鱼</li><li>Fast Attack + Slow Release = 钢琴、扬琴、竖琴</li><li>Slow Attack + Slow Release = 提琴、胡琴、Pad Synth</li></ul><p>为什么 ADSR 如此重要？<strong>因为影响声音的包络可以大大的改变声音特性</strong>。</p><p>当通过合成器来创作一个新的声音时，合成器需要控制 ADSR 的形状。组合包络形状比较类似的声音，可以优化混音效果。当 ADSR 差异非常大的声音结合在一起时，可以创作出结构非常丰富的音效。<br>￼<br><img src="https://c1.staticflickr.com/5/4524/24904416418_586ab94683_c.jpg" alt=""></p><h2 id="在-Ableton-Live-中调整-ADSR"><a href="#在-Ableton-Live-中调整-ADSR" class="headerlink" title="在 Ableton Live 中调整 ADSR"></a>在 Ableton Live 中调整 ADSR</h2><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5Dwavetable.png" alt=""></p><p>在 Ableton Live 里，很多音效都提供 ADSR 的控制，比如最常见的 operator。</p><p>下面的视频中，我们尝试调整各个参数，看看声音产生了怎样的变化。</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=b0705yxvme9&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/b0705yxvme9.html" target="_blank" rel="noopener">Envelop &amp; ADSR in Ableton Live_腾讯视频</a></p><h2 id="Max-MSP-中-调整-ADSR"><a href="#Max-MSP-中-调整-ADSR" class="headerlink" title="Max/MSP 中 调整 ADSR"></a>Max/MSP 中 调整 ADSR</h2><p>Max 里面提供了专门的 ADSR 对象，于是对声音参数的调控灵活度很大。</p><p>我们先来生成周期波形，观察不同 ADSR 参数状况下声音波形的变化：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=t0705h80ktu&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/t0705h80ktu.html" target="_blank" rel="noopener">ADSR in Max/MSP_腾讯视频</a></p><p>在生成一个声音包络时，可以调整不同的参数改变声音的属性：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=f0705uxmou1&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/f0705uxmou1.html" target="_blank" rel="noopener">ADSR Noise in Max/MSP_腾讯视频</a></p><h3 id="￼Ref"><a href="#￼Ref" class="headerlink" title="￼Ref"></a>￼Ref</h3><ul><li><a href="https://book.douban.com/subject/7069885/" target="_blank" rel="noopener">Audio Engineering 101 - A Beginner’s Guide to Music Production</a></li><li><a href="https://book.douban.com/subject/27057297/" target="_blank" rel="noopener">设计声音</a></li><li><a href="https://www.wikiwand.com/en/Envelope_(waves" target="_blank" rel="noopener">Envelope (waves) - Wikiwand</a>)</li><li><a href="https://www.wikiwand.com/en/Synthesizer#/Attack_Decay_Sustain_Release_(ADSR" target="_blank" rel="noopener">Synthesizer - Wikiwand</a>_envelope)</li><li><a href="https://www.youtube.com/watch?v=Q-ot9AaJx-Y" target="_blank" rel="noopener">What is the envelope of a sound? (ADSR explained) - YouTube</a></li><li><a href="https://blog.landr.com/adsr-envelopes-infographic/" target="_blank" rel="noopener">ADSR Envelopes: How to Build The Perfect Sound [Infographic] | LANDR Blog</a></li><li><a href="http://www.muzines.co.uk/articles/back-to-basics/1882" target="_blank" rel="noopener">Back to Basics (EMM Apr 85)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://image.freepik.com/free-vector/set-of-vinyl-record-and-envelope-for-plate-retro-sound-carrier-mock-up-isometric-view-vector-illustration_7714-316.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Envelope" scheme="http://uegeek.com/tags/Envelope/"/>
    
      <category term="ADSR" scheme="http://uegeek.com/tags/ADSR/"/>
    
      <category term="包络" scheme="http://uegeek.com/tags/%E5%8C%85%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise04 - 波形和相位</title>
    <link href="http://uegeek.com/180626-make-noise-04.html"/>
    <id>http://uegeek.com/180626-make-noise-04.html</id>
    <published>2018-06-26T12:01:34.000Z</published>
    <updated>2018-08-22T09:39:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li></ul><h2 id="声音的速度和波长"><a href="#声音的速度和波长" class="headerlink" title="声音的速度和波长"></a>声音的速度和波长</h2><p>对于在同一种材质中出现的一个声音事件，波的速度通常是恒定的（主要取决于温度）。在 20°C 的空气中，声波的传播速度大概是 1130 ft/s  或 344 m/s 。</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/wavespeed_fomular.png" alt=""></p><p>通过测量具有相同位移、且运动方向一致的距离最近的两个质点的距离，就可以确定波长 wavelength。</p><p>因为声音在介质中的传播速度相对固定，所以频率低的声音，波长更长。</p><p>跟声音类似，光也是一种波动，是能量的一种形式。而波动传递的能量跟波长密切相关。下面是不同波长的波动类型（包括可见光在内）：</p><p>￼<img src="http://sci.esa.int/science-e-media/img/cb/Figure_4_spectrum_High-energy_highlight.jpg" alt=""></p><h2 id="波形"><a href="#波形" class="headerlink" title="波形"></a>波形</h2><p>波形（waveform）表示信号的形状、形式。波形可以千变万化，常见的基础波形包括正弦波，方波，三角波，锯齿波等：<br>￼<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Waveforms.svg/700px-Waveforms.svg.png" alt=""></p><p>在 Max/MSP 中，有一系列与之对应的生成周期信号的信号源对象：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Doscillators%20in%20max.png" alt=""></p><p>最常用的生成器对应的波形如下：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Ddifferent_waveform.png" alt=""><br>￼</p><p>其中 <code>cycle~</code> 生成正/余弦波，<code>phasor~</code> 和 <code>saw~</code> 生成锯齿波（两者的取值范围不同，<code>saw~</code>生成的波形更平滑一些），<code>rect~</code> 生成方波。</p><p>然后我们来听听看不同波形发出 440Hz 声音：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=p070303e85g&tiny=0&auto=0" allowfullscreen></iframe><p><a href="http://v.qq.com/x/page/p070303e85g.html" target="_blank" rel="noopener">Different Waveform in Max/MSP</a></p><h2 id="相位"><a href="#相位" class="headerlink" title="相位"></a>相位</h2><p>了解过频率、波长、波形等概念，下面来啃一个相对复杂的概念——相位 Phase。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/wave&amp;phase.png" alt=""></p><p>相位是波形中一个参考点在某个时间点所处的位置，用来描述信号的波形变化（单位： degree）。</p><blockquote><p>Phase is the degree of progression in a cycle</p></blockquote><p>参考点的位置公式如下：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/phase_fomular-s.png" alt=""></p><p>不同相位的波形会相互干涉。当两个声波 in phase（相位相同），会增强振幅；</p><p>￼<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b4/Sine_waves_same_phase.svg/440px-Sine_waves_same_phase.svg.png" alt=""></p><p>当两个声波相位不同，会形成干涉。<br>￼<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Sine_waves_different_phase.svg/440px-Sine_waves_different_phase.svg.png" alt=""></p><p>当两个声波 180° out of phase（相位相反），会完全抵消。这一原理常运用在降噪耳机、消音器上。<br>￼<br><img src="https://www.mediacollege.com/audio/images/wave-interaction.gif" alt=""></p><h2 id="在-Max-MSP-中生成和改变波形"><a href="#在-Max-MSP-中生成和改变波形" class="headerlink" title="在 Max/MSP 中生成和改变波形"></a>在 Max/MSP 中生成和改变波形</h2><p>在前面我们已经用几个信号对象生成对应的波形：</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Ddifferent_waveform.png" alt=""></p><p>周期性信号从 0 开始上升，每一步递增的量就是这个信号的斜率，它决定了这个周期会持续多长时间(控制着频率)。其中 phasor~ 相位器是非对称的，取值不会低于 0.0，而是在 0.0~1.0 之间移动。通常使用相位器作为所有周期波形的时间基准或输入（基础源）。</p><p>在实现相位干涉之前，我们先试着修改波形：给波形做乘法会缩放，做加法会在 y 轴产生位移：</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dmodify_wave.png" alt=""></p><p>然后，我们用 <code>cycle~</code> 生成两个频率为 4 的正弦波。将其中一个乘以 -1 得到相反相位的波形。然后把两个波叠加起来，会看到结果是波形完全消失：</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5D180_out_of_phase.png" alt=""></p><h2 id="在-Ableton-Live-中实验相位干涉"><a href="#在-Ableton-Live-中实验相位干涉" class="headerlink" title="在 Ableton Live 中实验相位干涉"></a>在 Ableton Live 中实验相位干涉</h2><p>在 Ableton Live 中，波形的调制随处可见。比如 Operator 里面可选多种波形去调制声音：</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5Doperator_waveform.png" alt=""></p><p>我们首先来实验两个相同的音频，同时播放时的增强效果。</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=o0703smlru3&tiny=0&auto=0" allowfullscreen></iframe><p><a href="http://v.qq.com/x/page/o0703smlru3.html" target="_blank" rel="noopener">In_phase</a></p><p>然后再来尝试将两个音频消音。</p><p>添加 Utility 音效器，在第二个音轨播放时，打开左右声道的相反相位开关。然后同时播放两个音频，会发现声音消失了，因为两个音频的相位正好相反，产生了完全抵消的效果。</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=t07031wi6nr&tiny=0&auto=0" allowfullscreen></iframe><p><a href="http://v.qq.com/x/page/t07031wi6nr.html" target="_blank" rel="noopener">Phase Interference in Ableton</a><br>￼  </p><h3 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h3><p>现在让我们回头看看在 Max/MSP 里听不同波形的这个视频：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=p070303e85g&tiny=0&auto=0" allowfullscreen></iframe><p><a href="http://v.qq.com/x/page/p070303e85g.html" target="_blank" rel="noopener">Different Waveform in Max/MSP</a></p><p>有什么新发现吗? 😁</p><h3 id="￼Ref"><a href="#￼Ref" class="headerlink" title="￼Ref"></a>￼Ref</h3><ul><li>Audio Engineering 101 - A Beginner’s Guide to Music Production</li><li><a href="https://www.wikiwand.com/en/Waveform" target="_blank" rel="noopener">Waveform - Wikiwand</a></li><li><a href="https://www.youtube.com/watch?v=jjy-eqWM38g" target="_blank" rel="noopener">Light: Crash Course Astronomy #24 - YouTube</a></li><li><a href="https://www.youtube.com/watch?v=TfYCnOvNnFU" target="_blank" rel="noopener">Traveling Waves: Crash Course Physics #17 - YouTube</a></li><li><a href="https://www.youtube.com/watch?v=jxstE6A_CYQ" target="_blank" rel="noopener">Simple Harmonic Motion: Crash Course Physics #16 - YouTube</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Phase" scheme="http://uegeek.com/tags/Phase/"/>
    
      <category term="相位" scheme="http://uegeek.com/tags/%E7%9B%B8%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise03 - 振幅/响度/音量/增益 大乱斗</title>
    <link href="http://uegeek.com/180624-make-noise-03.html"/>
    <id>http://uegeek.com/180624-make-noise-03.html</id>
    <published>2018-06-24T10:02:47.000Z</published>
    <updated>2018-08-22T09:39:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li></ul><p>振幅/响度/音量/增益，这大概是 Sound engineering 入门的第一捆容易混淆的概念们。<em>(¦3」∠)</em></p><h2 id="振幅-Amplitude"><a href="#振幅-Amplitude" class="headerlink" title="振幅 Amplitude"></a>振幅 Amplitude</h2><p>振幅 Amplitude 是在波动或振动中，距离平衡位置或静止位置的最大位移。<br>￼<br><img src="http://mathworld.wolfram.com/images/eps-gif/Amplitude_1000.gif" alt=""></p><p>最大正位移与最大负位移之差，称为值域（range）或峰-峰幅度，是常规振幅的两倍。</p><p><strong>音源的振幅（物理量）</strong>与频率、频谱包络以及时域包络等其他因素一起，<strong>影响声音的响度（感知量）</strong>。顺便复习一下，频率是声源每分钟震动次数的物理量，音高是感知量。</p><h2 id="响度-Loudness"><a href="#响度-Loudness" class="headerlink" title="响度 Loudness"></a>响度 Loudness</h2><p>我们常用 Sound pressure level (SPL) 值来测量声音的响度，单位为 dB。</p><p>不过 dB 并不是可以测量的物理量，它只是一个单位。来看看以下几个概念，有助于我们理解响度到底是什么：</p><ul><li>声压/声强（acoustic pressure）：是指声波通过媒质时，由振动所产生的<strong>压强改变量</strong>。声压的数值很大，不便于计算和描述，于是人们取了一个人耳刚刚能听到 1kHz 声音时候的声压值作为标准。</li><li>声压等级（SPL）：是<strong>描述声音大小的物理量</strong>，用声压值除以上面提到的标准声压值，取了对数再乘以10，就得到 SPL，公式见下图。</li><li>分贝（decibels/dB）：是<strong>描述物理量比值的单位</strong>（分贝不仅用于声学，多用于衡量各种信号的强度、增益等）。</li></ul><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/SPL2dB.png" alt=""></p><p>从以上公式容易看到，<strong>响度和声压并不是线性关系</strong>。一个声波大概需要 10 倍的压强，才能让我们在听觉上感受到 2 倍的响度。</p><p>Fletcher-Munson 曲线总结了人耳对响度的敏感性。人耳对 3kHz~4kHz的声音最敏感，其他频率区域的声音往往都需要经过放大才能被听清。<br>￼<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/49/Lindos4.svg/800px-Lindos4.svg.png" alt=""></p><h2 id="常见的响度范围"><a href="#常见的响度范围" class="headerlink" title="常见的响度范围"></a>常见的响度范围</h2><p>大多数人能识别 3dB 的声音幅度变化。下图给出了常见的声音场景的响度：</p><p><img src="https://images-na.ssl-images-amazon.com/images/I/71Z0oKDowKL._SL1500_.jpg" alt=""></p><ul><li>0 dB: 几乎安静无声</li><li>40-50 dB: 室内环境音</li><li>50-60 dB: 低语声</li><li>60-75 dB: 谈话声</li><li>80-85 dB: 最佳声音响度区域，在混音时最高不应超过 85 dB</li><li>90 dB: 工厂噪声，长时间暴露在这种环境中会损伤听力</li><li>100 dB: 婴儿哭声 </li><li>110 dB: 汽车喇叭</li><li>120 dB: 会引起疼痛和听觉损伤的响度阈值</li><li>140 dB: 相当于连续猛烈敲击军鼓1分钟</li><li>150-160 dB: 飞机引擎声</li></ul><p>不同枪支发射时的 SPL：</p><p>￼<img src="https://cdn.shopify.com/s/files/1/1696/0313/files/SoundComparison-Silencer-Supressor.jpg?v=1500407959" alt=""></p><h2 id="Sound-engineering-里的音量-Volume-和-增益-Gain-的区别"><a href="#Sound-engineering-里的音量-Volume-和-增益-Gain-的区别" class="headerlink" title="Sound engineering 里的音量 Volume 和 增益 Gain 的区别"></a>Sound engineering 里的音量 Volume 和 增益 Gain 的区别</h2><p>Volume 和 Gain 是初学者常常容易混淆的两个概念（就像我现在……☁️☁️☁️），在各种教程和工具界面里会频繁出现这两个词，它们似乎都可以翻译为「音量」。但它们是两个不同的概念。</p><h3 id="Gain"><a href="#Gain" class="headerlink" title="Gain"></a>Gain</h3><p>Gain 用来表示信号的强度，是<strong>音频输入信号和输出信号差异的幅度</strong>。</p><blockquote><p>Gain is the parameter for the amount that some sort of amplifier circuit is going to increase the amplitude of an input signal. </p><p>via <a href="https://www.youtube.com/watch?v=33u60cYDZTM" target="_blank" rel="noopener">Gain vs Volume - Production Concepts</a></p></blockquote><p>可以说，gain 控制的是「进入」声音设备的信号。</p><p>在数字音频中，Gain 常用的单位是 dBFS。0 dBFS 是数字音频中的最大值，正常值都为负数。如果大于 0 呢？音频就会出现削波和失真。</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>Volume 是声音大小（响度）的值，单位是 dBSPL(dB Sound Pressure Level)，测量的是声波在环境中的压强值。可以说，volume 控制的是从声音设备「输出」的声响大小。</p><p>在混音时，volume 值保持在 80 dB 左右最佳。增大响度叫 boost，减小响度叫 cut。</p><h3 id="在软件中的使用场景"><a href="#在软件中的使用场景" class="headerlink" title="在软件中的使用场景"></a>在软件中的使用场景</h3><p>现在，我们知道可以<strong>将 Gain 理解为对信号的调整，将 Volume 理解为处理完成后声音响度的听觉感受</strong>。</p><p>这正好可以对应到 Max/MSP 和 Ableton Live 的实现中。</p><p>Max/MSP 很擅长数字信号处理，主要在信号层面做底层的调控。所以在 Max/MSP 中只有控制 gain 的对象，而没有调控 volume 的对象。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/gain&amp;meter.png" alt=""><br>￼</p><p>而 Ableton Live 善于处理音频，叠加各种音效和编排音轨。控制每一个音轨的音量是最基本的功能之一。在界面功能中，它会把信号的 level 描述为 volume：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=r0700unhufv&tiny=0&auto=0" allowfullscreen></iframe><p><a href="http://v.qq.com/x/page/r0700unhufv.html" target="_blank" rel="noopener">Volume in ableton live</a></p><p>从上面的视频中可以看到，这个音轨的 peak level 是 -14.9，不会超过 0 ，实际上它控制的还是信号的 gain。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>振幅：波动的最大位置，并不是响度的唯一影响因素</li><li>响度：用物理量声压级 SPL 来测量，一般用简化的单位 dB 来表示响度这一感知量</li><li>音量：在音频处理时表示响度的概念，更多是指音频输出时听觉感受到的声音大小</li><li>增益：在音频处理时表示信号强度的概念，更多是指音频输入与输出时信号强度的差别</li></ul><p>它们都是对声音「大小」的不同描述，现在是不是更清晰一些了？</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ul><li>Audio Engineering 101 - A Beginner’s Guide to Music Production</li><li><a href="https://www.youtube.com/watch?v=qV4lR9EWGlY" target="_blank" rel="noopener">Sound: Crash Course Physics #18 - YouTube</a></li><li><a href="https://www.wikiwand.com/en/Sound_pressure" target="_blank" rel="noopener">Sound pressure - Wikiwand</a></li><li><a href="https://www.zhihu.com/question/23047125" target="_blank" rel="noopener">响度与振幅与分贝的关系是什么？ - 知乎</a></li><li><a href="https://www.wikiwand.com/en/Fletcher%E2%80%93Munson_curves" target="_blank" rel="noopener">Fletcher–Munson curves - Wikiwand</a></li><li><a href="http://www.prsguitars.com/index.php/blog/post/tips_from_a_recording_engineerthe_critical_difference_between_gain_and_volu" target="_blank" rel="noopener">Tips from a Recording Engineer: The Critical Difference Between Gain and Volume</a></li><li><a href="https://www.youtube.com/watch?v=33u60cYDZTM" target="_blank" rel="noopener">Gain vs Volume - Production Concepts - YouTube</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Gain" scheme="http://uegeek.com/tags/Gain/"/>
    
      <category term="Volume" scheme="http://uegeek.com/tags/Volume/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise02 - 频率和音高</title>
    <link href="http://uegeek.com/180623-make-noise-02.html"/>
    <id>http://uegeek.com/180623-make-noise-02.html</id>
    <published>2018-06-23T09:47:45.000Z</published>
    <updated>2018-08-22T09:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <p><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MN02-quote.png" alt=""></p><p>频率 Frequency 是周期运动在一秒内重复的次数。比如一根琴弦在一秒内震动 440 次（cycles per second - cps），它发出的就是 440 Hz 频率的声音。</p><p>频率是绝对量，在心理声学上对应的感知量是音高 Pitch。</p><p>一个声音听起来什么样，频率是最基本的决定要素之一。声源在每秒内振动次数的越多，频率就越大，产生的音高也就越高。</p><h2 id="常见声音频率范围"><a href="#常见声音频率范围" class="headerlink" title="常见声音频率范围"></a>常见声音频率范围</h2><p>下图展示了人和一些动物的听觉范围。<strong>人的听觉范围在 20 ~ 20000 Hz</strong>。低于 20 Hz 的属于次声波 infrasounds，高于 20 kHz 的属于超声波 ultrasounds。</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/diff_sound_freq.png" alt=""></p><p>所以市面上有一些号称 α、β 脑波的音乐，纯粹是耍流氓：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/brainwave_freq.png" alt=""></p><p>再来看看乐器的发声频率：</p><p><img src="http://www.heavyweightbass.net/wp-content/uploads/2015/12/digitalcopy.jpg" alt=""></p><p>小提琴的频率是 200Hz~1.25kHz，中提琴是 125Hz~1kHz，大提琴是 60Hz~500Hz。频率越高，音高越高，所以小提琴的音高&gt;中提琴&gt;大提琴。男声的频率在 100Hz~800Hz，女声的频率在 250Hz~1kHz，所以大多数女声比男声听起来更「高」更「尖」。</p><p>可听的频率范围可以进一步划分为：</p><ul><li>低音频率: 20~200 Hz</li><li>中音频率: 200~5k Hz, 在这个范围我们的听力最佳<ul><li>Low-mids: 200~700 Hz， 常用 darker, hollow 来形容</li><li>Mid-mids: 700~2k Hz，more aggressive “live” tones</li><li>High-mids: 2k~5kHz，常用 brighter, present 来形容</li></ul></li><li>高音频率: 5k~20kHz</li></ul><h2 id="查看小提琴和大提琴的频谱"><a href="#查看小提琴和大提琴的频谱" class="headerlink" title="查看小提琴和大提琴的频谱"></a>查看小提琴和大提琴的频谱</h2><p>接下来，我们到 Ableton Live 里试听小提琴和大提琴的声音和频率有什么不同。</p><p>在内容库里面找到 String1 Violin 和 Strings2 Cello，在 C3 拖出 2 个节拍。<br>￼<br><img src="http://7xjpra.com1.z0.glb.clouddn.com/violin_vs_cello.png" alt=""></p><p>再加入内容库里面 Audio Effects 里的 EQ eight。播放音频时，可以看到小提琴的频率范围：</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/EQ_violin.png" alt=""></p><p>大提琴的频率范围，更多会在低频率的部分。</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/EQ_cello.png" alt=""></p><h2 id="用-Max-制作不同频率的声音"><a href="#用-Max-制作不同频率的声音" class="headerlink" title="用 Max 制作不同频率的声音"></a>用 Max 制作不同频率的声音</h2><p>接下来用 Max/MSP/Jitter （系列教程另外单开）来实现并聆听不同频率的正弦声波。</p><p>Max 内置了强大的声音和信号处理机制。这次我们用最简单的方式—— cycle~ 对象来生成持续的正弦波信号。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/max_cycle~.png" alt=""></p><p>设定不同的频率 200Hz、440Hz、800Hz、1200Hz，切换频率，就能听到不同频率产生的音高不同。</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/frequency_in_max.png" alt=""></p><p>声音和频谱可以查看下面的视频：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=l0699omxbcq&tiny=0&auto=0" allowfullscreen></iframe><p><a href="http://v.qq.com/x/page/l0699omxbcq.html" target="_blank" rel="noopener">MakeNoise02-frequency_in_max</a></p><h2 id="谐波频率"><a href="#谐波频率" class="headerlink" title="谐波频率"></a>谐波频率</h2><p>振动物体可以产生一个谐波频率（每个频率都与基频呈简单的整倍数关系），也可以产生非谐波频率。</p><p>谐波是一个数学或物理学概念，是指周期函数或周期性的波形中能用常数、与原函数的最小正周期相同的正弦函数和余弦函数的线性组合表达的部分。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c5/Harmonic_partials_on_strings.svg/500px-Harmonic_partials_on_strings.svg.png" alt=""></p><p>一个纯净音色并不需要各个谐波都完美的排列在完全整数值上，它需要这些谐波形成一个稳定的级数。例如，100Hz、199Hz、396.01Hz。每个泛音几乎都是一个频倍，是前一个频率的 1.99 倍。</p><p>除了正弦/余弦波以外，所有声音都由多个频率构成，形成一个频谱（在上面 Max 里面展示频率的图就是一种频谱）。</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li>Audio Engineering 101 - A Beginner’s Guide to Music Production</li><li><a href="https://www.youtube.com/watch?v=qV4lR9EWGlY" target="_blank" rel="noopener">Sound: Crash Course Physics #18 - YouTube</a></li><li><a href="http://www.heavyweightbass.net/index.php/2014/08/29/2014827eq-tips/" target="_blank" rel="noopener">Balance is key – EQ’s magic frequencies | Heavyweightbass.net</a></li><li><a href="https://www.wikiwand.com/en/Harmonic_series_(music" target="_blank" rel="noopener">Harmonic series (music) - Wikiwand</a>)</li><li><a href="https://www.wikiwand.com/zh-hans/%E8%B0%90%E6%B3%A2" target="_blank" rel="noopener">谐波 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh/%E8%85%A6%E6%B3%A2" target="_blank" rel="noopener">腦波 - Wikiwand</a></li></ul><p>￼</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Frequency" scheme="http://uegeek.com/tags/Frequency/"/>
    
  </entry>
  
</feed>
