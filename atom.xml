<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>00&#39;s Adventure</title>
  
  <subtitle>Why join the navy if you can be a pirate</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://uegeek.com/"/>
  <updated>2018-09-24T04:00:29.000Z</updated>
  <id>http://uegeek.com/</id>
  
  <author>
    <name>kidult00</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译19 - 使用已命名矩阵的反馈</title>
    <link href="http://uegeek.com/180924-jitter-19.html"/>
    <id>http://uegeek.com/180924-jitter-19.html</id>
    <published>2018-09-24T03:58:55.000Z</published>
    <updated>2018-09-24T04:00:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-1.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li><li><a href="https://www.uegeek.com/180915-jitter-17.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 17 - 图像旋转</a></li><li><a href="https://www.uegeek.com/180917-jitter-18.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 18 - 使用已命名的矩阵</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter17" target="_blank" rel="noopener">Max 7 - Tutorial 16: Using Named Jitter Matrices</a></p></blockquote><p>本教程讲解在反馈循环（feedback loop）中使用命名的 <code>jit.matrix</code> 。我们将使用随机值矩阵来构建迭代过程（Conway’s Game of Life）。</p><p>教程 patch 用 <code>jit.noise</code> 生成随机值的初始矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17a.png" alt=""><br><code>jit.noise</code> 对象</p><p><code>jit.noise</code> 生成由随机值填充的矩阵。dim，planecount 和 type 属性确定输出矩阵（需要一个 80 x 60 单平面 char 数据矩阵）。<code>jit.op</code> 将随机单元格的值（初始为 0~255）设置为 false（0）或 true（255）。<code>jit.op</code> 的 &gt; 运算符从右入口数字框中获取值并用于比较运算。如果单元格值小于该值，单元格的值将设置为 0，否则设置为 255。发送到 <code>jit.noise</code> 的 bang 将生成新的随机矩阵。</p><p>更改附加到 <code>jit.op</code> 的数字框。单击连接到 <code>jit.noise</code> 的按钮，每次都生成一个新矩阵。注意更大的比较值产生更少的白色（255）单元格。<code>jit.op</code> 下面的小 <code>jit.pwindow</code> 显示随机矩阵。单平面矩阵数据由 <code>jit.pwindow</code> 解析为灰度视频。</p><h2 id="矩阵反馈"><a href="#矩阵反馈" class="headerlink" title="矩阵反馈"></a>矩阵反馈</h2><p>patch 顶部的量化（quantized）噪声从 <code>jit.op</code> 传到名为 cellular 的 <code>jit.matrix</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17b.png" alt=""><br>在反馈循环中有两个已命名的 <code>jit.matrix</code></p><p><code>jit.matrix</code> 接收来自 patch 顶部的 <code>metro</code> 的 bang，它连接到一个名为 <code>jit.conway</code> 的对象，其输出连接到另一个同名的 <code>jit.matrix</code>。结果是 <code>jit.conway</code> 的输出（无论它做什么）被写入跟其输入相同的矩阵中，从而创建反馈循环。</p><p>点击开关启动 <code>metro</code>。 patch 底部的 <code>jit.pwindow</code> 将显示 <code>jit.conway</code> 的输出。</p><p>如果想从一个新的随机矩阵开始，单击连到 <code>jit.noise</code> 的按钮，将新矩阵复制到反馈循环中。来自 <code>jit.op</code> 的矩阵会进入反馈循环中相同的 cellular 矩阵。</p><h2 id="生命的游戏"><a href="#生命的游戏" class="headerlink" title="生命的游戏"></a>生命的游戏</h2><p><code>jit.conway</code> 对输入矩阵执行名叫 “Game of Life” 的简单元胞自动机算法。该算法由普林斯顿大学的 John Conway 发明，模拟食物供应有限环境中的有机生存周期。矩阵中的单元格被看做是活的（非 0）或死的（0）。比较每个单元与周围的单元。如果一个活细胞有两个或三个活的邻居，它就活着。如果多于或少于该数字，它将死亡（0）。如果死去的细胞恰好有三个活的邻居，它就会变为活的（255）。就这么简单。</p><p>每当 <code>jit.conway</code> 接收到输入矩阵时，会开始一轮生命游戏。因此，在反馈循环内使用对象是有意义的，可以看到在同一初始数据集上执行多代算法。</p><p>例如，初始随机矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17c.png" alt=""><br>一些随机矩阵值</p><p><code>jit.conway</code> 在前四次迭代中生成以下矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17d.png" alt=""><br>在上面的数据集上 Game of Life 的前四代</p><p>使用随机矩阵 seeding 反馈循环后，可以打开 <code>metro</code> 并观察算法运行。Game of Life 的设计方式使得矩阵最终将稳定到一组自振荡 (self-oscillating) 细胞单元或空矩阵（a dead world）。在任何一种情况下，都可以 bang 一组新的数字重新开始。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用 <code>jit.matrix</code> 的 name 属性在 Jitter 中创建反馈循环。在对象链的任一端使用两个同名 <code>jit.matrix</code>，可以创建输出将被写入与输入来源相同的矩阵的链条。<code>jit.noise</code> 产生的任意随机数 type/dim/planecount 的矩阵。<code>jit.conway</code> 对输入矩阵做简单的元胞自动处理，在反馈回路中效果最好。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译18 - 使用已命名的矩阵</title>
    <link href="http://uegeek.com/180917-jitter-18.html"/>
    <id>http://uegeek.com/180917-jitter-18.html</id>
    <published>2018-09-17T10:21:32.000Z</published>
    <updated>2018-09-17T10:24:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-9.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li><li><a href="https://www.uegeek.com/180915-jitter-17.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 17 - 图像旋转</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter16" target="_blank" rel="noopener">Tutorial 16: Using Named Jitter Matrices</a></p></blockquote><p>本教程将学习如何使用 <code>jit.matrix</code> 的 name 属性将来自多个源的矩阵数据写入同一矩阵。我们还将研究如何在复制时缩放矩阵的大小，以及如何用 Max 低优先级队列来降低事件的优先级，以支持更耗时的任务。</p><p>教程 patch 分为五个彩色区域。中间（浅蓝色）区域包含两个 <code>jit.movi​e</code> 对象。<code>loadbang</code> 对象在 patch 打开时读取两个视频（rain.mov 和 traffic.mov）到 <code>jit.movi​e</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16a.png" alt=""></p><p>与之前的教程不同，这里的 <code>jit.movi​e</code> 使用 <code>send</code> 和 <code>receive</code> 对象与 patch 的其余部分通信。名为 m1 和 m2 的 <code>receive</code> 对象将消息转发给两个 <code>jit.movi​e</code>  对象。然后发送它们的输出矩阵（使用 <code>send</code>）到 patch 其他位置名为 movie1 和 movie2 的 <code>receive</code> 对象。</p><p> patch 顶部的黄色区域包含驱动 patch 中 Jitter 进程的 <code>metro​</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16b.png" alt=""></p><center><code>metro</code> 驱动两个消息框中的一个</center><p>点击开关启动 <code>metro</code> 。 patch 中的三个 <code>jit.pwindow</code> 开始显示图像。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p><code>metro</code> 经过 <code>Ggate</code> 和 <code>jit.qball</code> 到达 <code>gate</code>。 <code>metro</code> 发送的 bang 由 <code>gate</code> 分流到两个消息框之一。最终输出矩阵（在 patch 底部的 <code>jit.pwindow</code> 中）将根据哪个消息框被触发而改变。</p><p>单击连接到 <code>gate</code> 左入口的两个消息框（1 和 2）。注意底部的 <code>jit.pwindow</code> 如何变化：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16c.png" alt=""></p><center>最终输出矩阵根据 patch 的消息顺序而变化</center><p>两个消息框都将 bang 发送到三个命名相同的 <code>receive</code> 对象（m1，m2 和 output）。两者的区别在于发送消息的顺序。左侧消息框（由 <code>metro</code> 驱动，当 <code>gate</code> 设置为 1 时）将第一个 bang 发送到 <code>jit.movie</code> （rain movie）。最后，patch 底部的 <code>jit.matrix</code> 收到 bang，最终矩阵被发送出去。右侧消息框（由 <code>metro</code> 驱动，当 <code>gate</code> 被设置为 2 时）调换驱动 <code>jit.movie</code> 的两个 bang 的顺序（左 <code>jit.movie</code> 先输出矩阵，然后是右边的 <code>jit.movie</code>）。</p><p>当查看两个 <code>jit.movie</code> 和最终的 <code>jit.pwindow</code> 之间发生了什么时，这些消息发送的顺序才有意义。</p><blockquote><p>要点：如果不确定 Max patch 中发生事件的顺序，可以查看 patch 的 trace 的执行方式。在接线中设置断点就可以使用 “Auto Step” 命令逐步执行 patch ，查看它如何运行。但是这对于 <code>metro</code> 效果不好，因为 bang 将持续重启。先在  <code>metro</code> 位置添加按钮用于调试。</p></blockquote><h2 id="名字里面有什么？"><a href="#名字里面有什么？" class="headerlink" title="名字里面有什么？"></a>名字里面有什么？</h2><p>一旦 <code>jit.movie</code> 接收到 bang，就会向下面的 <code>send</code> 对象输出一个矩阵，然后传递给名为 movie1 和 movie2 的 <code>receive</code> 对象。<code>receive</code>（在 patch 右侧两个相同的区域）连接到 <code>jit.pwindow</code> 以及两个已命名的 <code>jit.matrix</code> 对象：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16d.png" alt=""></p><center>已命名的 <code>jit.matrix</code> </center><p> patch 右侧的两个 <code>jit.matrix</code>（以及 patch 底部 <code>jit.pwindow</code> 上方的 <code>jit.matrix</code>）都有名称。这三个对象的名称是 composite。它们共享包含在名为 composite 的矩阵中的数据。</p><p>理解了两个 <code>jit.movie</code> 将数据写入相同的矩阵（名称相同的两个独立的 <code>jit.matrix</code>），就明白为什么 bang 的顺序很重要。如果左边的 <code>jit.movi​e</code> 首先发出矩阵，它会将数据写入 composite 矩阵，然后是右边的 <code>jit.movi​e</code>，它将数据写入同一个矩阵。如果两个矩阵写入任何共同的单元格（见下文），那么最后到达的矩阵将覆盖之前单元格中的数据。</p><h2 id="目的地维度"><a href="#目的地维度" class="headerlink" title="目的地维度"></a>目的地维度</h2><p>教程 patch 右侧的两个 <code>jit.matrix</code> 对象将 <code>usedstdim</code> 属性设置为 1。这样可以缩放由 <code>jit.movie</code> 发送的矩阵，以便它们只写入 composite 矩阵的某个区域。</p><p>调整标记为 <code>x origin</code> <code>y origin</code> 的数字框，缩放它所连接的两个子 patch <code>p coords</code>。请注意 composite 矩阵如何移动和调整 <code>jit.movie</code> 中两个图像的大小。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16e.png" alt=""></p><center>图片内的图片</center><p><code>p coords</code> 包含相同的辅助 patch ，用于格式化 <code>jit.matrix</code> 对象的 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性。这些属性分别指定将数据复制到 composite 矩阵时的左上角和右下角坐标。<code>usedstdim</code> 属性告诉 <code>jit.matrix</code> 复制数据时使用这些属性。当 <code>usedstdim</code> 为 0 时，缩放输入矩阵以填充 <code>jit.matrix</code> 引用的整个矩阵。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16f.png" alt=""></p><center>写入共享矩阵之前先缩放输入矩阵</center><p>发送到子 patch 的三个数字由内部对象格式化，生成要填充的输出矩阵的左上和右下区域坐标列表。消息在输出前，用 $ 暂时替代列表中对应的数字参数。</p><p>在两个矩阵写入 composite 矩阵之后，最后一件事是发送 bang 到名为output 的 <code>receive</code> 对象：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16g.png" alt=""></p><center>最后的结果</center><p>教程 patch 底部的区域是第三个名为 <code>jit.matrix</code> 的对象。由 <code>metro</code> 发送的 bang 经过一个 <code>trigger</code> 对象发送 bang 到 <code>jit.matrix</code>（让它输出矩阵到 <code>jit.pwindow</code>），紧接一个 <code>clear</code> 消息（0），清除所有名为 composite 矩阵中的单元格。如果不清空矩阵，改变任何<code>jit.matrix</code> 的 <code>dstdimstart</code> 和<code>dstdimend</code> 属性，可能导致残留之前输出位置的图像。</p><h2 id="队列优先级"><a href="#队列优先级" class="headerlink" title="队列优先级"></a>队列优先级</h2><p>当 Max 运算跟不上速度时， patch 顶部的 <code>jit.qball</code> 对象就有了用武之地。<code>metro​</code> （每隔 50 毫秒发出 bang）正在触发三个独立的操作（从 <code>jit.movi​e</code> 对象写入数据到两个已命名的矩阵，显示数据，清空矩阵以便重新开始）。<code>jit.matrix</code> 写入数据到内部矩阵（这个例子中是 composite 矩阵）并允许后续消息来插队。运行任务时，它允许其他优先级更高的 Max 事件发生。这样可以在前一操作完成之前显示矩阵（或将更多数据写入），从而引起闪烁和其他意外结果。</p><p><code>jit.qball</code> 对象把消息放到 Max 低优先级队列的最后， 在那里其他消息可以被优先处理。如果 <code>jit.qball</code> 在所有当前任务完成之前从 <code>metro​</code> 得到 bang，它将等到队列中其他所有任务都完成后，再发出 bang。同样，如果另一个 bang 在发出第一个 bang 之前就出现了（即如果 patch 的剩余时间需要超过 50 毫秒才能完成所有事情），第一个 bang 将被抢先（抛弃）而只发出第二个 bang。这让我们可以放心地在 Max patch 中设置极值，而不必担心事件累积过快 Max 处理不过来。</p><p>单击标记为 <code>jit.qball bypass switch</code> 的 <code>Ggate</code> 对象，让 <code>metro​</code> 的输出绕过 <code>jit.qball</code> 。底部 <code>jit.pwindow</code> 中的合成图像开始闪烁，表示消息乱序到达。</p><p>通常，发送 bang 到 Jitter 对象将插到已经挂起的事件（例如已经到达但尚未被处理的 bang）前面。不过 <code>jit.qball</code> 提供了对多个 Jitter 对象链的控制，自动调度事件（dropframing）保证消息以正确的顺序到达。</p><blockquote><p>注：在大多数应用中 <code>Qball</code>已被 <code>qmetro​​</code> 取代。 <code>qmetro​​</code> 是内置 <code>qball</code> 机制的 <code>metro​​</code> 对象。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>命名多个 <code>jit.matrix</code> 为同一个名称，可以在 patch 的不同部分中写入和读取矩阵数据。使用 dstdimstart 和 dstdimend 属性，或者设定 usedstdim 属性为 1，可以在将其复制到 <code>jit.matrix</code> 内部时缩放矩阵。<code>jit.qball</code> 对象把 Max 事件放到低优先队列中来降低优先级，如果没有足够资源来执行，则优先处理其他事件。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p><center>👇👇👇</center></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译17 - 图像旋转</title>
    <link href="http://uegeek.com/180915-jitter-17.html"/>
    <id>http://uegeek.com/180915-jitter-17.html</id>
    <published>2018-09-15T12:09:37.000Z</published>
    <updated>2018-09-15T12:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-8.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter15" target="_blank" rel="noopener">Tutorial 15: Image Rotation</a></p></blockquote><h2 id="使用-jit-rota-旋转和缩放"><a href="#使用-jit-rota-旋转和缩放" class="headerlink" title="使用 jit.rota 旋转和缩放"></a>使用 jit.rota 旋转和缩放</h2><p>Jitter 提供 <code>jit.rota</code> 对象来旋转和/或缩放图像。旋转和缩放是常见的视频效果，以不同方式组合它们还可以实现万花筒效果。<code>jit.rota</code> 在入口处获取视频数据矩阵（或其他类型的图像），根据对象属性的设置发送已缩放、旋转和以其他方式失真的版本。</p><p>打开教程 patch 。loadbang 触发 QuickTime 视频 dishes.mov 读入 <code>jit.movi​​e</code>。单击 “Display” 开关启动 <code>metro</code> 开始播放视频。</p><p>视频是一个对着餐盘拍摄的三秒从左到右平移镜头。<code>jit.movi​​e</code> 的循环属性初始化为 2，因此视频来回循环产生了来回平移的效果。</p><blockquote><p>注意：Jitter 对象的许多属性使用参数 1 和 0 表示 “on” 和 “off”，因此可以合理地假设 <code>jit.movi​​e</code> 的 loop 属性也是这样。loop 0 关闭循环，loop 1 打开，loop 2 让视频向前播放，到达 loopend 点时向后播放，而不是跳回到视频起点。</p></blockquote><p><code>jit.rota</code> 的 theta 属性指定围绕中心锚点的旋转角度。</p><p>拖动 “Rotation Angle” 数字框旋转视频。正（或增加）值是逆时针旋转，负（或减小）值是顺时针旋转。旋转角度 - 也就是角度（θ） - 以弧度表示。0 或 2π 的任何倍数（如 6.283185）是正常的直立位置。π 值（3.141593）或 π 的任何奇数倍是颠倒的位置。随意尝试，直到了解 theta 值与 <code>jit.rota</code> 行为之间的关系。</p><blockquote><p>技术细节：<code>jit.rota</code> 用三角法进行大量内部计算，以确定如何旋转图像。如果不是三角学迷，你可能不习惯用弧度来思考角度。平时我们更常使用度数，即一个完整的旋转是 360°。在三角学中更常使用弧度，完整旋转是 2π 弧度。这是因为半径为 1 的圆的周长恰好为 2π，可以用与单位圆相交的点来表示角度。（例如，从单位圆上的一个点开始并绕圆周移动 π/2 的距离，会得到 90° 角度 - 即 π/2 弧度的角度 - 从开始的地方以圆心为中心）</p><p>另外，在三角学中，角度的正变化是围绕单位圆逆时针旋转，而在日常生活中，把顺时针运动看做 “正” 或 “增加” 更符合惯例（如钟表时针的转动）。</p><p>因此，如果把度为单位的顺时针旋转，转换为以弧度表示，需要将度角乘以 2π，然后除以 -360。</p></blockquote><h2 id="自动旋转"><a href="#自动旋转" class="headerlink" title="自动旋转"></a>自动旋转</h2><p>除了手动旋转图像外，还可以编写自动化程序提供不断变化的旋转角度。在<a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">上一章</a>中，我们编写了一个名为 rotate 的子 patch，它使用 <code>line</code> 对象将色调旋转角度从 0° 增加到 360°。现在做类似的事情，但使用 bang 视频的 <code>metro</code> 来增加旋转角度。为了使用上的友好，用 ° 表示旋转角度，而不是弧度（在子 patch 中转换度弧度单位），另外也显示转速为 “每秒转数”。</p><p>在标有 Degrees per bang 的数字框中输入数字 6。这让旋转角度在 <code>metro</code> 每次 bang 时增加 6°。由于 <code>metro</code> 每秒发出 20 次 bang（每 50 毫秒一次），我们可以通过公式 <code>d * 20 / 360</code> 计算每秒的转数（即 d / 18，d 是每次 bang 增加的角度）。现在单击标记为 On / Off 的开关开始自动旋转。</p><p>双击 <code>rotate</code> 查看子 patch</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter15a.png" alt=""><br>[rotate]子 patch 中的自动旋转</p><p>用度数 * 2π / -360，将用户指定的每次旋转角度转换为弧度量。当一个 bang 进入左入口时，如果正在旋转，bang 让旋转角度增加并添加到 <code>accum</code> 对象中。请注意，每次增加负的角度也 ok，这让图像逆时针旋转。当总旋转角度超过 2π（或 -2π）时，<code>split</code> 将值发送到使用模运算的 <code>expr</code>，并在发送到出口前将其恢复到范围内（重置 <code>accum</code> 中的值）。如过旋转关闭，我们 用 <code>sel 0</code> 检测到该事件，将 theta 角度重置为 0。</p><p>关闭子 patch 窗口。单击 On/Off 开关停止自动旋转。</p><h2 id="放大或缩小"><a href="#放大或缩小" class="headerlink" title="放大或缩小"></a>放大或缩小</h2><p><code>jit.rota</code> 的另一个主要功能是缩放。缩放量由 <code>zoom_x</code> 和 <code>zoom_y</code> 属性决定。这样可以单独放大或缩小水平和垂直尺寸；或者一次更改两个属性来同时缩放。</p><p>拖动标有 <code>Zoom</code> 的数字框来放大和缩小。大于 1 的值会放大图像，小于 1 的值会缩小图像。直接在 x 和 y 数字框中输入值分别更改 x 和 y 的缩放尺寸（负缩放值会翻转图像并调整其大小）。</p><p>当放大图像（如值为 2）时，图像质量仍然不错，因为我们已经用 <code>interp 1</code> 消息打开 <code>jit.rota</code> 的插值属性。如果关闭 interp，会在放大时产生像素化。当缩小时 interp 没有明显的效果，它几乎浪费了计算资源。（有关像素化和插值，请参阅 <a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Jitter 教程16</a>）不过插值确实可以改善旋转图像的现实，即便图像缩小。</p><h2 id="超越边缘"><a href="#超越边缘" class="headerlink" title="超越边缘"></a>超越边缘</h2><p>将缩放的两个尺寸设置为较小的值例如 0.25。</p><p>当图像由于收缩或旋转而未填满整个显示区域时，<code>jit.rota</code> 必须决定如何处理位于图像区域外的矩阵的其余部分。现在 <code>jit.rota</code> 将图像区域外的所有单元格值设置为 0，使它们为黑色。<code>boundmode</code>属性决定 <code>jit.rota</code> 如何处理位于图像边界之外的单元格。不同的可用 <code>boundmode</code> 设置显示在 patch 右上角标记为 <code>Space outside the image</code> 的弹出菜单中。将 <code>boundmode</code> 的值初始化为 1，让 <code>jit.rota</code> 清除所有外围单元格。以下是每个 <code>boundmode</code>设置的含义：</p><blockquote><p>0 Ignor：保持所有外围单元格不变。</p><p>1 Clear：将所有外围单元格值设置为0。</p><p>2 Wrap：根据需要重复图像以填充矩阵。</p><p>3 Clip：对于所有外围单元格，继续使用图像边界单元格的值。</p><p>4 Fold：重复图像，向相反方向翻转。</p></blockquote><ul><li>对于缩小图像时的特殊效果，尝试将 <code>boundmode</code> 属性设置为 2（Wrap）以获得 “Warhol” 复制图像效果，或设置为 4（Fold）得到万花筒效果。</li><li>现在试着重新打开自动旋转，组合旋转和缩放，并修改参数（每次 bang 的度数、缩放、Space outside the image）。</li><li>尝试完以后，关闭自动旋转并将缩放属性（ <code>zoom_x</code>和 <code>zoom_y</code>）调整回 1。</li></ul><h2 id="调整锚点和偏移"><a href="#调整锚点和偏移" class="headerlink" title="调整锚点和偏移"></a>调整锚点和偏移</h2><p>目前为止，我们一直使用图像的中心作为旋转锚点。其实可以选择任意一点。用 <code>anchor_x</code> 和 <code>anchor_y</code> 属性设置旋转中心。现在是 160 和 120（图像尺寸的一半），可以在标记为 Anchor 的数字框中更改。</p><p>尝试不同的锚点，然后在 Rotation Angle 数字框上拖动查看效果。可以尝试 0,0 或 40,30 或 160，-120 或 320,240。将 <code>boundmode</code>属性设置为 1 可以更清楚地看到不同旋转的效果。请注意，<code>anchor_x</code> 和 <code>anchor_y</code> 值是相对于矩阵的左上角指定的，但它们可以超出矩阵维度的边界。</p><p>此外可以用 <code>offset_x</code> 和 <code>offset_y</code> 属性在缩放和旋转后，将图像移动到输出矩阵中的其他位置。</p><p>要最有效地查看此内容，请先单击 patch 右下角的 <code>pvar</code> 对象上方的消息框。这会将旋转角度/边界模式/缩放/锚点恢复到本章开头的设置。（已经为相关的 UI 指定了名称，以便通过 <code>pvar</code> 与它们通信）现在将缩放数字框设置为 0~1 的某个值来缩小图像。</p><p>使用 Location offset 数字框，更改 <code>offset_x</code>和 <code>offset_y</code> 值来移动图像。同时设置 <code>boundmode 4</code>，在 “kaleidoscope” 模式下查看效果。</p><p>完成后，将位置偏移值重置为 0。</p><h2 id="鼠标控制旋转"><a href="#鼠标控制旋转" class="headerlink" title="鼠标控制旋转"></a>鼠标控制旋转</h2><p>我们为你设计了另一种旋转图像的方法。</p><p>单击 <code>jit.pwindow</code> 显示对象，按住鼠标，围绕对象中心以小圆周运动拖动。</p><p><code>jit.pwindow</code> 跟踪鼠标移动，当鼠标按下时，它会以鼠标消息的形式将坐标信息（和其他鼠标信息）发送到右输出口。鼠标消息的前两个参数是相对于 <code>jit.pwindow</code> 左上角的 x 和 y 坐标。使用这些坐标来计算鼠标相对于 <code>jit.pwindow</code> 中心的角度并发送到 <code>jit.rota</code> 作为theta 属性的参数。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter15b.png" alt=""><br>用 <code>jit.pwindow</code> 中的鼠标位置作为控制信息</p><h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>想知道这是如何计算的吗？</p><p>如果将 <code>jit.pwindow</code> 的中心点视为原点 0,0，把当前鼠标位置看做是位于该点圆周上的点，那么可以基于这两点得到一个直角三角形。获取鼠标坐标 y / x 的反正切值，得到鼠标相对于 <code>jit.pwindow</code> 中心的角度。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter15c.png" alt=""></p><p>接收到传入的 x 和 y 坐标要做的第一件事是做转换，使它们以 <code>jit.pwindow</code> 为中心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr<span class="number">-1.0</span>*atan(($i1<span class="number">-160.</span>)/(<span class="number">-1.</span>*$i2+<span class="number">119.5</span>))+($i2&gt;=<span class="number">120</span>)*<span class="number">-3.141593</span></span><br></pre></td></tr></table></figure><p>用 x 坐标减去 160 （x 值现在在 -160~160）并将 y 坐标乘以 -1（这样上移时值正向增大）然后加上 119.5。（如果正好添加120，那么每次从 <code>jit.pwindow</code> 得到 120 的 y 坐标时都会尝试在 expr 中除以0，这是一个未定义的数学运算）转换了 x 和 y 坐标，用 <code>atan(y / x)</code> 来获得弧度，然后乘以 -1 使鼠标顺时针旋转，从而使图像顺时针旋转。</p><p>此方法仅在 180° 范围内有效，因为反正切函数无法区分鼠标位置与圆上相对点之间的差异（这两个点 y / x 的值相同）。因此每当鼠标的 y 坐标进入 <code>jit.pwindow</code> 的下半部分时，我们在 θ 角度上添加 -π 的偏移量来区分那些来自另外一边的位置。（表达式中的最后一部分）</p><p>请注意，此表达式仅适用于 <code>jit.pwindow</code> 中的点 160,120。如果想创建一个适用于任何大小 <code>jit.pwindow</code> 中心点的表达式，要使用 <code>getsize</code> 消息获取 <code>jit.pwindow</code> 的维度，并用 size 值作为表达式中的变量。正如书上所说，“我们把这个练习留给读者”。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.rota</code> 对象用 theta 属性指定旋转角度，以弧度表示旋转图像。它还提供了使用 <code>zoom_x</code>和 <code>zoom_y</code> 属性放大和缩小图像的简便方法。用 <code>anchor_x</code>和 <code>anchor_y</code> 属性更改旋转的中心点，用 <code>offset_x</code> 和 <code>offset_y</code> 属性在输出矩阵中移动生成的图像。可以用 <code>boundmode</code> 属性更改 <code>jit.rota</code> 处理位于结果图像之外的矩阵单元格的方式。结合这些功能，除了缩放和旋转之外，你还可以获得重复图像和万花筒效果。</p><p>缩放和旋转涉及 <code>jit.rota</code> 相当密集的内部计算，这些操作对计算机的处理器提出了很高的要求。本教程中未提及的其他属性，可以调整旋转公式中的几乎每个系数，提供更多扭曲和旋转图像的可能性。请查看 <code>jit.rota</code> 文档说明。</p><p>要同时管理对如此多属性，可以设计自动流程以生成属性值，和/或交互式控件来更改值。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译16 - 矩阵定位</title>
    <link href="http://uegeek.com/180909-jitter-16.html"/>
    <id>http://uegeek.com/180909-jitter-16.html</id>
    <published>2018-09-09T11:02:52.000Z</published>
    <updated>2018-09-09T11:04:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-7.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter14" target="_blank" rel="noopener">Max 7 - Tutorial 14: Matrix Positioning</a></p></blockquote><h2 id="在矩阵中数据定位"><a href="#在矩阵中数据定位" class="headerlink" title="在矩阵中数据定位"></a>在矩阵中数据定位</h2><p>本教程将讨论如何获取矩阵的一部分数据，放到另一个矩阵中不同位置。要重新定位数据的原因可能有很多。这里讨论的技巧主要为了生成各种视觉效果，但对于其他目的也适用。</p><p>我们将展示如何分离矩阵的一个区域，将其放到另一个矩阵中的指定位置，调整大小（对于拉伸、像素化和模糊等视觉效果非常有用）并动态移动它。</p><h2 id="jit-window"><a href="#jit-window" class="headerlink" title="jit.window"></a>jit.window</h2><p>打开 Window_options 子 patch</p><p>在 patch​ 左下角有一个<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">教程 3</a> 介绍过的 <code>jit.window</code> 对象。它创建一个单独的窗口来显示矩阵内容。在大多数其他教程章节中都使用 <code>jit.pwindow​</code>。</p><p><code>jit.window</code> 和 <code>jit.pwindow​</code> 非常相似 - 除了一个是打开单独的窗口而另一个使用 Patch 中的矩形区域 - 它们有许多相同的属性和消息。但也有一些差异，这将使用 <code>jit.window</code> 来展示一些特性。</p><p>你可能看不到 <code>jit.window</code> 打开的 Display 窗口，因为它隐藏在 Patch 窗口后面。我们可以让 Display 窗口浮动 - 一直在浮动在 Max 每个窗口之上，同时仍然与 Patch 窗口交互。为此要用 <code>floating 1</code> 消息打开 <code>jit.window</code> 的浮动属性（默认为 0）。</p><p>打开 Window_options 子 patch​ ，单击标记为 <code>Display as floating window</code> 开关，将 <code>floating 1</code> 消息发送到 <code>jit.window</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14a.png" alt=""><br>使窗口“浮动”在其他窗口前面</p><p>输入到 <code>jit.window</code> 的屏幕坐标 - <code>450 60 770 300</code> - 指定了 320 像素宽，240 像素高的显示区域。（如何为 <code>jit.window</code> 指定屏幕坐标，请参阅本章后面的说明和/或<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">教程 3</a>）</p><h2 id="从一个-jit-matrix-到另一个"><a href="#从一个-jit-matrix-到另一个" class="headerlink" title="从一个 jit.matrix 到另一个"></a>从一个 jit.matrix 到另一个</h2><p>现在加载图片并尝试修改。</p><p>单击消息框 <code>importmovie sunset.jpg</code> 将图片加载到 patch 顶部的 <code>jit.matrix</code> 中。打开标有 <code>Display On/Off</code> 的 <code>metro</code>，开始向 <code>jit.matrix</code> 发送 bang。</p><p>用 <code>jit.window</code> 显示图像之前，bang 将矩阵（通过 <code>jit.hue</code>）发送到第二个 <code>jit.matrix</code>。在那里能够修改属性以指定显示矩阵的哪个部分。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14b.png" alt=""><br>发送矩阵给另一个 <code>jit.matrix</code>，然后到 <code>jit.window</code> </p><p>我们已经在 patch​ 中间的 <code>preset</code> 中为 UI 对象保存了几个配置。</p><p>选择 <code>preset</code> 中的配置 1 会发送 <code>dim 16 12</code> 消息将下方的 <code>jit.matrix</code> 的尺寸更改为 16x12。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14c.png" alt=""><br>dim 消息改变<code>jit.matrix</code>的维度</p><p>输入矩阵的尺寸是 320x240，但是接收 <code>jit.matrix</code> 的尺寸仅为 16x12，它尽可能显示接收的矩阵，但必须丢弃大部分信息。这会导致图像像素化（指用低分辨率 - 较小的像素 - 来显示图像时产生的马赛克效果）。即使 <code>jit.window</code> 能够显示全分辨率 320x240 的图像，它接收的矩阵现在只有 16x12。出于显示目的，它按需复制像素，将 16x12 矩阵「扩展」为 320x240。</p><p>拖动标有 “Change actual matrix dimensions” 的两个数字框，查看不同的像素化效果。</p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>现在将数字框设置回 16 和 12，然后单击标记为 <code>Interpolate in window to smooth pixelation</code> 的开关将 <code>interp 1</code> 消息发送到 <code>jit.window</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14d.png" alt=""><br>在 <code>jit.window</code> 中打开插值</p><p>现在由 <code>jit.window</code> 在输入矩阵和扩展到 320x240 之间插值，而不是复制 16x12 像素来制作一堆 20x20 像素块。也就是说，当它扩展图像时，在每个单元格值与其输入矩阵中的相邻值之间，创建平滑的颜色渐变，因此 320x240 矩阵中从一个单元到另一个单元的所有变化都尽可能渐进发生。插值会产生极大的模糊，因为输入和输出矩阵的大小差异很大。</p><p>再次点击开关，发送 <code>interp 0</code> 消息给 <code>jit.window</code> 设置 interp 的属性为 0（关闭）。在标记为 <code>Change actual matrix dimesions</code> 的数字框中输入新的矩阵尺寸，减少图像像素化：例如，80 和 60（现在像素化块每个只有 4x4）。点开关重新开启插值。请注意，在这种情况下模糊减轻了，因为插值只发生在 4 个像素上。再次关闭插值。</p><p>现在点击标记为 <code>Interpolate in matrix to smooth pixelation</code> 的开关，打开 <code>jit.matrix</code>（而不是 <code>jit.window</code>）的插值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14e.png" alt=""><br>减小矩阵的大小时，插值就不明显</p><p>这没有太大变化。因为 <code>jit.matrix</code> 仍然只能发送 80x60 矩阵。在这种情况下的插值（缩小而不是放大矩阵时）可以忽略不计。</p><p>再次点开关关闭 <code>jit.matrix</code> 的插值。</p><h2 id="隔离矩阵的一部分"><a href="#隔离矩阵的一部分" class="headerlink" title="隔离矩阵的一部分"></a>隔离矩阵的一部分</h2><p>在 <code>preset</code> 中，选择配置 2。现在只能看到图片的一小部分。</p><p>这个配置将 <code>jit.matrix</code> 的尺寸恢复为 320x240。但是仍然可以使用一些属性来隔离矩阵的特定部分而不改变整个矩阵的实际尺寸： <code>srcdimstart​</code> ，<code>srcdimend​</code> 和 <code>usesrcdim</code>。</p><p>向 <code>jit.matrix</code> 发送三条新消息来设置这三个属性：<code>dimstart 40 150</code>，<code>dimend 119 209</code> 和 <code>usesrcdim 1</code>。这些消息指定输入矩阵的子集，并将这些值作为全尺寸（在本例中为 320x240）矩阵发送出去。输入矩阵的这个子集在 <code>jit.matrix</code> 「扩展」（按需复制单元格），以填充输出矩阵的大小。<code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性被忽略。</p><p>设置 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性的消息中，单词紧跟的是描述每个维度内起点和终点的单元索引。<code>dimstart 40 150</code> 和 <code>dimend 119 209</code> 消息告诉 <code>jit.matrix</code> 在水平维度中使用来自单元格 40~119 的特定 80x60 区域，在垂直维度中使用单元格 150~209。</p><blockquote><p>本章中讨论了三种指定矩形区域的方法！关键要明确每种情况下指定的内容。</p><ul><li><p>在 <code>jit.window</code> 中输入显示区域的坐标。在计算机的操作系统中，屏幕坐标原点在左上角，是 0,0; 往右两个像素（左起第三个像素）是 2,0; 该点向下 5 个像素（向下的第六个像素) 是 2,5。输入矩形的左-上-右-下的参数坐标描述屏幕的矩形区域。</p></li><li><p><code>jit.matrix</code> dim 属性指定维度大小（单元格数量）。</p></li><li><p><code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性指定单元格索引（包含）。单元格索引从 0 到单元格数量 - 1（平面的索引也类似）。对于 320x240 矩阵，第一维中单元格索引从 0~319，第二维索引从 0~239。对于 <code>jit.matrix</code> 的维度，用 <code>srcdimstart​</code> 后跟起始单元格索引，来指定每个维度的起点，用 <code>srcdimend​</code>  后跟结束单元格索引，来指定终点。</p></li></ul></blockquote><p>输入矩阵仅有 80x60 像素，而目标矩阵为 320x240。较小矩阵扩展为较大矩阵会导致像素化。但是现在扩展发生在 <code>jit.matrix</code> 内部（即在它的“源”区域和“目标”大小之间），而不是在 <code>jit.matrix</code> 和 <code>jit.window</code> 之间（正如之前减小 <code>jit.matrix</code> 尺寸）。如果想通过插值来平滑像素化，必须在 <code>jit.matrix</code> 中完成。在 <code>jit.window</code> 中启用插值没有意义，因为它已经从 <code>jit.matrix</code> 接收到 320x240 矩阵。</p><p>要验证这一点，请打 <code>interpolate in window...</code> 开关发送 <code>interp 1</code> 到 <code>jit.window</code>。因为我们试图将 320x240 矩阵插入到 320x240 显示区域，因此不会发生任何变化。关闭开关，将 <code>jit.window</code> 差值属性设置回 0。现在用另一个开关将 <code>interp 1</code> 消息发送到 <code>jit.matrix</code>。现在得到了我们想要的平滑效果。</p><p>尝试输入新值来更改 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性的参数。这样可以将图片的任何特定区域隔离为“源”区域。为源区域选择的尺寸将决定图片在扩展到填充 320x240 输出矩阵时的失真程度。</p><h2 id="翻转图像"><a href="#翻转图像" class="headerlink" title="翻转图像"></a>翻转图像</h2><p>你可能认为 <code>srcdimend​</code> 属性的参数（源区域的终点单元索引）应该大于 <code>srcdimstart​</code>。并非如此。</p><p>选择 <code>preset</code> 的配置 3 垂直翻转图片。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14f.png" alt=""><br>顶部和底部在第二维中翻转</p><p>如果在垂直维度中指定小于起始索引的结束单元格索引，<code>jit.matrix</code> 仍将这些索引与目标矩阵的垂直维度中的起点和终点相关联，从而有效地反转值的方向。</p><p>可以在水平维度中进行翻转以水平翻转图像。如果在两个维度上翻转源区域，会得到将图像旋转 180° 的视觉效果。</p><p>选择 <code>preset</code> 的配置 4。</p><p>这个例子在两个维度上翻转了源区域，将大小减小到 160x120 ，并打开 interp 属性来平滑像素化。</p><h2 id="调整输出矩阵的大小"><a href="#调整输出矩阵的大小" class="headerlink" title="调整输出矩阵的大小"></a>调整输出矩阵的大小</h2><p>既然可以指定矩阵的源区域，那么也可以指定目标区域。这仍然不会改变输出矩阵的大小，dim 属性为 320x240。但是会更改源区域所在的区域。输入矩阵的源区域，将被放置在输出矩阵的目标区域中（按需扩展/收缩）。位于目标区域之外的输出矩阵的单元将保持不变。</p><p>选择 <code>preset</code> 的配置 5。整个输入矩阵被挤压到输出矩阵中心的 80x60 矩形中。</p><p>首先要注意的是 <code>usesrcdim</code> 属性已被关闭，因此我们再次使用整个输入矩阵作为源（现在忽略 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性）。<code>usedstdim</code> 属性已打开，输入将被放在输出矩阵的任意指定部分。<code>dstdimstart</code> 和 <code>dstdimend</code> 属性指定矩阵中间的单元为目的地：<code>dstdimstart 120 90</code> 和 <code>dstdimend 199 149</code>。我们关闭了 interp 属性，因为现在正在收缩图像。</p><p>另外，我们已打开标记为 <code>Erase previous image</code> 的开关。这将数字 1 发送到 <code>if $2 then clear</code> 对象。该语句的 if 部分现在为 true ，因此每次对象在左入口处收到消息时，将发送 <code>clear</code> 消息。这会在显示图像后立即清除 <code>jit.matrix</code> 对象的内容，为将要接收的下一个 <code>jit.matrix</code> 准备。这样可以确保目标区域外的所有单元格的值都为 0，输出矩阵的未使用区域将显示为黑色。</p><p>更改指定目标尺寸的数字框中的值，在 Display 窗口中移动（并调整尺寸）图片。</p><p>关闭标记为 Erase previous image 的开关停止 <code>clear</code> 消息。更改 <code>dstdimstart</code> 和 <code>dstdimend</code> 的参数，注意这次有什么不同。之前的目标区域仍然在 Display 窗口中绘制，因为矩阵中的那些单元格尚未清除，如果它们位于新目标区域之外，将保持不变。这样产生了前面图像的残留效果，可进一步获得特定的视觉效果。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14g.png" alt="">            </p><h2 id="在矩阵中移动图像数据"><a href="#在矩阵中移动图像数据" class="headerlink" title="在矩阵中移动图像数据"></a>在矩阵中移动图像数据</h2><p>自动设置 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性过程，我们可以在矩阵中移动数据，使图像看起来在实时移动。</p><p>选择 <code>presets</code> 的配置 6。</p><p>这将启动 <code>move_around​</code> 子 patch 内部的自动过程，持续提供新的参数给 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性。用 patch 上方的开关启动，数字框为每次移动到新目的地指定时间（以毫秒为单位）。</p><p>双击 patch <code>move_around​</code> 查看子 patch 内容。目前为止我们只使用了子 patch​ 的右半部分。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14h.png" alt=""><br>子 patch [<code>move_around​</code>] 中的目标移动过程</p><p>右入口中的 rate 值是 <code>metro</code> 的时间间隔。定期触发 4 个 <code>random</code> 对象，随机选择新的左-上-右-下索引。这些目标点与时间值一起发送到 <code>line</code> 对象，再以每 50 毫秒间隔发出，把目标区域逐步转移到这些新的随机点（显示图像的速率）。在子 patch​ 之外，这些值用作 <code>jit.matrix</code> 的 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性的参数。</p><p>这个子 patch​ 包含一些值得注意的技巧。第一个技巧我们已经实现过，它让 <code>dstdimend</code> 的参数可以超过矩阵的 320x240 范围。例如，使用 <code>random 640</code> 对象作为水平维度，然后从结果中减去 160，得到从 -160~479 的结束单元格索引。这样做是为了增大目标区域，以便图像变化时看到较大的视图，这也意味着图像将更频繁地移动到窗口边缘。值得注意的是，可以指定超出矩阵实际单元格的目标边界，<code>jit.matrix</code> 能够在该区域内完整显示图像（当超出矩阵尺寸时裁剪）。</p><p>第二个技巧比较细节：使用 <code>sel 0</code> 对象来检测 <code>metro</code> 何时关闭，用它来触发每个 <code>line</code> 对象的 <code>stop</code> 消息，以便它们在自动流程关闭后不会继续发送值。</p><p>关闭 [move_around​]子 patch​ 窗口。</p><h2 id="更改，调整大小和移动源图像"><a href="#更改，调整大小和移动源图像" class="headerlink" title="更改，调整大小和移动源图像"></a>更改，调整大小和移动源图像</h2><p>现在我们也将更改源图像自动化。</p><p>选择 <code>presets</code>的配置 7。</p><p>与设置目标区域的方式大致相同，现在需要不断改变图像的源区域。我们现在看到源矩阵的一些矩形子集的动画视图（使用 <code>srcdimstart​</code> 和 <code>srcdimend​</code>），不断调整该视图的大小并在窗口中移动它（使用 <code>dstdimstart</code> 和 <code>dstdimend</code>）。由于[<code>move_around​</code>]子 patch​ 随机选择源矩形和目标矩形，因此图像有时也会被翻转。<code>jit.matrix</code> 的插值属性已经打开，平滑源图像被拉伸时出现的像素化。</p><p>要更清楚看到变化，打开标记为 <code>Erase previous image</code> 开关。</p><h2 id="关于尺寸的更多信息"><a href="#关于尺寸的更多信息" class="headerlink" title="关于尺寸的更多信息"></a>关于尺寸的更多信息</h2><p>本教程介绍了如何更改 <code>jit.matrix</code> 的维度，以及如何在对象中指定源和目标区域。为了便于讨论和可视化，我们在二维矩阵内指定源矩形和目标矩形。这也可以用于任意维度的矩阵。（<code>srcdimstart​</code> ，<code>srcdimend​</code> ，<code>dstdimstart</code> 和 <code>dstdimend</code> 的参数个数对应于 <code>jit.matrix</code> 的维度）。 例如，如果有一个三维矩阵，这些参数可用于指定矩阵的虚拟 3D 空间中的六面体。</p><blockquote><p>注意：某些专门处理 2D 矩阵的 Jitter 对象（例如 <code>jit.movi​​e</code>），源和目标区域将始终为矩形区域。在这些对象中，源区域和目标区域在名为 srcrect 和 dstrect 的单个属性中定义，这些属性用四个参数来指定矩形的边界（左上角和右下角）单元格。</p></blockquote><h2 id="Hue-Rotation"><a href="#Hue-Rotation" class="headerlink" title="Hue Rotation"></a>Hue Rotation</h2><p>为了增添一点多样性，在两个 <code>jit.matrix</code> 中间增加 <code>jit.hue</code> 对象。（<a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">教程 9 详细介绍了 <code>jit.hue</code></a>）</p><p>选择 <code>presets</code>配置 8 并查看正在运行的 <code>jit.hue</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14i.png" alt=""><br>修改色调角度</p><p>这个配置关闭 <code>usedstdim</code> 但打开 <code>usercdim</code>，并在 <code>jit.matrix</code> 中启用插值以模糊扩展的图像。rotate 子 patch 自动旋转 <code>jit.hue</code> 的色相角度。</p><p>双击打开 rotate 查看子 patch。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14j.png" alt=""><br>[rotate]子 patch​ </p><p>右入口的值指定完成 360° 色调旋转的时间（以毫秒为单位）。当 1 进入左入口时，数字 360 与该时间值组合，指示 <code>line</code> 对象在该时间内从 0 到 360，每 50 毫秒发出一个新的值。</p><p>请注意，<code>line</code> 的第一个 typed-in 参数包含一个小数点，说明 <code>line</code> 发送浮点数而不是整数以提高精度（而且 <code>jit.hue</code> 的 hue_angle 消息接收浮点数）。当<code>line</code> 到达 360，右出口发出 bang。用它将 <code>line</code> 设置回 0，然后 re-bang <code>pack</code> 对象开始下一个旋转。当左入口处接收到 0 时，<code>sel 1</code> 对象直接将其传递到 <code>line</code> 停止重置色调角度为 0。</p><p>关闭[rotate]子 patch​。</p><p>选择 <code>preset</code> 配置 9。它基本上整合了 patch​ 中所有自动化和图像处理技巧。这次 <code>jit.matrix</code> 的目标尺寸变化设置为 200 毫秒，以更快的速率产生效果。</p><h2 id="全屏显示"><a href="#全屏显示" class="headerlink" title="全屏显示"></a>全屏显示</h2><p>当你用 Max patch​ 创建了想要的图像，并想以更优雅的方式显示结果时，可以让 <code>jit.window</code> 全屏。它的 <code>fullscreen</code> 属性打开时，<code>jit.window</code> 使用整个屏幕作为显示区域。如果不勾选 inspector 中的 fsmenubar 属性，将隐藏菜单栏。</p><p>关于 <code>jit.window</code> 全屏功能，有几点需要注意。</p><p>首先，一旦全屏（特别是隐藏了菜单栏时），无法再使用鼠标退出全屏。所以需要在 Max patch​ 中设置让全屏属性恢复为 0 的方法。</p><p>其次，只有一个 <code>jit.window</code> 可以全屏。如果有多个 <code>jit.window</code> 对象争夺全屏访问权限，则最近将全屏属性设置为 1 的对象将填满屏幕。</p><p>此外，即使 <code>jit.window</code> 全屏，其分辨率也由其实际尺寸（即其 rect 属性的参数）决定。例如，如果 rect 属性指定了 320x240 的矩形，那会作为图像的分辨率，即使屏幕尺寸远大于此。</p><p>在 Window_options 子 patch​ 中，包含了使用空格键打开和关闭 <code>jit.window</code> 全屏属性的功能。<code>jit.window</code> 将 fsmenubar 设置为 0。这在全屏时隐藏顶部菜单栏（Mac）。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14a.png" alt=""><br>使用空格键切换到全屏显示</p><p>尝试使用空格键打开和关闭全屏。</p><p>要获得更抽象的视觉效果，请将 colorswatch.pict 图像导入到 patch 顶部的 <code>jit.matrix</code> 中，然后尝试不同的配置。</p><p>本教程使用静止图像作为源素材，以便查看演示效果，当然也可以使用视频。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>隔离和重新定位矩阵中的某些数据有不同的方法。<code>jit.matrix</code> 的 dim 属性设置矩阵的实际尺寸。<strong>打开 <code>jit.matrix</code> 的 <code>usesrcdim</code> 和 <code>usedstdim</code> 属性，可以使用输入和输出矩阵的指定区域</strong>，它们被称为源（source）和目的（destination）区域。</p><p>使用 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性指定这些区域的单元格边界（将起始和结束单元格设置为源区域的角点）和 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性（用于目标区域）。</p><p>这些属性不会改变矩阵的实际大小，当 <code>usercdim</code> 和 <code>usedstdim</code> 打开时，它们指定输入矩阵的某部分将显示在输出矩阵的哪个部分。如果源区域和目标区域的形状（大小）不同，<code>jit.matrix</code> 将扩展或收缩源区域以适合目标区域。这会导致重复或丢失数据，但可以产生有趣的拉伸或像素化效果。源区域和目标区域可以使用 Max patch​ 的其他部分的数字来动态更改，以便交互式或自动修改图像的大小、形状和位置。</p><p>interp 属性打开时，如果目标区域的尺寸大于源区域，<code>jit.matrix</code>  在它们之间插值（提供中间值）。这可以平滑像素化效果，并模糊相邻单元格的变化。</p><p><code>jit.window</code> 用已经指定的 rect 属性大小的矩形区域，显示它接收的任何尺寸的矩阵。如果输入矩阵的大小与显示区域的大小不同，图像将被 <code>jit.window</code> 扩展、缩小或扭曲。这也可以用于拉伸和像素化效果。 打开 <code>jit.window</code>  interp 时，可平滑拉伸和像素化。</p><p>要使用图像填充整个屏幕，可以打开 <code>jit.window</code> 全屏属性，并用 <code>fsmenubar 0</code> 消息隐藏菜单栏。（要留下一些方法让 Patch 窗口回到前台）</p><p>我们已经演示了调整矩阵数据的大小、重新定位、翻转和插值以生成视觉效果（如拉伸，扭曲，模糊和像素化）的技巧。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译15 - 剪刀和胶水</title>
    <link href="http://uegeek.com/180908-jitter-15.html"/>
    <id>http://uegeek.com/180908-jitter-15.html</id>
    <published>2018-09-08T10:12:52.000Z</published>
    <updated>2018-09-08T10:14:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-6.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter13" target="_blank" rel="noopener">Tutorial 13: Scissors and Glue</a></p></blockquote><p>本教程学习如何使用两个简单的对象来切割和组合二维矩阵的矩形区域。</p><p>教程 patch 有两个互补的 Jitter 对象：将矩阵切割成大小相等的小矩阵的 <code>jit.scissors</code>; 将多个矩阵粘贴到一起的 <code>jit.glue</code>。还会简要介绍 <code>router</code> 对象，它可以将 Max 消息从多个源引导到多个目的地。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13a.png" alt=""><br>读取视频</p><p>patch 左上角的 <code>loadbang</code> 自动发送 <code>read traffic.mov</code> 消息给 <code>jit.movi​​e</code> 加载交通镜头的视频。</p><p>点击 patch 顶部的开关启动 <code>metro</code>。视频出现在底部较大的  <code>jit.pwindow</code> 中。有趣的是，图像被切割成四个象限，出现在分开的的 <code>jit.pwindow</code> 中。</p><h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><p><code>jit.scissors</code> 把包含视频的矩阵分割成四个小矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13b.png" alt="">        </p><p><code>jit.scissors</code> 将任意尺寸/类型/平面数的矩阵切割成更小的矩阵，然后在不同出口发送。@rows 和 @columns 属性指定每次接收到矩阵时分割成多少个小矩阵。这里 <code>jit.scissors</code> 将图像拆分为四个小矩阵（2 列 2 行）。这些单独的矩阵以<strong>列优先</strong>顺序发送到各出口（从左到右，然后从上到下）。</p><p><code>jit.scissors</code> 有两个属性非常重要：</p><p>1）出口数量在创建对象时就确定。只有在对象框中指定行和列属性，才会生成对应数量的出口。例如，<code>jit.scissors @rows 10 @columns 2</code> 将创建一个有 20 个出口的 <code>jit.scissors</code> 实例（包括用于查询属性的最右出口），如果 <code>jit.scissors</code> 没有参数，就只会生成一个出口。可以用 Max 消息更改行和列属性，但是无法添加超过对象初始化时的出口数量。</p><p>2）<code>jit.scissors</code> 发送的矩阵大小等于矩阵切片的大小，而不是整个原始矩阵。例如，教程 patch 中的四个较小的矩阵，每个都是 160x120 个单元，而不是 320x240。</p><h2 id="Routing-the-Matrices"><a href="#Routing-the-Matrices" class="headerlink" title="Routing the Matrices"></a>Routing the Matrices</h2><p>由 <code>jit.scissors</code> 输出的四个小矩阵，被发送到两个不同的地方： <code>jit.pwindow</code> 和 <code>router</code> 对象。彩色接线显示每小矩阵被发送到了哪里。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13c.png" alt=""><br><code>router</code> 对象</p><p><code>router</code> 是 <code>gate</code> 和 <code>switch</code> 的组合。它有两个参数（输入口数量和输出口数量），由左入口的消息指定。<code>router</code> 能处理的大多数消息与 MSP 对象 <code>matrix~</code> 相同。因此可以跟 <code>matrixctrl</code> 对象一起使用。</p><p><code>router</code> 右侧的四个入口从 <code>jit.scissors</code> 的四个矩阵出口获取输入。<code>receive routeit</code> 对象从 patch 的右下方控制 <code>router</code> 的 <code>s routeit</code> 获取消息。<code>router</code> 最左边四个出口连接到 <code>jit.glue</code> 对象，我们稍后会讨论。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13d.png" alt=""><br>控制路由器</p><p>发送消息 <code>patch $1</code> 后跟入口号($1)和出口号到 <code>router</code>， 会在该入口和对象的出口之间建立虚拟连接。到达该入口的任何消息会转发给相应出口。如果先前已有入口连接到该出口，patch 消息将切断该连接以支持新连接。</p><p>patch 中的 <code>radiogroup</code> 对象控制四个小矩阵（到达入口）被发送到 <code>router</code> 的哪些出口。入口和出口从 0 开始编号，所以 <code>2 1</code> 在 <code>router</code> 的 3 入口和 2 出口建立连接。</p><p>单击 <code>radiogroup</code> 控件并观察下方 <code>jit.pwindow</code> 的图像如何变化。注意 <code>router</code> 如何使剪切的矩阵，出现在底部合成图像的四个象限中。</p><h2 id="整合的胶水"><a href="#整合的胶水" class="headerlink" title="整合的胶水"></a>整合的胶水</h2><p>patch 底部的 <code>jit.glue</code> 做与 <code>jit.scissors</code> 相反的事情。行和列的属性指定入口数而不是出口数，以网格排列的输入矩阵合成一个矩阵输出。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13e.png" alt=""><br>将相同的矩阵发送到 <code>jit.glue</code> 的四个入口</p><blockquote><p>要点：与 <code>jit.scissors</code> 一样，<code>jit.glue</code> 只能在对象初始化时创建入口和出口，对象框中的行和列属性将确定入口数。此外，由 <code>jit.glue</code> 生成的输出矩阵的大小，等于所有小矩阵的大小（例如，四个 160x120 矩阵将合成一个 320x240 矩阵）。</p></blockquote><p><code>jit.glue</code> 默认当从左入口接收到新矩阵时，只输出复合矩阵。如果断开 <code>jit.glue</code> 最左边的入口，就不能再获得任何新的输出矩阵。syncinlet 属性可让 <code>jit.glue</code> 发送输出到不同的入口。syncinlet 值为 -1 时，<code>jit.glue</code> 在任一入口收到新矩阵时都输出新的合成矩阵。虽然看似不错，但会增加大量冗余工作，降低 Jitter 的帧处理速率。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.scissors</code> 对象切割矩阵成更小的、大小相等的矩阵。<code>jit.glue</code> 对象把相同大小的矩阵合并到一起生成复合矩阵。两个对象的行和列属性分别确定出/入口的数量，以及矩阵被切割或合成的方式，这在对象创建时就要给出。<code>router</code> 以任意方式连接多个入口处的消息到多个出口，跟 MSP <code>matrix~</code> 对象类似。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译14 - 颜色查找表</title>
    <link href="http://uegeek.com/180907-jitter-14.html"/>
    <id>http://uegeek.com/180907-jitter-14.html</id>
    <published>2018-09-07T11:57:41.000Z</published>
    <updated>2018-09-07T11:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-5.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter12" target="_blank" rel="noopener">Tutorial 12: Color Lookup Tables</a></p></blockquote><p>本教程将讲解如何使用颜色查找表（lookup tables）重新映射 Jitter 矩阵内的数据。<code>jit.charmap</code> 对象是为此而设计的。我们还将研究生成查找表矩阵的不同策略，包括 <code>jit.gradient</code> 对象。</p><h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p>查找表（通常称为传递函数/transfer functions）是一个数组，以数字为表的索引。检索存储在该索引（地址或位置）的数字来替换原数字。任何函数 graph - 每个 x 值（地址）有相应的 y 值（输出）- 都可以用作查找表。Max 对象如 <code>funbuff</code>，<code>table</code> 和 MSP <code>buffer~</code> 对象是常用的查找表。本教程将以类似的方式使用 Jitter 矩阵。</p><p>打开教程 patch 读取图像</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12a.png" alt="">            </p><p>patch 左上角有一个 <code>jit.movi​​e</code> 对象，读取两个文件。初始化对象（通过 loadbang）并加载文件 colorwheel.pct。也可以点击 <code>rain.mov</code> 消息加载视频。可以随意切换两个图像源。</p><p>单击 patch 顶部的开关启动 <code>metro</code>。色轮同时出现在顶部和底部的 <code>jit.pwindow</code>。底部第三个（矩形）<code>jit.pwindow</code> 中出现渐变。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12b.png" alt=""><br><code>jit.charmap</code> 的输出和查找表矩阵</p><p>patch 底部有一个<code>jit.charmap</code> 对象，用它来重新映射图像中的单元格值。对象有两个入口，左入口连接到顶部的 <code>jit.movi​​e</code>。右入口连接到 <code>jit.matrix colortable</code>。名为 colortable 的矩阵只有一维共 256 个单元，有四个 char 型数据平面。这是<code>jit.charmap</code> 用来重新映射左边矩阵中单元格的颜色查找表。带有名字 ctable 的<code>receive</code>（一般缩写为 <code>r</code>）对象从 patch 的其他位置接收数据并发送到 <code>jit.matrix</code>。打开顶部的开关发送一个 bang 到 <code>jit.matrix colortable</code>，它将矩阵消息发送到<code>jit.pwindow</code> 和 <code>jit.charmap</code>。</p><p><code>jit.charmap</code> 用输入（左）矩阵中的值，指向（右）矩阵中对应的位置并复制那里的值，生成输出矩阵。如果发送给<code>jit.charmap</code> 的矩阵包含一个在四个平面中值为 <code>100 50 35 20</code> 的单元格。如果查找表在平面 1 第 100 个单元格的值是 73，平面 2 第 50 个单元格的值是 25 ，平面 3 的第 35 个单元格的值是 0，平面 4 第 20 个单元格的值是 203，输出单元的值是 <code>73 25 0 203</code>。</p><p><code>jit.charmap</code> 查找表是有 256 个单元格的一维矩阵，其平面数量与要重新映射的矩阵相同。因为 char 矩阵的值范围是 0~255，因此需要 256 个数字来覆盖查找表。</p><h2 id="生成查找表"><a href="#生成查找表" class="headerlink" title="生成查找表"></a>生成查找表</h2><p>patch 的右上侧包含三个 <code>multislider</code>，可以设计 colortable 查找表矩阵 1-3 平面的传递函数：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12c.png" alt=""><br>用 multislider 的值填充查找表矩阵</p><p><code>multislider</code>（有 256个 整数 slider，范围为 0~255）把列表发送到下面的 <code>jit.fill</code>对象。它用 <code>multislider</code> 的值替换 colortable 矩阵当前存储在平面1-3（即红，绿和蓝）的值。当矩阵采用新值时，<code>jit.fill</code>发出 bang 到 patch 左边连接到 <code>jit.charmap</code> 右入口的 <code>jit.matrix</code>。这里忽略了平面 0，因为只有将 4 平面矩阵视为视频时，它才包含 Alpha 值。</p><p>patch 中的 <code>jit.matrix</code> 和 <code>jit.fill</code> 的名称相同（colortable）。这样两个对象从同一矩阵读取和写入，一个对象（<code>jit.fill</code>）生成另一个对象（<code>jit.matrix</code>）可读取的数据，而不必在两个矩阵之间复制数据。这跟许多 MSP 对象（例如 <code>peek~</code>，<code>play~</code>，<code>groove~</code>）可以共享存储在单个 <code>buffer~</code> 中的样本数据类似。关于命名矩阵请参见<a href="https://www.uegeek.com/180905-jitter-13.html" target="_blank" rel="noopener">教程 13</a>，18 和 19。</p><p>在 <code>multislider</code> 中随意绘制一些形状，看它如何影响查找表（较小的<code>jit.pwindow</code>）和 <code>jit.movi​​e</code> 的输出图像。可以来回切换两个图像源。</p><p>如果想重置任一平面为 <code>y = “x”</code> 传递函数（使所有值保持不变的固定斜率直线），可以单击相应 multislider 上的按钮。名为 <code>p clear</code> 的子 patch 用 <code>uzi</code> 初始化了 <code>multislider</code>。</p><blockquote><p>要点：与许多 Max 对象一样，Jitter 对象会保留存储在一个入口中的矩阵，即使另一个入口接收到了新矩阵。所以这个 patch 的 <code>metro</code> 只需要触发 <code>jit.movi​​e</code>。包含查找表<code>jit.charmap</code> 的<code>jit.matrix</code> 只需要在所存储的数据发生变化时输出值。</p></blockquote><p>以下是一些查找表及其结果：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12d.png" alt=""><br>三组 <code>multislider</code>及其生成的颜色查找表和输出颜色轮</p><p>例 1 中，红色和蓝色查找表调换而绿色正常。结果是输入图像中较大的红色和蓝色值在输出时变小，反之亦然。所以色轮的白色背景现在看起来是绿色的（单元格值 0 255 255 255 映射为 0 0 255 0）。</p><p>例 2 设置绿色平面为 0（查找表在整个输入值范围内设置为 0）。红色和蓝色平面如果超过阈值也设置为 0，这时值会突然上升（红色比蓝色上升得更明显）。结果是色轮大部分都是黑色的（特别是在绿色区域）。红色平面仅在非常高的值（即色轮背景中的品红色）中可见。</p><p>例 3 正常映射红色平面。绿色平面是抛物线形状，极值映射为高，中间阴影映射为低。蓝色平面除了中间调中被归零的范围，其余正常。这种非线性表现为贯穿彩色轮顶部和右侧的红色“断层线”。</p><p>有无数组合可以重新映射矩阵单元格的值。接下来研究另一个以更精确方式重新映射颜色值的对象。</p><h2 id="jit-gradient-对象"><a href="#jit-gradient-对象" class="headerlink" title="jit.gradient 对象"></a>jit.gradient 对象</h2><p>打开 Duotone 子 patch，它显示了使用 <code>jit.gradient</code> 生成查找表的方法：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12e.png" alt=""><br>使用 <code>jit.gradient</code> 对象</p><p><code>jit.gradient</code> 生成两个单元格的值之间平滑渐变的单维 char 矩阵。<code>start</code> 和 <code>stop</code> 属性是指定这些单元格的值列表。例如，start 属性 <code>0 0 0 0</code> 和 end 属性 <code>0 0.5 1.0 0.5</code> 将生成从黑色（矩阵中的单元格 0）到浅绿色（矩阵中最后一个单元格）的渐变。</p><p>我们已经用参数指定 <code>jit.gradient</code> 为 256 单元宽，这样当它改变时可以存储在 <code>jit.matrix colortable</code> 中。请注意， <code>jit.gradient</code> 在属性列表中使用浮点数来指定 char 值（即属性中用值 1.0 指定 char 值为 255）。</p><p>用 <code>swatch</code> 对象输出的 RGB 列表转换为 ARGB 浮点数来获得格式化属性。将属性发送到 <code>jit.gradient</code> 对象后，它接收触发对象发出的 bang，将矩阵输出到 patch 左侧的<code>jit.matrix</code>。</p><p>尝试在 <code>swatch</code> 中选择颜色。start 和 end 属性指定查找表的边界，所以输入图像的值表现为在两种颜色之间变化的双色调外观。patch 顶部的 <code>multislider</code> 将反映 <code>jit.gradient</code> 所生成的查找表。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12f.png" alt=""><br>使用颜色渐变作为查找表</p><p>例 1 是翻转的图像。查找表的 start 是白色（<code>start 0 1.0 1.0 1.0</code>），end 是黑色（<code>end 0. 0. 0. 0</code>）。结果是输入值 0 映射到 255，反之亦然（<code>y = 255 - x</code>）。</p><p>例 2 和 3 是双色调渐变，将色轮的光谱重新映射到红色和橙色（例 2）以及橄榄色和青色（例 3）之间。请注意，根据色轮中不同点的原始颜色，渐变曲线变得更陡峭或更和缓。</p><p><code>jit.gradient</code> 的另一个属性是 cheby，它指定在矩阵开始和结束值之间的变形曲线。cheby 属性的参数列表是浮点数。这些参数是 Chebyshev polynomials（见下文的切比雪夫多项式）不同阶数的振幅。使用查找表时，这些特殊功能曲线会产生不同的效果。patch 中设置 cheby 属性的 <code>multislider</code>，可以指定前 8 个 Chebyshev polynomials 曲线的相对振幅，形状如下（如果将它们视为从黑色到白色的过渡）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12g.png" alt=""><br>用 Chebyshev orders 1-4（顶行）和 5-8（底行）生成的梯度</p><blockquote><p>技术说明：切比雪夫多项式通常用作数字合成算法中波形整形音频信号的查找表（它们的特殊属性可以将正弦波形扭曲成等效于不同阶数幅度的谐波频谱）。MSP <code>lookup~</code> 对象可以与加载到 <code>buffer~</code> 中的函数一起来完成音频信号处理（跟本教程中的图像处理类似）。更多内容请参阅 MSP 手册中的教程 12：综合波形整形。</p></blockquote><p>复位 gradient 中开始和结束点（单击上面的消息框），缓慢调整 <code>multislider</code>控制的 cheby 属性。观察颜色轮在颜色消失并在不同区域重新出现时如何变化。</p><p>在 <code>jit.gradient</code> 中使用 cheby 属性时，即使将渐变起点和终点保留为黑色和白色，也可以得到一些非常有趣的颜色变形效果。以下是视频剪辑 rain.mov 的一些例子：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12h.png" alt=""><br>不同梯度曲线对雨水彩色频谱的影响</p><p>左边图像显示 rain.mov 中未处理的静止图像。中间图像显示了当使用二阶切比雪夫多项式（图像中最暗的区域现在位于色谱的中间）生成梯度时色谱的变化。右侧图像显示更复杂的梯度，色谱显示多个峰和谷。</p><p>patch 顶部的 <code>multislider</code>反映查找表的当前状态（由 <code>jit.gradient</code> 生成的矩阵被发送到 <code>p showit</code> 子 patch 中的 <code>jit.iter</code>，在那里数字被组合以设定 <code>multislider</code> 的状态）。尝试生成渐变，然后调整 multislider 手动修改查找表。这样 <code>jit.gradient</code> 就作为更复杂的查找表的起始点。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/jitterchapter12i.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用 <code>jit.charmap</code> 映射 char 矩阵中单元格的值。<code>jit.charmap</code> 的右入口接收 256 单元矩阵来定义要用于输入矩阵数据的查找表（或传递函数）。可以使用多种方法定义查找表，包括<strong>使用 <code>jit.fill</code>从 Max 列表生成矩阵，或使用 <code>jit.gradient</code> 对象根据 cheby 指定的曲线形状，在开始和结束单元格值之间生成颜色渐变属性。</strong></p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译13 - 列表和矩阵</title>
    <link href="http://uegeek.com/180906-jitter-13.html"/>
    <id>http://uegeek.com/180906-jitter-13.html</id>
    <published>2018-09-06T10:54:22.000Z</published>
    <updated>2018-09-06T10:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-4.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter11" target="_blank" rel="noopener">Tutorial 11: Lists and Matrices</a></p></blockquote><p>本教程讲解如何用 Max 列表和 <code>jit.fill</code> 对象来填充（部分）矩阵，以及如何用 <code>jit.spill</code> 检索（部分）矩阵内容作为列表。还将演示通过矩阵名称远程访问矩阵内容。</p><h2 id="矩阵名称"><a href="#矩阵名称" class="headerlink" title="矩阵名称"></a>矩阵名称</h2><p>patch 左侧有一个蓝色的 <code>jit.matrix</code>。第一个参数是矩阵的名称 smallbox。其他参数表示矩阵有 1 个 char 平面，包含一维 12 个单元格。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11a.png" alt=""><br>矩阵唯一名称：smallbox</p><p><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 介绍过，每个矩阵都有一个名称。如果没有另外指定，Jitter 将自动命名（类似 “u040000114” 奇怪的唯一名称）。名称表示存储矩阵的内存位置。为什么要另外给矩阵命名呢？这样可以告诉其他对象如何找到矩阵的内容。引用矩阵的名称，对象之间可以共享数据，无需接收 jit_matrix 消息就可以远程访问矩阵的内容。</p><blockquote><p>Jitter 使用矩阵名称来指代内存位置，这跟 Max 的 <code>value</code> 对象类似。名称相同的对象可以有多个，只在其中一个中存储数值，其他对象就可以检索这个值。该名称实际上只有一个内存位置，它们共享相同的数据。同样，可以有多个名称相同的 <code>jit.matrix</code> 对象，它们共享相同的数据。其他对象（例如 <code>jit.fill</code>）只需知道名称即可访问矩阵内容。</p></blockquote><h2 id="jit-fill"><a href="#jit-fill" class="headerlink" title="jit.fill"></a>jit.fill</h2><p><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 展示了在矩阵特定位置指定数值的 <code>setcell</code>消息，以及检索位置内容的 <code>getcell</code> 消息。现在来看看如何使用 <code>jit.fill</code> 对象将一个值列表存入矩阵中。（本章后面还将展示如何从矩阵中一次检索多个值）</p><p>在 patch 的左上角有一个包含  12 个数值列表的消息框。它连接到 <code>jit.fill smallbox</code> 对象。矩阵名字是 smallBox。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11b.png" alt=""><br> <code>jit.fill</code> 在命名矩阵中存储一个值列表</p><p>单击消息框将列表发送到 <code>jit.fill smallbox</code>。对象在名为 “smallBox” 的矩阵存储这些值。单击 <code>jit.matrix smallbox</code> 上方的按钮显示 smallbox 矩阵的内容来验证。这些值由 <code>jit.print</code> 打印在 Max Console 中，并在狭长的 <code>jit.pwindow</code> 中显示为灰阶。</p><p>这个例子的列表长度恰好可以填充整个矩阵。这不是必须的。可以在 1D 或 2D 矩阵的任意连续部分中放置任何长度的列表。</p><h2 id="偏移属性"><a href="#偏移属性" class="headerlink" title="偏移属性"></a>偏移属性</h2><p>双击打开 <code>random_lists</code> 子 patch。</p><p>默认情况下，<code>jit.fill</code> 将值列表放在矩阵最开头。也可以设置 <code>jit.fill</code> 的 <code>offset</code> 属性将列表指定到矩阵中的任何位置。这里演示如何使用 offset。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11c.png" alt=""><br>首先指定偏移量，后跟列表</p><p>上面的例子随机选择单元格索引作为 <code>jit.fill</code> offset 消息的参数，然后向 randbox 矩阵中的该索引处，发送要存储的 16 个元素的列表。</p><p>点击开关启动 <code>metro</code>。每隔半秒，16 个元素的列表被写入 randbox 矩阵中的新位置。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11d.png" alt=""></p><p>用 <code>clear</code> 消息清除 randbox 矩阵的内容，然后观察 <code>metro</code> 将列表写入新的随机位置。<code>metro</code> 也正在触发 <code>jit.matrix randbox</code> 将其内容发送到 <code>jit.pwindow</code> 显示。</p><h2 id="使用-multislider"><a href="#使用-multislider" class="headerlink" title="使用 multislider"></a>使用 multislider</h2><p>打开 draw_list 子 patch。</p><p>现在我们知道如何将预先定义的值列表存到矩阵中。如果要在 Max 中交互式生成列表并实时放置在矩阵中，需要用构建列表的对象比如  <code>multislider</code> 和 <code>zl</code>。</p><p><code>multislider</code> 对象包含一组 <code>slider</code>，并一次发送所有 slider 的值作为列表（slider 可以小到一个像素宽，这样它看起来更像一个图形而不是一组单独的控件）。在窗口中移动任何 slider 时会发送整个列表，释放鼠标按钮时再次发送列表。在 draw_list 子 patch，有一个包含 256 个滑块的 <code>multislider</code>，可发送从 0~255 的值，它恰好将 256 个 char 值发送给 <code>jit.fill graybox</code>  对象。</p><p>拖动鼠标在 <code>multislider</code> 中设置 256 个滑块。释放鼠标按钮时，256 个值的列表将发送到 <code>jit.fill graybox</code>。注意矩阵单元的亮度如何与滑块的高度相对应。</p><p>一旦 <code>jit.fill</code> 在入口处收到列表，就会写入指定的矩阵（offset 属性指定的）位置。完成时 <code>jit.fill</code> 会发出 bang。可以用它来触发另一个动作，例如显示矩阵。</p><blockquote><p>前两个例子故意不使用 <code>jit.fill</code>左侧出口的 bang，以便清楚看到，<code>jit.fill</code> 远程写入到指定命名的矩阵，而不是通过物理连接。当然 <code>jit.fill</code> 左侧出口的 bang 很方便，只要填充完就会触发矩阵的输出。</p></blockquote><h2 id="使用-zl"><a href="#使用-zl" class="headerlink" title="使用 zl"></a>使用 zl</h2><p>打开 collect_values 子 patch</p><p>某些情况下你可能想用矩阵来存储 patch 某处的数字消息：MIDI消息、来自 UI 对象的数字等。可以向 <code>jit.matrix</code> 发送 <code>setcell</code> 和 <code>getcell</code> 消息，也可以将消息收集到列表中，然后用 <code>jit.fill</code> 将它们一次性存到矩阵中。</p><p><code>zl</code> 是多功能的列表处理对象，由第一个参数指定模式和行为。当第一个参数是 group 时，它会收集左入口的消息直到一定数量，然后将这些数字作为单个列表发送出去（这些值按接收顺序分组）。在 collect_values 子 patch 中有一个 <code>zl group 256</code> 对象，每当它从左入口收集够 256 个值，就把这个列表发送到左出口（并清除内存）。</p><p>向上和向下移动 slider 为 <code>zl</code> 对象生成 256 个输入值。当 <code>zl</code> 收到 256 个数字时，它把这个列表发送到 <code>jit.fill midibox</code>，由它写入 midibox 矩阵，然后 bang <code>jit.matrix midibox 1 char 256</code> 对象以显示矩阵。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11e.png" alt=""><br><code>zl</code> 将包含 256 个元素的列表发送到 midibox 矩阵，然后 bang <code>jit.matrix</code> 来显示结果</p><p>如果电脑连接了 MIDI 键盘，可以使用 MIDI 键盘的 modulation wheel 移动 slider。（MIDI 和 Jitter 的交互将在后面的教程中详细探讨）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11f.png" alt=""><br>值*2 获得 0~254 范围</p><p>可以用<code>list length</code>数字框向右入口发送新的值来更改 <code>zl</code>数据集的列表长度。用 <code>loacation</code> 数字框发送 <code>offset</code> 消息给 <code>jit.fill</code> 告诉它想要存储列表的位置。改变列表长度和位置，可以将任意数量的值放入矩阵的任何连续区域。</p><p>更改 <code>zl</code> 的 list length （如 100），设置 <code>jit.fill</code> 的 offset 属性（如 50），然后移动 slider 把值的列表存到矩阵中的指定位置。</p><h2 id="jit-fill-和多平面矩阵"><a href="#jit-fill-和多平面矩阵" class="headerlink" title="jit.fill 和多平面矩阵"></a>jit.fill 和多平面矩阵</h2><p>打开 <code>fill_separate_panes</code> 子 patch</p><p><code>jit.fill</code> 可用于多平面矩阵，但它一次只能填充一个平面。<code>jit.fill</code> 要处理哪个平面由 <code>@plane</code> 属性指定。在<code>fill_separate_panes</code> 子 patch 中创建了另一个名为 colorbox 的矩阵，这次有四个char 数据平面。设置了三个 <code>multislider</code> 和三个 <code>jit.fill</code> 对象，每个对象都对应 colorbox 框矩阵的不同颜色平面。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11g.png" alt=""><br>各自填充每个平面</p><p>拖动三个彩色 <code>multislider</code> 填充三个颜色平面。</p><p>这样可以快捷生成矩阵中 RGB 平面不同强度的曲线。显示矩阵的 <code>jit.pwindow</code> 宽为 256 像素，所以矩阵 64 个单元格都显示为 4 像素宽的条带。如果打开 <code>jit.pwindow</code> 的 <code>interp</code> 属性，相邻频段之间的差值会被插值平滑。</p><p>单击 <code>interp $1</code> 消息框上方的开关，将消息发送到 <code>jit.pwindow</code>。（注意，这也会发送 bang 到 <code>jit.matrix</code> 重新显示内容）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11h.png" alt=""><br>与前一个示例相同，但打开了 <code>jit.pwindow</code> 的插值</p><h2 id="jit-fill-和二维矩阵"><a href="#jit-fill-和二维矩阵" class="headerlink" title="jit.fill 和二维矩阵"></a>jit.fill 和二维矩阵</h2><p>目前为止所有的例子都是一维矩阵。用列表（一维数组）通过 <code>jit.fill</code> 填充二维矩阵时会发生什么？<code>jit.fill</code> 对象在第一个维度里尽可能排列列表（尽量排满指定的行）然后绕到下一行继续排列。下面演示排列的过程。</p><p>单击标有 2D 的按钮，把 <code>jit.matrix colorbox</code> 对象变成 8x8 二维矩阵，<code>jit.pwindow</code> 也会调整为更合适的形状。无论何时更改矩阵尺寸，它都会清除之前的数据，所以需要再次单击三个 multislider 重新填充矩阵。仍向每个 <code>jit.fill</code> 对象发送 64 个元素的列表，并用 8 个元素填充矩阵的 8 行。</p><blockquote><p>要点：这里没有演示如何使用带有 offset 属性的 2D 矩阵，当 <code>jit.fill</code> 的 name 属性命名 2D 矩阵时，offset 属性需要两个参数： x 偏移量和 y 偏移量。</p><p><code>jit.fill</code>  仅适用于 1D 和 2D 矩阵。</p></blockquote><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11i.png" alt=""><br>相同的例子，列表填充 8x8 矩阵（未插值）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11j.png" alt=""><br>开启插值</p><h2 id="jit-spill"><a href="#jit-spill" class="headerlink" title="jit.spill"></a>jit.spill</h2><p><code>jit.spill</code> 是 <code>jit.fill</code> 的补充。它在入口处接收 <code>jit_matrix</code> 消息，将矩阵值作为列表发送到左出口。当使用红色 <code>multislider</code> ，下面的 <code>jit.spill</code> 发送平面 1（红色）的值到左出口并在消息框显示内容。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11k.png" alt=""><br>用列表显示 colorbox 矩阵的平面 1 的内容</p><blockquote><p><code>jit.spill</code> 也有 list length 和 offset 属性</p></blockquote><p>如果需要发送一系列单个数字消息而不是单个列表消息，<code>iter</code> 对象了解一下。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11l.png" alt=""><br>从矩阵中获取一些值并分成不同的消息</p><h2 id="jit-iter"><a href="#jit-iter" class="headerlink" title="jit.iter"></a>jit.iter</h2><p>打开 individual_values 子 patch。</p><p><code>jit.iter</code> 对象可以检索矩阵中的每个值。当它收到 <code>jit_matrix</code> 消息时，会按矩阵中单元格的顺序发出消息序列：单元格索引（中间出口），然后是该单元格的值（左出口）。如果是一个大矩阵，会有一大堆消息试图在（Max’s scheduler）单个 tick 中发送出去，所以当它完成所有发送后，<code>jit.iter</code> 会向右出口发送一条完成的消息。</p><p>在 individual_values 子 patch 中有一个 <code>jit.iter</code> 对象，它接收来自 <code>jit.matrix readbox 1 char 256</code> 的矩阵信息。我们使用 <code>swap</code> 对象切换单元格索引的顺序（来自 <code>jit.iter</code> 中间出口）和单元格值（来自 <code>jit.iter</code> 左出口）。然后用该单元格的值作为想要存储在表对象中的 y 值，用单元格索引作为 x 轴索引。</p><p>点击 <code>multislider</code> 发送内容给 <code>jit.fill</code>（然后 bang  <code>jit.matrix</code> 并传达其内容给 <code>jit.iter</code>）。双击 <code>tabel</code> 对象打开图形窗口，看到它包含与 readbox 矩阵相同的值。</p><p>请注意，使用 <code>jit.iter</code> 填充表格的技巧适用于中等大小的一维单平面矩阵，因为表格是一维数组。但是像<code>jit.movi​​e</code> 对象的 2D 矩阵有四个平面，<code>jit.iter</code> 的中间（单元索引）出口输出双元素列表，左出口的值列表是四元素列表。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11m.png" alt="">            </p><p>对于一维或小的 2D 矩阵，或者在较大矩阵中搜索特定值或模式， 用 <code>jit.iter</code> 扫描整个矩阵是很方便的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>发送 <code>setcell</code> 和 <code>getcell</code> 消息给 <code>jit.matrix</code>，可以<strong>存储或检索矩阵中的单个值</strong>（如<a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 所示）。<strong>如果要存储或检索列表，就要用 <code>jit.fill</code> 和 <code>jit.spill</code>。</strong>它们可以检索 1D 或 2D 矩阵的任何平面，在任意起始单元位置存储任何长度的列表。</p><p><code>multislider</code> 和 <code>zl</code> 对象用于实时生成列表消息。用鼠标拖动 <code>multislider</code> 可以绘制列表。使用 <code>zl group</code> 收集多个单独的数值到一个列表中，然后一次性发送到 <code>jit.fill</code>。</p><p>可以设置 <code>jit.fill</code>（或 <code>jit.spill</code>）的 offset 属性来指定矩阵中的起始单元格位置。<code>jit.fill</code> 对象要设置名称属性（或者发送<code>name</code> 消息或输入[name]参数），指定它将填补的矩阵名称。它用这个名称访问矩阵，并且在列表写入矩阵完成时发出 bang。可以用它来触发其他操作。</p><p>发送矩阵给 <code>jit.iter</code>，可以输出整个矩阵中所有值。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="列表" scheme="http://uegeek.com/tags/%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译12 - Chromakeying 视频去背景合成</title>
    <link href="http://uegeek.com/180904-jitter-12.html"/>
    <id>http://uegeek.com/180904-jitter-12.html</id>
    <published>2018-09-04T11:16:04.000Z</published>
    <updated>2018-09-06T10:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-3.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter10" target="_blank" rel="noopener">Tutorial 10: Chromakeying</a></p></blockquote><p>本教程介绍如何使用 <code>jit.chromakey</code> 对两个源视频Chromakeying（去背景合成，chroma-纯色，key-抽离颜色）。还将学习如何使用 <code>suckah</code> 对象获取屏幕上任意像素的颜色。</p><p>打开教程 patch，由 <code>loadbang</code> 发送 <code>read</code> 消息到两个 <code>jit.movi​​e</code> 对象，自动读取两个视频（oh.mov 和 traffic.mov）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10a.png" alt=""><br>通过 <code>loadbang</code> 初始化 patch</p><p>其他参数也由连接到右侧消息框的 <code>loadbang</code> 初始化。消息框发送消息到 patch 中其他名为 <code>receive</code> 的对象完成初始化。（参见<a href="https://docs.cycling74.com/max7/tutorials/basicchapter16" target="_blank" rel="noopener">教程 18：Remote Messaging</a>）。</p><p>点击开关启动 <code>metro</code>。三个 <code>jit.pwindow</code> 对象中出现了图像。开关不仅可以启动和停止 <code>metro</code>，还可以启动和停止两个 <code>jit.movi​​e</code> 视频播放。</p><p>教程 patch 的下半部分（三个 <code>jit.pwindow</code> 中的两个）是这样的：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10b.png" alt=""><br><code>jit.chromakey</code> 对象</p><p>点击左侧 <code>jit.pwindow</code> 对象的蓝色区域（即视频中男性头部后面的区域）。</p><p>第三个 <code>jit.pwindow</code>（在 patch 右下角）将显示：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10c.png" alt="">            </p><blockquote><p>历史说明：蓝屏合成（在蓝色哑光背景下拍摄现场镜头的过程）在 20 世纪 30 年代就出现了，目的是为了后期用其他图像替换蓝色。蓝屏合成涉及平版印刷分色，起初是非常昂贵的电影工艺，它（现在更常见的是绿屏合成）已经演变成影视制作中最常见的特效。通过数字叠加完成 Chromakeying（蓝屏处理的术语）让它更普及。Chromakeying 在电视行业中常被称为 CSO（色彩分离叠加），由 1960 年代开发它的 BBC 团队命名。蓝屏发明者 Petro Vlahos 在 1994 年被授予了电影艺术与科学学院终身成就奖，以表彰这项无可替代的技术。</p></blockquote><h2 id="jit-chromakey-对象"><a href="#jit-chromakey-对象" class="headerlink" title="jit.chromakey 对象"></a>jit.chromakey 对象</h2><p>去背景合成 - 将一个图像叠加在另一个上面，选择性替换颜色的过程 - 由 <code>jit.chromakey</code> 对象实现。<strong>通过指定颜色和其他参数， <code>jit.chromakey</code> 在第一个（左侧）矩阵中检测包含该颜色的单元，并在生成输出矩阵时，用第二个（右侧）矩阵中的对应单元替换它们。</strong>这样，来自第一个矩阵的单元叠加到第二个矩阵上。</p><p>可以选择任何颜色为要去除的背景，请尝试点击左侧 <code>jit.pwindow</code> 中的其他区域。不同的颜色会从男人的脸上移除，而显示出第二个视频中的图像。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10d.png" alt=""><br>消失的面孔（第一部分）</p><p><code>jit.chromakey</code> 用 <code>color</code> 属性（称为参考颜色）来定义中心色。这个属性是一个值列表，应用于等待抠图的矩阵中的所有平面。<code>tol</code> 属性定义中心色的<strong>容差范围</strong>。此范围内的颜色也会被去除。</p><p>将 <code>jit.chromakey</code> 与 char 矩阵一起使用时，属性值的范围在 0.0~1.0，然后映射到 char 数据所需的 0~255。所以可以将属性设置为 <code>color 0 0 1.0 0</code>，而不是 <code>0 0 255 0</code>。<code>tol</code> 为 0.5 时会去除距离参考色一半色阶的所有颜色（key all values within half of the chromatic distance from the reference color）。<code>tol</code> 为 0 时只会用精确的参考色来完成抠图。</p><p>再次点击左侧视频中的蓝色区域，然后调整 <code>tol</code> 属性查看输出的变化。在低容差时，左图中的一些蓝屏将保留。容差值非常高时，男人脸部的部分可能会消失。</p><p>在教程 patch 中，我们通过点击不可见的对象来设置 <code>jit.chromakey</code> 的颜色属性。解锁 patch，会看到左侧 <code>jit.pwindow</code> 上面的同心红色方块区域：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10e.png" alt=""><br><code>suckah</code> 对象</p><p>该区域是名为 <code>suckah</code> 的 Max UI 对象，可以在 interface 工具栏找到它：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10f.png" alt=""><br>对象面板中的 suckah 对象</p><p><code>suckah</code> 对象获取它所覆盖的屏幕像素的 RGB 值。当单击对象时（patch 处于锁定状态），它会获取 0.0~1.0 范围内的浮点数值。例如，单击视频中的纯蓝色区域，<code>suckah</code> 会发送 <code>0 0 1.0</code> 列表（suckah 的初始版本使用 0~255 范围。如果需要，可以在 inspector 中选择这个设置）</p><p><code>suckah</code> 对象获取 RGB 颜色列表后，用 <code>prepend 0</code> 在前面加上 0（增加 alpha 值到列表最前面）来设置 <code>jit.chromakey</code> 的颜色属性。然后再 <code>prepend color</code> 并发送给 <code>jit.chromakey</code>。</p><h2 id="Chromakey-选项"><a href="#Chromakey-选项" class="headerlink" title="Chromakey 选项"></a>Chromakey 选项</h2><p><code>jit.chromakey</code> 对象有附加属性：minkey，maxkey 和 fade。当矩阵从左入口进入，<code>jit.chromakey</code> 基于该矩阵在内部创建一个灰度（单平面）遮罩。输入矩阵中，在容差（tol）范围内颜色值的单元格，将设置为遮罩中的 maxkey 属性值（默认为 1）。容差范围之外的区域乘以 minkey 属性（默认为 0）。如果 minkey 和 maxkey 为 0 和 1，生成的图像在去背景的位置应该看起来是白色，而在要保留原始图像的位置看起来是黑色。</p><p>将得到的遮罩及其负片，分别乘以右矩阵和左矩阵。然后添加乘法的结果以形成合成图像。下图说明了这个过程：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10g.png" alt=""><br>遮罩（minkey 为 0，maxkey 为 1）和合成效果</p><p>maxkey 属性设置右边输出矩阵的强度，minkey 属性设置左边矩阵的强度。如果要反转 minkey 和 maxkey 属性，chromakey 将被反转：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10h.png" alt=""><br>minkey 为 1，maxkey 为 0（反向色度键）的合成效果</p><p>fade 属性在被去除和保留的区域之间生成插值，可以生成柔化边缘。左边矩阵中的颜色略微超出了容差范围，但是在参考颜色的 tol + fade 的范围内，在原始颜色和右侧矩阵对应单元格中的颜色之间插值。插值取决于 fade 值的大小，以及颜色距离容差边界有多远。</p><p>尝试不同的 tol，fade，minkey，maxkey 和 color 值。观察五个属性如何影响不同的抠图效果，以及 minkey 和 maxkey 值如何相互补充。</p><p>完全去除背景很困难。选取合适的 tol 和 fade 属性值，才能确保第一个图像中的区域对第二个图像起作用。包含很多细节的图像，通常会在抠图和保留区域之间颜色变化的区域，出现轻微的斑点。此外，单一颜色（例如蓝色）基本上满足不了去背景的需要，必须使用一系列值。但是你会发现，希望去除的颜色会出现在想要保留的区域中！平衡所有因素以获得满意的效果，是使用 <code>jit.chromakey</code> 对象最困难的部分。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.chromakey</code> 对象实现两个 Jitter 对象的 chromakeying。可以使用 color 和 tol 属性设置抠图的颜色范围，并用 fade，minkey 和 maxkey 值来定义两个矩阵在合成时的工作方式。<code>suckah</code> 对象放置在 <code>jit.pwindow</code> 上方，点击即可以获取所在位置的颜色。</p><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Chromakeying" scheme="http://uegeek.com/tags/Chromakeying/"/>
    
      <category term="抠图" scheme="http://uegeek.com/tags/%E6%8A%A0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译11 - 矩阵混合</title>
    <link href="http://uegeek.com/180903-jitter-11.html"/>
    <id>http://uegeek.com/180903-jitter-11.html</id>
    <published>2018-09-03T10:23:32.000Z</published>
    <updated>2018-09-04T10:27:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-2.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter09" target="_blank" rel="noopener">Tutorial 9: More Mixing</a></p></blockquote><p>本教程探讨用 <code>jit.scalebias</code> 和 <code>jit.op</code> 实现交叉渐变的技巧。它比 <code>jit.xfade</code> 方法复杂一些，但更灵活。</p><h2 id="混合和交叉淡化"><a href="#混合和交叉淡化" class="headerlink" title="混合和交叉淡化"></a>混合和交叉淡化</h2><p><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">上一章</a>讲解了 <code>jit.xfade</code> 用缩放（乘法）和加法以不同的比例混合两个矩阵。本教程将使用 <code>jit.scalebias</code> 和 <code>jit.op</code> 对象来自动执行这些数学运算。</p><p>这样做有一些好处。首先能清楚地演示混合和交叉渐变的数学过程。其次能看到 <code>jit.op</code> 如何对两个输入矩阵做数学运算。（在<a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">教程 5 </a>中展示了 <code>jit.op</code> 和标量值如何作用于单个矩阵）。第三，它可以分别指定两个矩阵的缩放因子，比 <code>jit.xfade</code> 更灵活。最后，<code>jit.op</code> 可以实现许多不同类型的数学运算，我们可以尝试其他组合矩阵的方法来得到不同的视觉效果。</p><h2 id="再说-Mixing"><a href="#再说-Mixing" class="headerlink" title="再说 Mixing"></a>再说 Mixing</h2><p>打开教程 patch</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter09a.png" alt=""><br>用乘法和加法混合/交叉渐变矩阵</p><p>缩放因子设置为 0~1 之间的 <code>jit.scalebias</code> 将两个视频 scaled down（变暗）。下面会看到用 <code>jit.op</code> 的不同：两个入口的输入都是矩阵。这时 <code>jit.op</code> 分别对每个值执行指定的数学运算，<strong>将左矩阵中的每个值与右矩阵中的对应值配对</strong>。这样我们可以把两个矩阵的所有值相加来混合图像。</p><p>这些乘法和加法的结果与 <code>jit.xfade</code> 对象做内部运算的结果一样。可以试试用 patch 右上角的控件来交叉渐变视频（与上一章几乎完全相同）。</p><p>启动 <code>metro</code> 并使用 <code>Mixer slider</code> 执行从视频 A 到 B 的交叉渐变。</p><p>请注意，渐变值直接作为视频 B 的缩放因子，同时 <code>!- 1</code> 对象用 1 减去该值，得到视频 A 的缩放因子。这样，两个缩放因子的和总是等于 1，就像在 <code>jit.xfade</code> 中一样。</p><h2 id="使用其他运算符组合矩阵"><a href="#使用其他运算符组合矩阵" class="headerlink" title="使用其他运算符组合矩阵"></a>使用其他运算符组合矩阵</h2><p>加法是两个矩阵最常见的运算。更改 <code>jit.op</code> 的 op 属性，可以尝试许多其他运算并查看其视觉效果。</p><p>在 <code>Transition Time</code> 数字框中设置一个非常长的交叉渐变时间（例如 10000 ms）。在 <code>Operator</code> 弹出菜单中选择 + 以外的运算符。现在点击 <code>Go To switch</code> 开始渐变，可以看到两个视频矩阵的运算如何进行。</p><p>弹出菜单包含 <code>jit.op</code> 各种运算符中的一部分。以下是菜单中选项的简要说明。</p><ul><li><code>+</code> 把 B 值加到 A</li><li><code>-m</code> 从 A 中减去 B，然后取模将结果折算回所需的数值范围</li><li><code>max</code> 使用 A B 中较大的值</li><li><code>absdiff</code>从 A 中减去 B，然后取差值的绝对值</li><li><code>|</code> “按位或”; 二进制操作，A 或 B 为 1，结果为 1</li><li><code>^</code> “按位独占或”; 二进制操作，A 和 B 值不相同，结果为 1，否则为 0</li><li><code>&gt;</code> 如果 A 大于 B，结果为 1（或 char 255），否则为 0</li><li><code>&lt;</code> 如果 A 小于 B，结果为 1（或 char 255），否则为 0</li><li><code>&gt;p</code> 如果 A 大于 B，结果为 A，否则为 0</li><li><code>&lt;p</code> 如果 A 小于 B，结果为 A，否则为 0</li></ul><p>其他运算符请查看 <code>jit.op</code> 对象参考文档。</p><p>你也可以直接拖动 <code>jit.scalebias</code> 上方的数字框，单独设置混合比例。还可以尝试超过 0~1 范围的值。</p><h2 id="jit-scalebias-vs-jit-op-op"><a href="#jit-scalebias-vs-jit-op-op" class="headerlink" title="jit.scalebias vs. jit.op @op *"></a>jit.scalebias vs. jit.op @op *</h2><p>这个 patch 用 <code>jit.scalebias</code> 来做缩放乘法，而没有用 <code>jit.op</code> 与 * 运算符。为什么呢？</p><p>当 <code>jit.op</code> 操作 char 数据时，val 属性范围是 0.0~1.0（浮点数）或 0~255（整数）。如果想将 char 数据乘以 0~1 的某个值，用 <code>jit.op</code> 就可以。如果想乘以其他范围的值，就要用 <code>jit.scalebias</code>，它允许 scale 的值超过 0~1 范围。 <code>jit.scalebias</code> 仅用于处理 4 平面 char 矩阵，在这个例子中没问题。所以在这个 patch 中，因为是在 4 平面 char 矩阵上做运算，并且想使用超过 0~1 范围的缩放因子，所以使用了 <code>jit.scalebias</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你可以用 <code>jit.op</code> 对两个不同矩阵中的值执行各种数学运算。 <strong><code>jit.op</code> 对每个值执行指定的数学运算，将左矩阵中的每个值与右矩阵中的对应值配对。当两个矩阵的 dim，planecount 和 type 属性不同时，<code>jit.op</code> 使用左入口矩阵的属性</strong>。在混合两个视频图像时，不同的数学运算符可以生成各种视觉效果。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Math" scheme="http://uegeek.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译10 - 交叉渐变</title>
    <link href="http://uegeek.com/180902-jitter-10.html"/>
    <id>http://uegeek.com/180902-jitter-10.html</id>
    <published>2018-09-02T10:29:21.000Z</published>
    <updated>2018-09-02T10:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-1.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter08" target="_blank" rel="noopener">Tutorial 8: Simple Mixing</a></p></blockquote><p>本教程介绍如何使用 <code>jit.xfade</code> 对象混合和淡入淡出两个图像。</p><h2 id="混合两个视频源"><a href="#混合两个视频源" class="headerlink" title="混合两个视频源"></a>混合两个视频源</h2><p>混合两个图像是视频处理中最常见和最有用的技巧之一。</p><p>最简单的视频混合是将两个图像叠加起来，可以调整任一图像的强度。逐渐淡出一个图像，同时淡入另一个图像，可以创建图像之间的平滑过渡淡入淡出效果。</p><p>Jitter 处理混合和过渡渐变的对象是 <code>jit.xfade</code>。</p><blockquote><p>技术细节：这种类型的混合，将一个矩阵中的每个值，加到另一个矩阵各单元和各平面的相应值上，并输出所有总和的矩阵。但这样让输出图像的值都大于任何一个输入图像，会比原始图像更亮（如果矩阵包含 char 数据，某些值甚至会在 255 处裁剪）。所以在它们相加之前应该减小一个或两个图像的强度。例如，为了按相同比例混合两个图像，在相加之前将它们缩小相等的量（例如，0.5 倍）。</p></blockquote><h2 id="jit-xfade"><a href="#jit-xfade" class="headerlink" title="jit.xfade"></a>jit.xfade</h2><p><strong><code>jit.xfade</code> 对象接收两个输入口的矩阵，缩放两个矩阵中的值，然后把两个矩阵相加并输出混合后的矩阵</strong>。两个输入矩阵缩放因子由 xfade 属性决定。xfade 是 1~0 之间单个（浮点） 数值，是右输入口矩阵的缩放因子。左输入口的矩阵按 1-xfade 的比例缩放。如果逐渐将 xfade 值从 0 增加到 1，输出矩阵将从左输入到右输入淡入淡出。</p><p>打开教程 patch。<code>loadbang</code> 对象自动读取两个源视频。开启<code>metro</code>。开始只会看到左侧视频。拖动滑块更改 xfade 值来控制左右矩阵的混合。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter08a.png" alt=""><br>值为 0.5 时左右矩阵以相同比例混合</p><h2 id="自动交叉渐变"><a href="#自动交叉渐变" class="headerlink" title="自动交叉渐变"></a>自动交叉渐变</h2><p>交叉渐变是最常见的图像转换方式之一。它可以非常缓慢 - 持续几秒 - 或者非常快速，只持续几分之一秒，只比突然跳帧略微平滑。</p><p>在 patch 左上角，有一个从视频 A 到 B （B 到 A）的自动渐变控制器。交叉渐变可以持续用数字框指定的任意过渡时间。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter08b.png" alt=""><br>自动发送不断变化的 xfade 值</p><p>用数字框设置一个比较长的渐变时间（例如 5000 ms），可以看到交叉渐变器的效果。单击 Go To 右侧的开关淡入视频 B。</p><p>Go To 开关实际上是一个范围为 2 的 <code>slider</code>和一个 <code>* 100</code>乘法器，所以只会发送 0 和 100 两个值。单击开关右侧发出值 100，<code>pack</code> 发出消息 <code>100 5000</code>，<code>line</code> 对象在五秒内发出 0~100 的连续值（每 50 毫秒一个新值）。然后将这些值乘以 0.01，得到平滑变化的从 0~1 的 xfade 值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>叠加两个矩阵是最简单的混合视频图像的方法。想要控制两个图像的混合比例，首先要按某个因子缩放每个矩阵。想从一个图像渐变到另一个图像，将一个图像的缩放因子从 1 减小到 0，另一个从 0 增加到 1。</p><p><code>jit.xfade</code> 对象专门混合和/或交叉渐变两个矩阵。xfade 属性指定两个矩阵之间的混合比例。<strong>将 xfade 值从 0 连续增大到 1 可实现平滑的交叉渐变。</strong>可以使用 <code>line</code> 或其他 Max 计时对象来自动化交叉渐变。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译09 - 调整图像颜色</title>
    <link href="http://uegeek.com/180901-jitter-09.html"/>
    <id>http://uegeek.com/180901-jitter-09.html</id>
    <published>2018-09-01T10:28:20.000Z</published>
    <updated>2018-09-01T10:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-9.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter07" target="_blank" rel="noopener">Tutorial 7: Image Level Adjustment</a></p></blockquote><p>本教程介绍如何调整 Jitter 矩阵中图像数据的亮度、对比度和饱和度，以及色调和色调旋转(hue rotation)的概念。</p><p>教程 patch 中有两个新对象：<code>jit.brcosa</code> ，控制矩阵中图像数据的亮度（brightness）、对比度（contrast）和饱和度（saturation），以及 <code>jit.hue</code>，旋转图像的色调。</p><h2 id="亮度，对比度和饱和度"><a href="#亮度，对比度和饱和度" class="headerlink" title="亮度，对比度和饱和度"></a>亮度，对比度和饱和度</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07a.png" alt=""><br>打开并查看图像</p><p>点击 <code>read colorwheel.pct</code> 消息框打开文件 colorwheel.pct。点击开关启动 <code>metro</code> 开始显示视频。</p><p>patch 底部 <code>jit.pwindow</code> 中会出现一个色轮：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07b.png" alt="">            </p><p><code>jit.pwindow</code> 展示了穿越过两个对象的图像。我们先谈谈 <code>jit.brcosa</code>，然后再到 <code>jit.hue</code>。</p><p><code>jit.brcosa</code> 对象将 4 平面 char 矩阵看作 ARGB 图像数据，可以调整矩阵数据的亮度、对比度、饱和度。三个属性的默认值是 1.0，这样矩阵保持不变：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07c.png" alt=""><br>使用 <code>jit.brcosa</code> 对象</p><p>更改 <code>jit.brcosa</code> 对象的属性并观察输出矩阵的变化。</p><p>与参考颜色（通常为黑色）相比，图像的亮度是指整体亮度/暗度。更改亮度属性相当于将矩阵中的值乘以该值。亮度值为 0 的图像是黑色；大于 1.0 的亮度值值将逐渐增加所有非 0 单元格直到白色（255）。值 0.5 使图像明显变暗，将值的范围从 0~255 降到 0~127。下面的色轮显示了一些亮度值：<br><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07d.png" alt=""><br>亮度值分别为 0.5，1.5 和 10 的色轮</p><p>用这种方式调整时，单元格的值会被裁剪为 0 和 255。这就是为什么亮度为 10 的那个图像基本上是白色，颜色只显示在原始矩阵中一/多个可见颜色平面（RGB 或平面 1,2 和 3）为 0 的区域。</p><p>图像对比度可以表示为<strong>图像中的颜色偏离整个原始图像的平均亮度的量</strong>（见下文）。当<code>jit.brcosa</code> 的对比度属性增加到 1.0 以上，高于整个矩阵平均亮度的单元变亮（增加），低于平均值的单元变暗（减少）。结果是矩阵图像 dynamic expansion，亮值更亮，暗值更暗。低于 1.0 的对比度设置则相反，较暗的色调变浅，较浅的色调变暗，直到对比度为 0.0，只保留整个图像的平均灰度。负值会以相同的总体对比度反转图像的颜色。</p><blockquote><p>技术细节：矩阵的平均亮度可以通过平均矩阵中所有单元格的值来计算，各平面互不干扰（获得 Alpha，red，green，blue 平面各自的平均值）。然后将三个平面乘以公式：</p><p><code>L = .299 * Red+ .587 * Green + .114 * Blue</code></p><p>L 值就是整个矩阵的平均亮度，<code>jit.brcosa</code> 用它来确定调整对比度时扩展的阈值。</p></blockquote><p>以下是一些对比度设置：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07e.png" alt=""><br>比度设定为 0.3，2，-1 和 100 的色轮</p><p>第一个例子中色轮的对比度急剧下降（单元格的值都接近矩阵的平均亮度）。第二个例子中对比度增加。请注意色轮中间较浅的色调开始接近白色。第三个示例显示了负值对比度。颜色与原始颜色相反，但矩阵的平均亮度与原始颜色相同。最后一个例子是大幅增强对比的结果。该示例中的单元值被极化为0 或 255。</p><p>图像饱和度反映了单元格中主要颜色与次要颜色的比率。随着饱和度值降至 1.0 以下，单元格中的所有颜色值将变得相似，变成去饱和的灰度。高于 1.0 的值将使颜色彼此远离，从而强化了主色。与对比度类似，饱和度属性的负值将反转颜色，但保留与原始颜色相同的亮度关系。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07f.png" alt=""><br>饱和度值为 0.2,2 和 -1 的色轮</p><p>第一个图像是去饱和的，矩阵中的每个单元格值都趋近于该单元格的亮度值。第二张图像过饱和，颜色比原始图像更亮（或更暗）。第三个图像保持色轮的原始亮度，但反转了颜色。</p><h2 id="Hue-and-Cry"><a href="#Hue-and-Cry" class="headerlink" title="Hue and Cry"></a>Hue and Cry</h2><p><code>jit.hue</code> 对象可以旋转输入矩阵的色调。设置 hue_angle 属性会将输入矩阵的色调旋转指定的度数（以度为单位）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07g.png" alt=""><br>hue_angle 属性旋转输入矩阵的色调</p><p>矩阵单元的色调可以看作是其基本颜色（例如，品红色）。图像色调在色轮上从红色变为绿色、蓝色，再变为红色。用 0-360 度数指定的色调值，以及图像的饱和度和亮度，可用描述特定的颜色，这与 RGB 值描述唯一颜色的方式非常相似。向前旋转图像的色调，我们移动颜色光谱的红色部分，使其显示为绿色，光谱的绿色部分显示为蓝色，蓝色部分显示为红色。饱和度和亮度不会改变。负色调旋转会将红色变为蓝色。以 120 度为增量的色调旋转将使图像与原始色调精确地移位一个（或多个）色彩平面。</p><blockquote><p>技术细节：我们的眼睛通过视网膜锥体的感知器来感知颜色（还有一种被称为 rods 的感知器专门探测微弱的光，但是不识别颜色）。我们眼睛的锥体响应三种不同波长的光来区分：L-senstive receptors 感知长波长的光（红色），M-senstive receptors 感知中波长光（绿色），以及 S-senstive receptors 感知短波长的光（蓝色）。跟听觉系统被加权以更好地感知人类语音范围内的频率一样，为了感知环境最关键的中间波长，我们的视锥细胞的分布也经过了加权处理。于是我们眼睛中的绿色感知器大约是其他两种颜色的两倍。所以上面的亮度公式将几乎 60％ 的感知亮度分配给图像中的绿色值。</p></blockquote><p>单击开关以自动化色轮的 hue_angle。请注意，当 hue_angle 达到 360 度时，会恢复原始矩阵图像。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07h.png" alt=""><br>色轮在各种色调之间旋转（0~360 度）</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.brcosa</code> 和 <code>jit.hue</code> 对象控制输入矩阵的亮度，对比度，饱和度和色调。你可以使用这两个对象调整动态水平（例如自动曝光），校正色彩或实现指定色调的位移。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译08 - 调整颜色</title>
    <link href="http://uegeek.com/180831-jitter-08.html"/>
    <id>http://uegeek.com/180831-jitter-08.html</id>
    <published>2018-08-31T11:04:49.000Z</published>
    <updated>2018-08-31T11:09:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-8.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter06" target="_blank" rel="noopener">Tutorial 6: Adjust Color Levels</a></p></blockquote><h2 id="jit-scalebias"><a href="#jit-scalebias" class="headerlink" title="jit.scalebias"></a>jit.scalebias</h2><p>本教程进一步讨论了<a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">上一章</a>的颜色话题，并介绍专门用于修改矩阵 ARGB 颜色平面的对象：<code>jit.scalebias</code>。</p><p>“scale” 是缩放因子，乘以给定的数值。”bias” 是加上一定的量来偏移某个值。组合乘法和加法，可以实现输入值到输出值的线性映射。</p><p>因为 <code>jit.scalebias</code> 修改图像中的 ARGB 颜色信息，所以它只处理 char 数据类型的 4 平面矩阵。（有关 ARGB 颜色和 char 数据的内容，请参阅 <a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">教程 7</a>）</p><h2 id="用-char-类型数据计算"><a href="#用-char-类型数据计算" class="headerlink" title="用 char 类型数据计算"></a>用 char 类型数据计算</h2><p><a href="https://www.uegeek.com/180830-jitter-06.html" target="_blank" rel="noopener">前一章讲到</a>，char （8位）数据可以表示 0~255 之间的整数值，或 0~1 之间的小数值。比如在<a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 中，我们用 <code>jit.print</code> 输出 0~255 的整数值。但是很多时候要修改矩阵的 char 值（更改其中一个属性）时，Jitter 对象只接收浮点数属性值。这可能有点费解，让我们来看看本教程的 patch。</p><p>打开教程 patch。双击打开中间的 <code>explain_scalebias</code>查看子 patch：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06a.png" alt=""><br>char 数据的浮点类型演示</p><p>在上面的例子中有一个非常小的矩阵。它有 4 个 char 平面，但只有一个单元。这样我们只需要注意矩阵中单个数值的变化。已将平面 2（绿色平面）的值设置为 100。在右侧，把整数值转换为 0~1 之间的小数值：用 100/255，得到 0~1 之间的值 0.392。</p><p><code>jit.scalebias</code> 对象乘上指定的缩放因子，然后再加上偏移因子。<code>jit.scalebias</code> 计算时会把所有值看做浮点数，然后再转换为 char 数据重新存储到矩阵中。</p><p>这里用 <code>scale 2.0</code> 和 <code>bias 0.2</code>消息来设置缩放和偏移因子。缩放因子（乘数）是 2.0，偏移因子（之后添加的偏移）是 0.2。为了了解 <code>jit.scalebias</code> 内部机制，将绿色值看做 <code>0.392 x 2.0 + 0.2</code>，等于 0.984。<code>jit.iter</code> 对象逐一输出每个单元中每个平面的值（矩阵只有一个单元），（以 char 类型存储在矩阵中）为 251（或是 0~1 范围的 0.984）。</p><p>（作为练习，请计算 <code>jit.scalebias</code> 在上面例子中在红色和蓝色平面中产生的值。在原矩阵中这些平面的值为 0，因此结果矩阵中的值将为 <code>0 x 2.0 + 0.2 = 0.2</code>，在 0~255 的范围内等于 51。因此底部的 <code>jit.pwindow</code> 对象显示的 RGB 值是 51 251 51）</p><h2 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h2><p>如果前一部分的讲解你已经理解得很清楚，可以跳过这部分。如果还是不太清楚 char 数据（特别是 <code>jit.scalebias</code>）的数学运算是如何工作的，这里还有一些例子。</p><p>从左到右逐个点击 <code>preset</code> 对象中的每个预设值。下面我们解释每个预设。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/tut%2006%20presets.png" alt=""></p><ol><li><p>原始矩阵的绿色平面中的值为 255.（相当于 0~1 范围的 1.0） <code>jit.scalebias</code> 将其乘以 0.5 得到 127.5; 但是将值存储为 char 时，<code>jit.scalebias</code> 会截断小数部分，将值存储为 127。</p><blockquote><p>这产生了相当不精确的结果。（0~255 范围的 127 等于 0~1 范围内的 0.498，而不是我们期望的 0.5）但用 8 位 char 数据只能这样了。如果需要更高的精度，char 数据就不适合，需要用 long，float32 或 float64 数据的矩阵，以及 <code>jit.op @op *</code> 和 <code>jit.op @op +</code> 对象。</p></blockquote></li><li><p>原始值为 100，将它加倍（缩放因子 2.0）会得到预期结果 200。这样不会有精度损失。</p></li><li>原始值为 100（0.392）。缩放 1.0 倍保持不变，然后加上 -0.2 （也就是减去 0.2）得到结果 49（即 0.192）。</li><li><code>0.392 x 2.0 + 0.2 = 0.984</code>。在 0~255 的范围内为 251。</li><li>此示例和下一个示例说明当乘法和加法运算的结果超过 8 位字符的容量时会发生什么。<code>jit.scalebias</code> 会直接裁剪结果为 char 的最大或最小值。这里，0.392 x 4.0  = 1.568（即 100x4 = 400），因此取上限为 255。</li><li>在另一个方向，0.392 - 0.5 = -0.108，因此结果为 0。</li></ol><p>注意，这些误差和裁剪只发生在将结果重新存储为 char 时。在此之前，这些值在内部用浮点数计算，可以保证精度。即使乘法使内部值超出0~1 范围，也不会做裁剪，而且加法运算可以让其回到范围。这里 0.392 x 3.0（= 1.176）- 0.5 = 0.676。存储为 char 时会产生小的误差。0.676 在 0~255 范围内等于 172.38，但是小数部分会被截断并存储为 172（即 0.675）。如果没有变化，比例因子应为 1，偏移量应为 0。</p><p>你可以尝试更多的值，直到完全了解 <code>jit.scalebias</code> 以及 8 位 char 数据产生的结果。完成后关闭 [explain_scalebias] 窗口。</p><h2 id="调整图像的颜色亮度"><a href="#调整图像的颜色亮度" class="headerlink" title="调整图像的颜色亮度"></a>调整图像的颜色亮度</h2><p>现在将 <code>jit.scalebias</code> 应用于彩色图像。在教程 patch 的左上角可以看到熟悉的配置：<code>jit.movi​​e</code> 对象，加载视频的 <code>read</code> 消息，和从 <code>jit.movi​​e</code> 触发 jit_matrix 消息的 <code>metro</code>对象。在这个 patch 中，<code>jit.scalebias</code> 用乘法和加法来修改矩阵。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06b.png" alt=""><br>加载图片或视频</p><p>点击 <code>read chilis.jpg</code> 读取 JPEG 静态图像（而非视频）到 <code>jit.movi​​e</code>。QuickTime 可以处理各种媒体格式，包括 PICT 或 JPEG 格式的静止图像。<code>jit.movi​​e</code> 将静止图像视为 1 帧长的视频。</p><p><code>jit.movi​​e</code> 的输出将传到 <code>jit.scalebias</code> 处理，然后显示在 <code>jit.pwindow</code> 中（现在先忽略 <code>jit.matrix</code> 对象。我们在本章后面讨论）。可以修改 <code>jit.scalebias</code> 的 scale 和 bias 属性来更改值。</p><p>点击开关启动 <code>metro</code>。拖动 <code>scale $1</code> 消息框上方的数字框，将 scale 属性值增加到 1.25。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06h.png" alt=""></p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06c.png" alt=""><br>增加图像亮度; scale 值越大亮度越大</p><p>这将使图像的 4 个平面的所有非零值放大到 1.25 倍（增加 25％）。请注意，乘法会让较大的被乘数增加更多值。例如，如果原始矩阵中某单元格的红色值为 200，它将增加到 250（净增加 50），而同一单元格的蓝色值可能从 30 增加到 37（净增加 7）。</p><ul><li>尝试将 scale 增加到非常大，如 20。原始矩阵中 13 或更大的值将被增大到最大值 255（甚至非常小的值也会增加到可见水平），产生人为的过度曝光。</li><li>尝试将 scale 降低到 0~1 之间。这会使图像变暗。scale ≤ 0 会将所有值设置为 0。</li><li>将 scale 属性恢复为 1。现在尝试调整 bias 属性，为矩阵中所有值添加常量。正值使图像变亮，负值使图像变暗。</li></ul><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06d.png" alt=""><br>以常量提升（或降低）亮度</p><p>还可以尝试几种更极端的 scale 和 bias 设置。设置 scale 为 40，bias 为 -20。这会将几乎所有值推到 255 或 0，除白色或黑色之外仅留下少数颜色。尝试设置 scale 为 -1，bias 为 1。高低值会互换，反转颜色。继续降低 scale（比如 -4 或 -8）会产生类似的反转，但只有原始值较低的值才会被正 bias 提升回 0~1 范围。</p><h2 id="单独调整平面"><a href="#单独调整平面" class="headerlink" title="单独调整平面"></a>单独调整平面</h2><p>你可以用 scale，abias，rscale，rbias 等属性在 <code>jit.scalebias</code> 中单独调整每个平面中的亮度。</p><p>将 scale 设置回 1，将 bias 设置回 0。然后提供新的值来独立调整每个颜色平面。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06e.png" alt=""><br>调整每个颜色平面的亮度</p><p>这里有一个可以同时调整三个颜色平面缩放比例的控制器，让过程更具交互性。单击或拖动 <code>swatch</code> 对象时，它发送一个表示鼠标所在位置 RGB 颜色值的列表。这些值之前以 0~255 范围表示，现在已经被改为 0.0~1.0 的值（如果需要，inspector 中有一个复选框可选择用旧样式输出）。用 <code>unpack</code> 拆分列表为三个单独的浮点数来改变 <code>jit.scalebias</code> 的 rscale，gscale 和 bscale 属性 。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06f.png" alt=""><br>用 <code>swatch</code> 的值作为 <code>jit.scalebias</code> 的属性</p><ul><li>拖动 <code>swatch</code> 同时缩放 RGB 三个平面。这会产生 0~1 范围内的缩放值来降低所有亮度，让图像稍微变暗。</li><li>可以在不同图像上尝试这些操作。读取其他彩色图像如 colorswatch.pict 或 wheel.mov， 并尝试调整颜色亮度。</li></ul><h2 id="重新分配矩阵的平面"><a href="#重新分配矩阵的平面" class="headerlink" title="重新分配矩阵的平面"></a>重新分配矩阵的平面</h2><p>在<a href="https://www.uegeek.com/180830-jitter-06.html" target="_blank" rel="noopener">上一个教程</a>中，我们使用 <code>jit.unpack</code> 和 <code>jit.pack</code> 来重新组合矩阵的平面。使用 <code>jit.matrix</code> 对象的<code>planemap</code> 属性也可以做到。在这个例子中，用 <code>jit.matrix</code> 传递 <code>jit.movi​​e</code>的输出来演示如何设置 <code>planemap</code> 属性。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06g.png" alt="">        </p><p>用 <code>jit.matrix</code> 重新分配矩阵的平面</p><p><code>jit.matrix</code> 的 <code>planemap</code> 属性可以映射（分配）输入矩阵的任何平面到输出矩阵的任何平面上。planemap 后面跟的数字表示矩阵中有多少平面（在本例中为 4）。列表中的每个位置代表输出平面（第一个代表输出平面 0，第二个代表平面 1，等等），数字表示分配给它的输入平面。默认情况下，平面值为 0 1 2 3（等），输入矩阵中的每个平面都分配给输出矩阵中的同一平面。可以随意更改这些映射。例如，如果发送消息 <code>planemap 0 3 2 1</code> 给 <code>jit.matrix</code> ，会把输入平面 3 分配给输出平面 1（3 位于输出平面 1 的列表位置），把输入平面 1 输出到平面 3。这样就调换了图像的红色和蓝色平面。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/tut%2006%20planemap.png" alt="">    </p><ul><li><p>点击 <code>read wheel.mov</code> 消息框并启动 <code>metro</code> 显示视频。（设置<code>jit.scalebias</code> scale 属性为 1，bias 属性为 0，就可以在 <code>jit.pwindow</code> 中看到未改变的图像）在 patch 的右下角，单击<code>planemap 0 3 2 1</code> 消息框交换矩阵的红色和蓝色平面。单击消息框 <code>planemap 0 1 2 3</code> 恢复正常的平面映射。如果设置所有 RGB 输出平面设置为相同的输入平面，将在三个 RGB 平面中得到相等的值，从而产生灰度图像。</p></li><li><p>单击消息框 <code>planemap 0 1 1 1</code> 查看效果。三个 RGB 平面在列表中的值都是 1，因此原始的红色平面用来输出矩阵的所有 RGB 平面。用一个 <code>coll</code> 对象存储所有平面映射的组合，发送到 <code>jit.matrix</code> 来更改 <code>planemap</code> 属性。</p></li><li><p>双击 patcher <code>rotatecolorplanes</code> 查看子 patch。里面有一个 1 到 6 的计数器，逐一执行主 patch 中 <code>coll</code> 对象中的不同映射。（当它关闭时会发出数字 1 重置为默认平面映射）<br>  <img src="http://7xjpra.com1.z0.glb.clouddn.com/tut-06-counter.png" alt=""></p></li><li><p>点击主 patch <code>rotatecolorplanes</code> 对象上方的开关，以每秒切换一次设置的速率，逐一执行不同的平面映射。将右输入口上方的数字框更改为较小的值（例如 80），查看快速重新分配平面的闪烁效果。</p></li></ul><p>在下一章节中，你将了解如何使用 <code>jit.hue</code> 以更微妙的方式调整图像色调，以及使用 <code>jit.brcosa</code> 调整颜色的其他方法。</p><h2 id="读取和导入图像"><a href="#读取和导入图像" class="headerlink" title="读取和导入图像"></a>读取和导入图像</h2><p>在本教程 patch 中，将三种不同类型的图像加载到 <code>jit.movi​​e</code> 中：PICT 和 JPEG 静止图像，以及 QuickTime 视频。在视频对象中读入静止图像看起来有点奇怪，但 QuickTime 确实可以播放多种类型的媒体文件，<code>jit.movi​​e</code> 知道如何读取它们。（<code>jit.movi​​e</code> 还可以读入 AIFF 音频文件，用 start 和 stop 消息播放，用 time 属性跳转到不同的位置等等。当然这时看不到矩阵的任何视觉内容）</p><p><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">如教程 5 所示</a>，用 <code>importmovie</code> 消息加载静止图像到 <code>jit.matrix</code> 中很方便。用这种方式导入 QuickTime 视频，只有一帧存储在 <code>jit.matrix</code> 中。</p><p>在这个 patch 中，我们用 <code>jit.movi​​e</code> 加载所有图像。原因一是我们要加载整个视频（不只是视频的一帧）。原因二是想演示 <code>jit.matrix</code> 的 planemap 属性。矩阵有实际输入（左入口传入 jit_matrix 消息）时，<code>planemap</code> 属性才起作用。如果用 <code>importmovie</code> 直接导入图像到 <code>jit.matrix</code> ，<code>planemap</code> 不起作用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.scalebias</code> 用乘法和加法来修改 4 平面 char 矩阵中指定的平面（或所有平面）的值。scale 是矩阵中的每个值要乘上的缩放因子；bias 是乘法之后被加到每个单元的值。scale 和 bias 属性影响矩阵的所有平面。如果想一次只影响一个平面，请使用特定的属性例如 ascale，abias，rscale，rbias 等。</p><p>必须用浮点数定义这些属性值。当执行乘法和加法运算时，<code>jit.scalebias</code> 将 char 值视为 0~1 范围内的小数值，使用 floats 执行数学运算，然后将结果转换回 char（0~255 之间的整数）并存储。超出 0~1 范围的结果，在转换回 char 之前截取为 0 或 1。</p><p>可以用 <code>jit.matrix</code> 的 <code>planemap</code> 属性重新分配矩阵的平面。<strong><code>planemap</code> 的参数按顺序列出输出平面，列表中的值是要分配给每个输出平面的输入平面</strong>。例如，要将输入矩阵的平面 1 分配给输出矩阵的所有四个平面，属性应设置为 <code>planemap 1 1 1 1</code>。</p><p><code>jit.scalebias</code> 提供了强大的工具来调整 4 平面 char（ARGB 颜色）矩阵中的颜色值。下一章节将介绍更多此类工具。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译07 - ARGB 颜色</title>
    <link href="http://uegeek.com/180830-jitter-07.html"/>
    <id>http://uegeek.com/180830-jitter-07.html</id>
    <published>2018-08-30T10:00:18.000Z</published>
    <updated>2018-08-31T11:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-7.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter05" target="_blank" rel="noopener">Tutorial 5: ARGB Color</a></p></blockquote><h2 id="Jitter-中的颜色"><a href="#Jitter-中的颜色" class="headerlink" title="Jitter 中的颜色"></a>Jitter 中的颜色</h2><p>本节将讨论如何在 Jitter 中处理颜色，主要讲解用数字表示颜色，而不涉及把数字可视化为颜色。用数字表示颜色有许多方法，而关于色彩理论的全面讨论 - 光和物质如何产生色彩感觉 - 远远超出了本教程的范围。如果想了解颜色相关的理论和/或颜色数值表示的更多信息，可以查看参考书目。</p><p>本节重点说明 Jitter 表示颜色的方法，以及如何在矩阵中实现。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/tut5%20patch.png" alt=""></p><h2 id="颜色组成：RGB"><a href="#颜色组成：RGB" class="headerlink" title="颜色组成：RGB"></a>颜色组成：RGB</h2><p>混合红色，绿色和蓝色可以产生任意颜色 - 每种颜色都有一定的亮度（intensity）。这是「加法合成（additive synthesis）」 - 添加一定量的三原色光来生成颜色（与此相反的是减法合成：混合有色颜料，如油漆，吸收某些颜色的光并反射其余部分）。这样就可以用红色，绿色和蓝色相对应的频率强度来描述任意颜色。</p><p>在 Jitter 中一般用红色，绿色和蓝色的精确亮度组合来描述颜色。对于图像的每个像素 - 无论是视频，图片还是其他 2D 矩阵 - 至少需要三个值表示三原色。屏幕上的彩色图像一般使用至少 3 个平面的 2D 矩阵。</p><h2 id="Alpha-通道"><a href="#Alpha-通道" class="headerlink" title="Alpha 通道"></a>Alpha 通道</h2><p>第 4 个平面一般是 alpha 通道 - 它存储像素的透明度信息。Jitter 矩阵中一般都会包含颜色透明度的 alpha 通道。多数情况下，<strong>alpha 通道存储在平面 0（矩阵平面从 0 开始编号），RGB 值存储在 1,2 和 3 平面中</strong>。</p><h2 id="颜色数据：char，long-或-float"><a href="#颜色数据：char，long-或-float" class="headerlink" title="颜色数据：char，long 或 float"></a>颜色数据：char，long 或 float</h2><p>在计算机中用 8 位信息来表示每个基本颜色值。8 位能够表达 256（2 的 8 次幂）个不同值。如果分别用 8 位表示红色、绿色、蓝色，总共可以表示 16,777,216（2 的 24 次方）种不同颜色，足以覆盖人眼能够区分的所有颜色渐变。</p><p>因为 8 位分辨率已经可以表示所有基本颜色值，所以颜色信息矩阵 4 个平面中的值用 8 位 char 类型就足够了。当然 Jitter 也允许用 long，float32 或 float64 类型，只不过这会浪费内存。全帧视频图像要处理大量的像素（640x480 图像有 307,200 像素），为了节省内存和加快处理速度，最好使用 char 数据类型。</p><p>8 位 char 数据可以表示 0~255 之间的数字，或者 0~1 之间的灰度。包含 char 数据的 Jitter 对象，通常以 0~1 范围内浮点数的形式从其他 Max 对象接收数值。然后在内部计算时将浮点数转换为对应的 char 值（有一些例外，例如 <code>jit.op</code> 可以接收 0~1 的浮点数或右入口的 0~255 的整数）。关于在 Jitter 矩阵中使用 char 数据类型的更多内容，请参阅教程<a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">什么是矩阵？</a></p><h2 id="分离矩阵的平面"><a href="#分离矩阵的平面" class="headerlink" title="分离矩阵的平面"></a>分离矩阵的平面</h2><p>在示例 patch 的顶部有两个视频。一个是街机游戏，另一个是视频校准的标准颜色条。打开 <code>metro</code>对象（用来反复触发矩阵对象）可以查看。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05a.png" alt=""><br>观看视频或静止图像</p><p>单击 <code>metro 30</code>对象上方标有 “show movie” 的按钮查看视频</p><p>示例 patch 用 <code>jit.unpack</code> 对象将颜色信息矩阵分解为 4 个平面，可以单独查看和修改每个平面。与 Max 对象 <code>unpack</code> 将列表拆开成单个数字类似，<code>jit.unpack</code> 将多平面矩阵分解为单平面矩阵。可以输入参数来指定矩阵中有多少个平面，默认是 4 个平面，这是颜色数据的标准。想看到红色，绿色和蓝色屏幕的内容，就将平面 1,2 和 3 发送到 <code>jit.pwindow</code>。因为这里不关心 alpha，所以不显示平面 0。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05b.png" alt=""><br>将多平面矩阵拆为单平面矩阵</p><p>可以用三个单色图像查看每个颜色平面的内容。较亮的像素表示该颜色值较大。将每个矩阵发送到 <code>jit.op</code> 可以单独控制每种颜色的强度，并改变颜色平衡。然后将单个（改变后的）矩阵发送到 <code>jit.pack</code>，重新组合为 4 平面矩阵在 <code>jit.pwindow</code> 中显示。</p><p>尝试将绿色和蓝色的强度降低到 0.12，生成更偏红色的图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05c.png" alt=""><br>降低某些颜色的亮度来改变颜色平衡</p><h2 id="颜色交换"><a href="#颜色交换" class="headerlink" title="颜色交换"></a>颜色交换</h2><p>为了演示另一种技巧，将每个颜色平面发送到 <code>gate</code> 对象，这样每个矩阵都可以 <code>route</code> 到 <code>jit.pack</code> 的不同入口（颜色平面）。这样就重新定义了每个平面，并且从 patch 左侧的 <code>coll</code> 对象中选择选项来尝试所有可能的颜色组合。</p><p>拖动标记为 “Rotate RGB planes” 的数字框，尝试重新分配三个颜色平面。（请注意，平面 0 直接从 <code>jit.unpack</code> 发送到 <code>jit.pack</code> ; 它是触发矩阵输出到 <code>jit.pwindow</code>的 <code>jit.pack</code>的左入口收到的 <code>jit_matrix</code> 消息）如果选择 coll 中的选项 3，会得到如下结果：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05d.png" alt=""><br>重新分配各个颜色平面; 红色和绿色平面相互交换</p><p>上面的示例显示原始的绿色和蓝色平面减少为原来的 0.12，并在发送到 <code>jit.pack</code>之前，用 <code>gate</code> 调换红色和绿色平面，得到更偏绿色的图像。<code>coll</code> 对象包含 RGB 平面所有可能的排列组合。</p><p>双击 <code>coll</code> 对象可以查看其内容：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05f.png" alt=""><br>RGB 平面分配的排列组合</p><p>来自 <code>coll</code> 列表中的元素被 <code>unpack</code> 并发送给 3 个 <code>gate</code> 对象。发送到 <code>coll</code> 的数字也会发送给 umenu（标签模式）用单词显示颜色状态 - 现在显示为 “Green-Red-Blue”。</p><h2 id="颜色自动变化"><a href="#颜色自动变化" class="headerlink" title="颜色自动变化"></a>颜色自动变化</h2><p>让我们再来做一个颜色修改练习：制作不断更改颜色的缩放和旋转的自动化流程。</p><p>点击标记为 “Automate color changes” 的开关。三个颜色平面的缩放因子都在不断变化。双击 patch <code>colorgames</code> 对象查看子 patch 的内容。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05e.png" alt=""><br>[colorgames]子 patch</p><p>子 patch 用 <code>line</code> 对象为每个颜色缩放因子发送 0.5~1 的值。红色系数每 3 秒变化一次，绿色每 4 秒变化一次，蓝色每 5 秒变化一次（这三个 line 对象每 60 秒同步一次）。每隔 60 秒，<code>metro</code> 计数器会选择一个新的颜色组合。</p><p>你可以在不同的源图像上尝试所有颜色组合。回到主 patch，点击标记为 “Show movie” 的开关停止 <code>metro</code>。（也可以用这个开关来启动和停止 <code>jit.movi​​e</code> 播放视频。如果不需要观看，就没必要持续播放）现在点击标有 “Show colorbars ” 的开关来显示颜色栏。试着更改此图像上的 scale 和 rotation 系数。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当 <code>jit.window</code> 或 <code>jit.pwindow</code> 接收<strong>单平面</strong> 2D 矩阵时，会显示为单色（灰度）图像。当接收到 <strong>4 平面</strong> 2D 矩阵时，会将平面解析为 alpha，red，green 和 blue 值并显示相应颜色。<strong>Jitter 最常用 ARGB 4 平面矩阵来表示颜色。</strong></p><p>Jitter 颜色数据以 char 数据类型存储，因为所有基本颜色只需要 8 位精度就可以完全覆盖。大多数与 QuickTime 相关的对象（例如 <code>jit.movi​​e</code>）和许多专门用于操作颜色的对象（例如 <code>jit.brcosa</code> 和 <code>jit.colorspace</code>）都使用 4 平面 char 数据的 2D 矩阵。（许多对象会自适应其他数据类型。如有疑问请查看相应文档）。<strong>char 数据的范围是 0~255 的证书，或者 0~1 的浮点数</strong>。大多数情况下，包含 char 数据的对象从其他 Max 对象接收 0~1 的浮点数值。</p><p><strong><code>jit.unpack</code> 可以拆分多平面矩阵为单平面矩阵。<code>jit.pack</code> 打包单平面矩阵成一个多平面矩阵。</strong>单独处理每个平面可以控制图像的色彩平衡，甚至可以重新定义各个平面。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译06 - 控制视频播放</title>
    <link href="http://uegeek.com/180829-jitter-06.html"/>
    <id>http://uegeek.com/180829-jitter-06.html</id>
    <published>2018-08-29T13:15:21.000Z</published>
    <updated>2018-08-29T13:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-6.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter04" target="_blank" rel="noopener">Tutorial 4: Controlling Movie Playback</a></p></blockquote><p>本教程讲解在 Jitter 中播放 QuickTime 视频的进阶知识。我们将学习如何获得正在播放的视频的信息，以及如何更改速度、音量和循环点来控制视频的播放。</p><p>你应该已经熟悉 patch 中的两个 Jitter 对象： <code>jit.movi​​e</code> 和 <code>jit.pwindow</code>。其余部分尝试改变已加载到 <code>jit.movi​​e</code> 对象中的视频的播放行为。</p><p>patch 的左边部分我们很熟悉了：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04a.png" alt=""><br>打开并播放视频</p><p>点击消息框 <code>read crashtest.mov</code>，打开文件。</p><p><code>jit.movi​​e</code> 一读入视频就开始播放。这个视频有配乐，因此视频加载后会立即听到音乐。视频配乐由计算机内置音响而不是 MSP 播放。如果不希望听到声音，可以将消息框 <code>vol $</code> 的数字 1 改为 0。</p><p>即使视频正在播放，<code>jit.pwindow</code> 没有显示任何东西，因为 <code>jit.movi​​e</code> 需要 bang 消息才能发送矩阵到 <code>jit.pwindow</code>。单击连接到其入口的开关，启动 <code>metro</code> 对象。这时视频图像出现在 <code>jit.pwindow</code> 中。先忽略 <code>gettime</code> 消息，等会我们会提到。</p><h2 id="获取视频信息"><a href="#获取视频信息" class="headerlink" title="获取视频信息"></a>获取视频信息</h2><p><code>jit.movi​​e</code> 打开新的视频时，会读取视频的大量信息（包含在视频的标题中），包括视频的长度、有多少帧、播放速度等。我们用这些元数据来控制视频播放。</p><blockquote><p>要点：与许多可手动设置或由对象本身设置的 Jitter 属性不同， <code>jit.movi​​e</code> 的许多属性都依赖于当前的视频文件。不同视频生成不同的设置。</p></blockquote><p>要对 QuickTime 视频做的第一件事是读取元数据属性。可以向 <code>jit.movi​​e</code> 发送 <code>get</code> 消息来检索。然后解析对象最右输出口的响应消息。我们需要的信息是帧速率，时间单位(time scale)（一秒钟内 “QuickTime 时间单位” 的数量），持续时间（QuickTime 的单位），播放速率和音量。这些都通过带有 <code>getfps, gettimescale, getduration, getrate, getvol</code>的消息框获得。</p><p>让 <code>jit.movi​​e</code> 打开一个视频并播放时（发送<code>read</code>消息），它会向右输出口发送一条消息，告诉你它已找到视频并知道如何播放。如果要将打印对象连接到 <code>jit.movi​​e</code> 的右输出口并重新加载影片，会在 Max Console 中看到：<code>read crashtest.mov 1</code>。</p><p>在这个 patch 中，<code>jit.movi​​e</code> 的右输出口连接了一个 <code>route</code> 对象。加载成功后它收到 <code>read</code> 消息并传递给 <code>unpack</code> 和 <code>select</code>，再触发 <code>get</code>消息。如果无法找到 crashtest.mov 文件，会在文件名后看到 1 以外的数字，并且不会发出请求。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04b.png" alt=""><br>自动查询 <code>jit.movi​​e</code> 对象</p><p>除了捕获 <code>read</code> 消息之外，<code>route</code> 对象在接收到视频信息后做分发。Jitter 属性一般都由在 patch 中设置为相同格式的对象输出：属性的名称，后跟需要设置的信息。<code>route</code> 出口连接了数字框，以显示分发的值。虽然还不知道那些值代表什么，但是每次 <code>jit.movi​​e</code> 成功加载新视频时都会显示属性。</p><h2 id="开始，停止和减速"><a href="#开始，停止和减速" class="headerlink" title="开始，停止和减速"></a>开始，停止和减速</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04c.png" alt=""><br>一些简单的视频播放控件</p><p>patch 的顶部有一些可以更改 <code>jit.movi​​e</code> 回放行为的控件。向 <code>jit.movi​​e</code> 发送 <code>stop</code>消息，将在视频当前帧停止播放。发送 <code>start</code> 消息将从上次停止的位置恢复播放。视频播放停止时，视频文件中的所有音轨也都将停止。停止和启动视频对 <code>jit.movi​​e</code> 对象的矩阵输出没有影响，该输出仍然由 <code>metro</code> 对象控制。如果在开启 <code>metro</code> 的情况下停止播放视频，仍将以 <code>metro</code> 的速度收到新的矩阵对象（这里是每秒 25 次），虽然所有矩阵都是相同的。</p><p>更改视频的速率将改变音视频内容的播放速度。正的速率值使视频向前播放，值为 1 表示正常播放速度。负值将使视频倒退，速率为 0 将停止播放。<code>jit.movi​​e</code> 的速度属性以浮点数为参数，因此值 0.5 会使视频播放速度减半，值 -2.3 以超过两倍的速度向后回放。调整这个值时，音轨会加速、减速、向后播放，跟视频保持同步。一旦视频到达其最后一帧（或回放时的第一帧），它将循环到文件的另一端。将 <code>jit.movi​​e</code> 的 loop 属性设置为 0（无循环），1（常规循环）或 2（回文循环），可以更改此行为。</p><p><code>vol</code> 属性控制视频音轨的音量（响度）。1 为全音量，0 将关闭声音。</p><p>加载视频时，速率和音量属性都由 pathc 中间的消息框初始化。它们会给出每个 QuickTime 影片中存储的值。</p><h2 id="时间属性"><a href="#时间属性" class="headerlink" title="时间属性"></a>时间属性</h2><p>之前查询了三个属性：duration，timescale 和 fps，告诉我们视频文件如何处理时间。Duration 说明了视频的总长度。这个值不以毫秒或帧表示，而是以 QuickTime 时间单位表示。每个时间单位的实际长度，取决于视频的时间单位。视频的 timescale 是每秒视频的分辨率。视频的duration / timescale 会得出视频的大致长度，以秒为单位。例如， crashtest.mov 文件有一个持续时间为 2836 个时间单位和 600 的 timescale。视频大约持续 4.73 秒。如果想要用 2 秒钟播放视频，可以将 <code>jit.movi​​e</code> 设置 <code>time 1200</code>（1200 时间单位除以 600 单位/秒的时间刻度得到 2 秒）。</p><p>视频中的 fps （或每秒帧数）说明每秒显示多少单独的视频图像。fps 越高，视频播放就越平滑（假设每帧都不一样）。常见的 fps 速率是15, 24, 29.97 和 30. 这个例子中的视频以每秒 15 帧的速度播放，也就是每 40 个时间单位，或大约每 66.7毫秒，会更新一个视频帧。如果用 crashtest.mov 的持续时间，除以视频中每帧的 time units，可以得到视频文件有 70 帧。如果需要，可以用 <code>getframecount</code> 消息查询 <code>jit.movi​​e</code> 视频中的总帧数。</p><h2 id="截取和循环"><a href="#截取和循环" class="headerlink" title="截取和循环"></a>截取和循环</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04d.png" alt=""><br>显示和设置当前播放帧</p><p>patch 底部区域包含两个进一步操作视频播放的控件。左侧的数字框显示视频当前正在播放的帧。该值由 patch 顶部的 <code>metro</code> 对象发送到 <code>jit.movi​​e</code> 的 <code>gettime</code> 消息更新; 每次输出新的一帧时，时间都会更新。如果停止视频传输（向 <code>jit.movi​​e</code> 发送 <code>stop</code>消息），可以拖动数字框来“截取”视频。视频会跳转到 <code>frame</code> 消息指定的参数那一帧。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04e.png" alt=""><br>设置视频中的循环点</p><p>用两个整数参数设置 <code>looppoints</code>属性，可以将循环点（指定循环开始和结束的时间值）发送到 <code>jit.movi​​e</code>。教程 patch 中的 rslider 可以指定 <code>jit.movi​​e</code> 的循环区间。在加载视频时查询属性，将 rslider 的大小设置为视频的时长。可以发送不带参数的  <code>looppoints</code> 消息重置循环点。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.movi​​e</code> 提供了一些简单的属性来改变 QuickTime 播放内容的方式。可以使用这些消息停止和开始播放视频。速度属性可以改变播放速度和视频播放的方向。使用 vol 属性控制视频音轨的音量。</p><p>查询 duration，time scale 和 fps 等属性可获取加载到 <code>jit.movi​​e</code> 中视频的属性。用 <code>frame</code> 消息可跳转到视频中的特定帧，并且可以设置和检索循环点。发送 <code>gettime</code> 消息可以查询视频的当前时间位置​​。</p><p>更多强大的功能（例如编辑和保存视频）将在后面的教程中讨论。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译05 - 矩阵的数学运算</title>
    <link href="http://uegeek.com/180828-jitter-05.html"/>
    <id>http://uegeek.com/180828-jitter-05.html</id>
    <published>2018-08-28T11:37:40.000Z</published>
    <updated>2018-08-29T13:22:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-5.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter03" target="_blank" rel="noopener">Tutorial 3: Math Operations on a Matrix</a></p></blockquote><p>本教程介绍如何对存储在 Jitter 矩阵中的数据做简单的数学运算，使用 <code>jit.op</code> 对象来缩放矩阵单元格或单个平面。</p><p>教程分为三个​​简单的例子，你可以使用 <code>jit.op</code> 对象执行这些操作。<code>jit.op</code> 对矩阵的所有对象而不是单个数字执行数学运算。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03a.png" alt=""><br>向矩阵中的所有单元格添加常量</p><p>第一个示例显示了连接到 <code>jit.op</code> 的 <code>jit.matrix</code> 对象，其输出可由 <code>jit.pwindow</code> 查看。每次改变连接到 <code>jit.op</code> 右输入口的数字框，都会从 <code>jit.matrix</code> 输出一个新的矩阵。从参数中可以看出，<code>jit.matrix</code> 生成一个 4x3 的单平面 char（0-255） 矩阵。<code>jit.pwindow</code> 把这个矩阵可视化为一个灰度图像。拖动数字框将改变显示的灰度级别（黑色 0 ~ 白色 255）。</p><p>请注意，<code>jit.matrix</code> 输出了一个所有单元格都为 0 的矩阵。如果将 <code>jit.matrix</code> 和 <code>jit.pwindow</code> 对象绕过 <code>jit.op</code> 连接在一起，无论向 <code>jit.matrix</code> 发送多少次 bang 消息，都只能看到黑色图像。<code>jit.op</code> 向 <code>jit.matrix</code> 和 <code>jit.op</code> 之间的矩阵的所有单元都加上了一个值（由数字框给定）。</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="@ 操作符"></a>@ 操作符</h2><p><code>jit.op</code> 根据参数指定的运算（用 @op 表示）向矩阵加了一个值（不是乘或除）。@op 之后的参数是一个符号（或符号列表），它定义了 <code>jit.op</code> 在输入矩阵上执行的数学运算。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03a.png" alt=""></p><p>在这个例子中，op 属性设置为 + ，它对从左入口输入的任何矩阵都执行加法操作。右侧入口中的整数值会加到矩阵中的所有单元格。这个值被称为标量（scalar），因为它向整个矩阵添加了相同的值（在教程 11 中我们会展示 <code>jit.op</code> 如何使用两个矩阵进行数学运算）。</p><blockquote><p>要点：更改 <code>jit.op</code> 右侧入口中的标量值不会输出新矩阵。如果断开数字框和按钮之间的接线，<code>jit.pwindow</code> 将停止显示任何新内容。原因在于，大多数 Jitter 对象与大多数 Max 对象一样，仅在数据进入其最左侧入口时才会输出数据。</p><p>在上面的例子中，每次更改数字框时 <code>jit.op</code> 都会存储新的标量值。此时按钮发送一个 bang 给 <code>jit.matrix</code>，让它将新的矩阵（所有值设置为 0）发送到 <code>jit.op</code> 的左入口，触发输出矩阵。</p><p>如果在按钮上方的接线上放置一个断点，然后 shift-cmd-T 逐步执行消息，就能看到它是如何运作的。（有关如何使用断点功能跟踪 Max 消息，请参阅教程：消息顺序和调试）</p></blockquote><p>使用 <code>jit.op</code> 的 val 属性，标量值也可以作为常量。例如，如果想要为矩阵的所有单元格添加 134，可以使用 val 属性并省去数字框：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03b.png" alt="">            </p><p>类似地，如果想要更改由任何给定的 <code>jit.op</code> 对象执行的数学运算，可以用消息 <code>op</code> 后跟数学符号，发送到对象的左入口。</p><h2 id="多平面数据的数学运算"><a href="#多平面数据的数学运算" class="headerlink" title="多平面数据的数学运算"></a>多平面数据的数学运算</h2><p>第二个示例显示了使用 <code>jit.op</code> 将值传入矩阵的更复杂的例子。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03c.png" alt=""><br>为矩阵的每个平面使用单独的标量</p><p>这个 patch 跟第一个类似，区别在于现在使用的是 4 平面矩阵。这由 <code>jit.matrix</code> 的第一个参数给出。<code>jit.pwindow</code> 现在有颜色了，它正在解析矩阵 α/红/绿/蓝 4 个单独存储颜色通道的平面。这个例子中的 <code>jit.op</code> 包含 op 属性的四个符号的列表：每个符号设置输入矩阵的一个平面的数学运算。在这个 patch 中，保留第一个（alpha）平面不做改动，而为其他 3 个平面做加法运算。</p><p><code>pak</code> 对象向 <code>jit.op</code> 右输入口传送四个打包的整数。<code>pak</code> 和 <code>pack</code> 的唯一区别是，当更改任何数字时，<code>pak</code> 都会输出一个新列表（<code>pack</code> 需要一个新数字或左侧入口的一个 bang 来触发输出新列表）。由 <code>pak</code> 生成的四个数字决定了传入 <code>jit.op</code> 矩阵的每个平面的标量值。</p><p>在上面的示例中，平面 0 没有添加任何内容（op 属性的第一个参数是 pass）。平面 1,2 和 3 将分别添加 161,26 和 254。<code>jit.pwindow</code> 将输出矩阵的单元格解析为洋红色（即使只看到一种颜色，矩阵中实际上有 12 个单元格，都设置为相同的值）。</p><blockquote><p>要点：如果<code>jit.op</code> 对象的 op 属性只有一个值（只使用一个数字作为标量），<code>jit.op</code> 将在输入矩阵的所有平面都使用该运算符号和标量值。</p></blockquote><h2 id="修改图像中的颜色"><a href="#修改图像中的颜色" class="headerlink" title="修改图像中的颜色"></a>修改图像中的颜色</h2><p>第三个例子说明如何在矩阵中使用 <code>jit.op</code>，这个矩阵已经存储了相关数据：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03d.png" alt=""><br>将单个平面与标量相乘</p><p>单击消息框 <code>importmovie colorbars.png</code>，<code>jit.matrix</code> 的 <code>importmovie</code> 消息将图像或 QuickTime 视频文件中的单帧图像加载到对象存储的矩阵中。它会将原图像缩放到矩阵的尺寸（320 x 240）。</p><p>单击按钮，<code>jit.pwindow</code> 中显示图像校准颜色条。这时 <code>jit.op</code> 的算术运算符设置为：alpha 平面不做修改（pass）， 其他平面设置为 *（乘）。这个矩阵有 4 个平面，因此使用 4 个浮点数列表设置每个标量。平面 1~3 中的值都是 1.，结果是显示原始的图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03e.png" alt=""><br>所有标量均为 1</p><p>如果将标量设置为 1.0，0 和 0.，会看到以下图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03f.png" alt=""></p><p>包含颜色条的矩阵的所有平面（平面 1 除外）都乘以 0。这将消除矩阵的α，绿色和蓝色平面，仅留下红色（平面 1）。</p><p>将中间值（例如 0.,0.,1. 和 0.5）设置为 <code>jit.op</code> 的标量，会得到颜色栏看起来不同的图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03g.png" alt=""></p><p>在这种情况下，忽略 alpha 通道并将红色通道归零。蓝色平面的值是它们的一半。绿色通道（平面 2）保持不变。</p><blockquote><p>要点： <code>jit.op</code> 中的一些数学标量使用浮点数，有些则使用整数。这取决于相关运算符（由 op 属性定义）以及输入矩阵的类型。本教程所有示例都使用了 char 矩阵，因此在添加时可以使用整数（任何浮点数都将被截断，因为矩阵数据保留 0-255 范围内的整数）。</p><p>如果使用 float32 矩阵作为输入，就需要添加浮点数。同样，用 char 乘以浮点标量的矩阵也可以（240 * 0.5 = 120，整数）。但是，由于 <code>jit.op</code> 输出的矩阵仍然是 char 矩阵（参见下面的注释），因此仍然只能获得 0-255 范围内的值。</p></blockquote><p>如果你尝试使用标量值，容易看到某些颜色条消失或与相邻条形图合并。这是因为颜色条都设置为范围相似的标准颜色值。如果一次只显示一个通道（设置一个平面为 1，其余为 0），顶部七个条形中的四个将显示颜色。</p><p>本教程中只演示了 + 和 * 运算符，实际上 <code>jit.op</code> 对象可以执行许多其他的数学运算。运算符的完整列表请查看参考文档，或双击 <code>jit.op</code> 帮助文件中的 p op_list 子 patch。</p><h2 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h2><p>创建 <code>jit.pwindow</code> 对象时，它默认显示为 80 像素宽，60 像素高。它可以像 Max 中的许多 UI 对象一样改变大小。如果要精确地指定大小，可以使用 inspector 或向其发送尺寸消息，后跟宽度和高度（以像素为单位）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03h.png" alt=""><br>更改 <code>jit.pwindow</code> 的大小</p><p>如果给某个固定尺寸（像素）的 <code>jit.pwindow</code> 发送不同的尺寸的矩阵，<code>jit.pwindow</code> 会按自身的大小来缩放传入的矩阵。如果将非常小的矩阵发送到非常大的 <code>jit.pwindow</code> ，会做像素化处理（图像中颜色完全相同的矩形区域）。如果发送大矩阵到一个小的 <code>jit.pwindow</code>，可能会丢失不同程度的细节。</p><blockquote><p>要点：在上面的示例中，含有颜色块的 <code>jit.matrix</code> 的大小（由其维度决定）为 320 x 240 个单元格，planecount 为 4，类型是 char。<code>jit.op</code> 对象（以及大多数 Jitter 对象）识别出信息并自动适配计算、输出相同规格的矩阵。</p><p>如果要更改 <code>jit.matrix</code> 的大小， <code>jit.op</code> 将立即识别变化并重新适应。<code>jit.pwindow</code> 也适配传入的矩阵，但方式略有不同。如果输入矩阵小于其自身的尺寸，则使用重复数据填充所有像素。（这会产生前一段中描述的像素化效果）如果输入矩阵大于其自身的维度，则必须忽略某些数据，只显示它可以显示的内容。因此，即使教程 patch 中的 <code>jit.pwindow</code>跟输入矩阵的大小不同，它们也会尽可能适配 <code>jit.op</code> 矩阵。</p><p>最后一个例子中的 <code>jit.pwindow</code> 尽可能显示了 <code>jit.op</code> 输出的整个矩阵，但它必须忽略所有其他行和列，以使其接收的 320x240 矩阵适合自己的 160x120 显示区域。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.op</code> 对矩阵上的所有数据进行数学运算。可以分别对矩阵单元格中的整体或每个平面执行计算。<code>jit.op</code> 的 op 属性决定要执行什么数学运算，可以输入 <code>@op [operator]</code> 属性参数，或者由左入口中的 <code>op [operator]</code> 消息提供。</p><p>对于多平面矩阵（例如彩色图片和视频），可以给出运算符列表（例如，op pass <em> </em> *）来指定每个平面的操作，并且可以为每个平面提供不同的标量值。在教程 11 中我们会看到如何使用矩阵来代替简单的标量。</p><p>你可以使用 <code>size [width] [height]</code> 消息设置 <code>jit.pwindow</code> 的大小。<code>jit.pwindow</code> 将尽可能适应接收到的矩阵的大小。如果输入矩阵小于其维度，它将复制数据；如果输入矩阵大于其自身维度，它将忽略某些数据。大多数 Jitter 对象都尽量适应它们接收的矩阵的维度、类型和平面数量。对 <code>jit.op</code> 而言，它没有自己的维度，所以它自动适配传入的矩阵大小。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="数学" scheme="http://uegeek.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译04 - 创建矩阵</title>
    <link href="http://uegeek.com/180826-jitter-04.html"/>
    <id>http://uegeek.com/180826-jitter-04.html</id>
    <published>2018-08-26T10:59:41.000Z</published>
    <updated>2018-08-29T13:22:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-4.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter02" target="_blank" rel="noopener">Tutorial 2: Create a Matrix</a></p></blockquote><h2 id="什么是矩阵？"><a href="#什么是矩阵？" class="headerlink" title="什么是矩阵？"></a>什么是矩阵？</h2><p>本教程讲解处理矩阵数据的方法。可以先回顾一下 <a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></p><p>矩阵用虚拟的网格来存储和修改大批的数值数据。数据存储在矩阵中，就可以通过网格位置查找，并指定整个矩阵或部分矩阵来批量修改多个值。</p><p>在<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">上一篇教程</a>中，我们使用 <code>jit.window</code> 对象打开一个窗口，并将矩阵的内容显示为彩色像素。</p><p>显示的矩阵来自 <code>jit.movi​​e</code> 对象，它用 QuickTime 视频的当前帧连续填充矩阵。<code>jit.window</code> 之所以能显示视频，只不过因为被告知要显示哪些矩阵的内容; 事实上，矩阵中的任何数值都可以显示。本教程通过一个更简单的例子帮助你理解矩阵，它是 Jitter 的核心思想。</p><p>以下是本节完整的 patcher 截图</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/02patcher.png" alt=""></p><h2 id="jit-matrix-对象"><a href="#jit-matrix-对象" class="headerlink" title="jit.matrix 对象"></a>jit.matrix 对象</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02a.png" alt=""><br>为单个 8 位值创建 16x12 存储空间</p><p><code>jit.matrix</code> 对象创建矩阵并在内存中声明存储空间，以便我们存储和检索数值，并打印或显示出来。 <code>jit.matrix</code> 的参数包括：</p><ul><li>[name]（可选，本例中未包含）</li><li>[planecount]（在矩阵的每个单元格中存储多少个值）</li><li>[type]（用多少个字节来表示每个数字）</li><li>[dim]（维度，描述矩阵的大小）</li></ul><p>括号 [] 里面应填入实际的赋值。上面的例子创建了 1 个平面（每个矩阵单元包含 1 个数字）、尺寸为 16x12（共 192 个单元格）的 char 型（单字节值）矩阵。由此可以推断出矩阵能够保存 192 个单独的数值，每个值的范围是 0~255（单个字节的范围）。</p><blockquote><p>注意：在 Max 中用 x，y（宽度，高度）格式描述二维矩阵的维数，先给出水平维度的范围，然后是垂直维度。这跟视频和计算机屏幕坐标处理尺寸的方式一致（例如，640x480 视频图像）。即，先说明有多少列（宽），再说明有多少行（高）。需要注意，Jitter 描述行和列，与线性代数中描述矩阵的惯例（先表示行，然后是列）不同。</p></blockquote><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02a.png" alt=""></p><p>回到例子中，一个按钮连接到 <code>jit.matrix</code> 的入口。当 Jitter 对象在左入口接收到 <code>bang</code> 消息时会发送矩阵名称，这个按钮会触发 <code>jit.matrix</code> 发送它的矩阵名称（以 <code>jit_matrix</code> 消息的形式）。</p><h2 id="jit-print对象"><a href="#jit-print对象" class="headerlink" title="jit.print对象"></a>jit.print对象</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02b.png" alt=""><br>打印 <code>jit.matrix</code> 的内容</p><p>在 <code>jit.matrix</code> 下面有一个新的 Jitter 对象：<code>jit.print</code>。它在入口处接收矩阵名称（<code>jit_matrix</code> 消息）并格式化矩阵的值，以便在 Max Console 中打印。它将格式化的值打印到 Max Console，就像 Max 的 <code>print</code> 对象一样，然后在 <code>jit_matrix</code> 消息中以矩阵名称的形式传递出来。</p><p>单击标记为 “output” 的按钮，这会让 <code>jit.matrix</code> 传递矩阵名称给 <code>jit.print</code>，后者格式化值并在 Max Console 中显示：<code>jit_matrix [somename]</code>。左边的单词表示这是由 <code>jit.print</code>  对象打印的，这是 <code>jit.matrix</code> 出口的结果。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/max%20console.png" alt=""></p><p>因为我们没有指定矩阵的名称（没有指定 <code>jit.matrix</code> 的第一个输入参数），所以 <code>jit.matrix</code> 自己会生成唯一名称（类似 “u330000007”）。这里我们并不关心名称是什么，但它能够告诉 <code>jit.print</code> 对象要显示哪个矩阵的数据。</p><p>上图显示了来自 <code>jit.print</code> 矩阵中的所有值，按 16 列和 12 行整齐排列。它们现在都是 0，因为我们还没有在矩阵中填充任何内容。</p><h2 id="在矩阵中设置和查询值"><a href="#在矩阵中设置和查询值" class="headerlink" title="在矩阵中设置和查询值"></a>在矩阵中设置和查询值</h2><p>在<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">上一章</a>中，我们知道如何使用 QuickTime 视频中的彩色数据帧自动填充整个矩阵。还可以将数值放置在矩阵的特定单元格中，并从特定位置检索。</p><p>在下面的例子中，<code>jit.matrix</code> 上方有一些消息框，可以设置和获取矩阵中的值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02c.png" alt=""><br>消息 setcell 和 getcell 可以访问矩阵中的特定值</p><p>使用 <code>setcell</code> 消息可以在特定的矩阵位置中存储值。语法是： <code>setcell [cell coordinates] val [value（s）]</code>。</p><p>例如， <code>jit.matrix</code> 消息 <code>setcell 0 0 val 127</code> 会将矩阵的第一个单元格（即左上角的单元格）的值设置为 127。每个维度中对单元格坐标的编号从 0 开始，最大值比维度小 1。在此矩阵中，x 维度中的位置编号为 0~15，y 维度中的位置编号为 0~11。因此右下角的单元格坐标是 15 11.</p><p><code>pack 0 0 0</code> 对象组合多个数字提供给<code>setcell</code> 消息发送给 <code>jit.matrix</code>。首先设置想要存储值的 x 和 y 位置，然后指定要存储在那里的值。当 x 和 y 位置为 0 0 时，用标有“value” 的数字框发送 127 到 <code>pack 0 0 0</code> 的左侧入口。这将触发消息 <code>setcell 0 0 val 127</code> 发送给  <code>jit.matrix</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02d.png" alt=""><br>消息 <code>setcell 0 0 val 127</code> 设置单元位置 0,0 的值为 127</p><p>（如果矩阵中有多个平面，可以在单元格的特定/所有平面中设置值）</p><p>为了演示之前提过的单元格位置编号，现在尝试将消息 <code>setcell 15 11 val 255</code> 发送到 <code>jit.matrix</code>。在 “X position” 下面的数字框输入 15，在 “Y position” 下面的数字框输入 11 ，在 “value” 下面的数字框输入 255。然后点击 “output” 按钮查看矩阵的变化。<code>jit.print</code>在 Max 控制台中打印出整个矩阵。请注意，单元格位置 0,0 和 15,11 中的值已变为 127 和 255。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02e.png" alt=""><br>消息 <code>setcell 15 11 val 255</code>将单元格位置 15,11 的值设置为 255</p><p>在 Patch 窗口中，你可能已经注意到黑色矩形区域的变化。它的左上角和右下角已经改变了。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02f.png" alt=""><br><code>jit.pwindow</code> 对象显示的数值为颜色（或灰度值）</p><p>该区域是一个名为 <code>jit.pwindow</code> 的用户界面对象。在添加对象面板中可以找到它：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02g.png" alt=""><br>对象选项板中的 <code>jit.pwindow</code> 图标</p><p>在添加对象面板中单击或将其拖动到 patch 窗口时，它会创建一个小的矩形对象（可以拖动对象右下角调整尺寸）。它在功能上与 <code>jit.window</code> 非常相似，区别是它在 Patch 窗口中显示矩阵数据，而不是在一个单独的窗口。</p><p>于是我们看到数值显示为颜色（char 数值范围是 0~255）。矩阵中只有一个平面，所以是单色（即灰度）。0 表示黑色，其他值是某种灰度，最大值255 是白色。因此，单元格 15,11 的 255 值显示为白色，0,0 的 127 值显示为黑色和白色之间的 50％ 灰色。</p><p>你可能会觉得这样填充矩阵相当繁琐。没错。所以 Max 允许我们编写程序来自动填充。</p><h2 id="以算法方式填充矩阵"><a href="#以算法方式填充矩阵" class="headerlink" title="以算法方式填充矩阵"></a>以算法方式填充矩阵</h2><p>双击 <code>patcher  fillmatrix</code> 对象打开子 patch。它将不同的数字传入数学表达式，生成 192 个不同的值到矩阵中的每个单元。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02h.png" alt=""><br>通过算法生成值来填充矩阵的单元格</p><p>当 <code>uzi 12</code> 对象收到 <code>bang</code>（点击主 Patch 窗口中标记为 “fill” 的按钮）时，它会快速从右侧出口进行 1 到 12 计数，并向左侧出口发送每个计数的 bang。</p><p>那些 bang 触发了<code>uzi 16</code>对象，因此它每次都会发出 1~16 的数字。然后把这些数字减去 1，这样值的范围就限定在 0~11 和 0~15，输出的结果作为矩阵中的 y 和 x 位置。对于 12 个 y 位置中的每一个，<code>uzi 16</code>对象指定所有 x 位置，然后在数学表达式（expr）中使用这些数字来计算要存储在该位置的值。这些数字从 outlet 发送给主 patch 创建定义好的 <code>setcell</code> 消息，就像我们之前手动做的那样。</p><p>这里不需要关注具体的数学表达式。它可以生成任何公式。刚才我们用一个公式在每列中产生亮度的正弦梯度，这将让列的整体亮度从左向右增加（即随 x 增加）。</p><p>关闭 <code>patcher fillmatrix</code> ，然后单击标记为 “fill” 的按钮。矩阵在 Max 的 scheduler 的每个时钟节拍中填充值（由子 patch 中的 uzi 对象生成）。现在单击标有 “output” 的按钮查看矩阵的内容。数值将打印在 Max Console 中，并显示在 <code>jit.pwindow</code> 中。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/max%20console%20fill.png" alt=""></p><p>即使对于像 16x12 这样的小型矩阵，仅仅查看 Max Console 中的数字打印输出，我们很难看到数值数据的趋势。而 <code>jit.pwindow</code> 中的显示能够清楚而直观地展示值在矩阵中的变化情况。这是数据可视化的好处。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/output%20display.png" alt=""></p><p>你可以想象在 Max 中以算法方式填充矩阵的其他方法，我们将在后面的教程中演示。</p><h2 id="jit-matrix-可以响应的其他消息"><a href="#jit-matrix-可以响应的其他消息" class="headerlink" title="jit.matrix 可以响应的其他消息"></a>jit.matrix 可以响应的其他消息</h2><p><code>jit.matrix</code> 还可以接收许多其他消息。例如可以使用相同的值填充所有 <code>jit.matrix</code>。发送给<code>jit.matrix</code> 的 <code>clear</code>消息将所有值设置为 0，<code>setall</code> 消息（setall 后跟一个值）将矩阵中的所有单元设置为同一个值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02i.png" alt=""><br>查询矩阵位置 8,6 处的值; 报告单元格 8 6 val [value(s)]</p><p>还有 <code>getcell</code>消息。单词 <code>getcell</code> 后跟矩阵中的位置（x和y）会让 <code>jit.matrix</code> 将单元格坐标和该位置的值发送到右侧出口。</p><p>在 <code>getcell $1 $2</code> 消息框上方的数字框中输入 y 值，然后输入 x 值，并观察 Max Console 中打印的内容。请注意，该矩阵位置的值在 <code>jit.matrix</code> 的右侧出口输出。</p><p>在后面的教程中，你将看到从矩阵中检索值的各种方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.matrix</code> 对象可以为任何尺寸、平面数和数据类型的矩阵数据创建存储空间。该矩阵可以填充来自另一个 Jitter 对象（例如 <code>jit.movi​​e</code> ）的数据，或者用 <code>setall [value]</code>之类的消息来设置所有单元格中的值，或者 <code>setcell [position] val [value（s）]</code>来设置特定单元。可以使用 patch 中其他位置的算法根据公式或一组规则来填充矩阵。</p><p>要获取特定单元格中的数据，可以使用 <code>getcell [position]</code>消息。要查看在 Max Console 中打印的所有数值数据，请使用 <code>jit.print</code> 对象格式化矩阵数据并打印。要查看显示为颜色的矩阵数据，请使用 <code>jit.pwindow</code> 对象。这类似于<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">教程1</a>中演示的 <code>jit.window</code> 对象。</p><p>在本教程中，我们查看了自己生成的数据，而不是上一篇中的数字视频。两种情况下的存储原理是相同的。无论矩阵是存储来自数字视频帧的每个像素的颜色信息，还是表示颜色的数字，它们都存储在二维矩阵中，并且通过 <code>jit.window</code> 或 <code>jit.pwindow</code> 显示。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译03 - 播放 QuickTime 视频</title>
    <link href="http://uegeek.com/180825-jitter-03.html"/>
    <id>http://uegeek.com/180825-jitter-03.html</id>
    <published>2018-08-24T16:05:34.000Z</published>
    <updated>2018-08-29T13:22:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-3.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter01" target="_blank" rel="noopener">Tutorial 1: Playing a QuickTime Movie</a></p></blockquote><p>这个教程教你使用 Jitter 执行最简单但最有用的任务之一：在窗口中播放 QuickTime 视频。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01a.png" alt=""><br>打开 QuickTime 电影文件</p><p>这个 Patch 中有两个 Jitter 对象：<code>jit.movi​​e</code> 和 <code>jit.window</code>。<code>jit.window</code> 会自动打开电脑屏幕上的窗口。<code>jit.movi​​e</code> 则打开 QuickTime 视频并开始播放。</p><p>单击 <code>read countdown.mov</code> 的消息框，<code>jit.movi​​e</code> 就会打开 QuickTime 视频文件 countdown.mov 并开始读取。</p><p>默认情况下，<code>jit.movi​​e</code> 会在打开文件后立即播放。但是请注意，即使 <code>jit.movi​​e</code> 对象正在播放电影，窗口中却没有显示，因为：</p><p>Jitter 中的每个对象都执行特定任务——可能非常简单，也可能相当复杂。播放 QuickTime 视频实际上被分解为两个任务：</p><ol><li>从硬盘上的文件中将每帧视频数据读入 RAM</li><li>获取 RAM 中的数据，并将其显示为屏幕上的彩色像素</li></ol><p>第一个任务由 <code>jit.movi​​e</code> 执行，第二个任务由 <code>jit.window</code> 执行。为了让 <code>jit.window</code> 知道要显示什么，这两个对象需要进行通信。</p><h2 id="Jitter-对象如何通信"><a href="#Jitter-对象如何通信" class="headerlink" title="Jitter 对象如何通信"></a>Jitter 对象如何通信</h2><blockquote><p>重要概念：Jitter 对象相互通信的关键是<strong>矩阵的名称</strong> —— 它指定了数据在内存中的位置。Jitter 对象输出其他 Jitter 对象能理解的消息（<code>jit_matrix</code>，后跟空格和存储数据的矩阵名称）。此消息通过接线在对象之间传递。</p><p><strong>接收的对象从入口接收消息，从内存中的指定位置获取数据，以某种方式修改数据，并发送修改后的名称数据，输出到对象的左侧出口。</strong></p><p>这样每个对象查看内存中相应的位置来获取所需的数据，执行各自的任务，而不必知道其他对象正在做什么。大多数 Jitter 对象只有从另一个对象获取 jit_matrix 消息，得知该查看相应的矩阵，才会对那里的数据做一些事情。</p></blockquote><p>在多数情况下，Jitter 对象自己会生成唯一的名称。你也可以指定名称（最好是这样）。显式地命名矩阵，不同对象就可以使用相同的内存空间。</p><h2 id="由-Jitter-对象触发动作"><a href="#由-Jitter-对象触发动作" class="headerlink" title="由 Jitter 对象触发动作"></a>由 Jitter 对象触发动作</h2><p>是什么让一个 Jitter 对象将 <code>jit_matrix</code> 消息发送给另一个对象呢？大多数 Jitter 对象在收到消息 <code>outputmatrix</code> 或 <code>bang</code> 时，会发出 <code>jit_matrix</code> 消息。另外，一个对象收到消息并修改了数据后，它会自动发出一条 <code>jit_matrix</code> 消息，通知其他包含相同矩阵名称的对象。</p><p>也就是说，当一个对象收到 <code>jit_matrix</code> 消息时，它会做一些事情并发出自己的 <code>jit_matrix</code> 消息。当一个对象收到 <code>outputmatrix</code> 或 <code>bang</code> 时，它会发送一个 <code>jit_matrix</code> 消息，而不做任何其他事情。</p><p>因此在示例中，<code>jit.movi​​e</code> 对象正在播放 QuickTime 视频，不断存储当前的视频帧，但 <code>jit.window</code> 对象只会在从 <code>jit.movi​​e</code> 对象接收到 <code>jit_matrix</code> 消息时显示内容。只有当 <code>jit.movi​​e</code> 收到消息<code>bang</code>（或 outputmatrix）时才会发生这种情况。那时，<code>jit.window</code> 将显示当前正在电影中播放的任何视频帧。</p><p>为了使 <code>jit.window</code> 以一定速度更新并不断显示视频帧，就需要以同样的速度发送 <code>bang</code> 消息给 <code>jit.movi​​e</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01b.png" alt=""><br>视频在 jit.movi​​e 中播放，每当要显示一帧时都要发送 bang 消息</p><ul><li>单击标记了 play 的开关，<code>metro</code> 对象就会启动。这将以每秒 25 次（每 40 毫秒）的速度发出 <code>bang</code> 消息。这个速度足以显示该视频的每一帧。只要 <code>bang</code> 继续，我们就能看到窗口中显示的视频。</li></ul><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01c.png" alt=""><br>jit.window 显示矩阵的内容</p><ul><li><p>点击开关停止 <code>metro</code>。<code>jit.window</code> 对象停止更新电影窗口，现在只会看到最后显示的静止图像。电影仍在播放 - <code>jit.movi​​e</code> 仍在逐帧更新内存 - 但 <code>jit.window</code> 会忽略这些更新，因为 <code>jit.movi​​e</code> 不再发送消息。</p></li><li><p>你可以单击 <code>metro</code> 下方的按钮，来验证电影是否仍在播放。这会让 <code>jit.movi​​e</code> 将 <code>jit_matrix</code> 消息发送到 <code>jit.window</code>，当前帧会更新 Movie 窗口。连续点几次，会看到电影在鼠标点击之间有变化。</p></li></ul><p>总而言之，<code>jit.movi​​e</code> 以视频正常速率逐帧读取 QuickTime 文件的一帧。当 <code>jit.movi​​e</code> 收到 <code>bang</code> 消息时，会将该数据的位置传达给 <code>jit.window</code>，然后 <code>jit.movi​​e</code> 收到 <code>bang</code> 时所包含的任何帧都由 <code>jit.window</code> 显示出来。</p><h2 id="对象中的参数"><a href="#对象中的参数" class="headerlink" title="对象中的参数"></a>对象中的参数</h2><p>本教程中的 <code>jit.movi​​e</code> 的两个参数 320 和 240，指定了对象在内存中保留单帧视频时的宽度和高度。它会声明足够的 RAM 来存储这些帧。因此，使用 read 消息输入希望读入的视频的尺寸是 ok 的。这样我们知道 QuickTime 视频的尺寸是 320x240。</p><p>如果输入的维度小于读入的视频的尺寸，<code>jit.movi​​e</code> 没法声明足够的存储空间，就不得不忽略每帧的一些像素。相反，如果输入的维度大于读入的视频尺寸，则每一帧中都没有足够的像素来填充已分配的内存空间，因此 <code>jit.movi​​e</code> 会平均分发数据，并用重复数据填充空余的内存。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01b.png" alt="">    </p><p><code>jit.window</code> 对象有五个输入的参数：<code>Movie 5 41 325 281</code>。第一个参数是 <code>jit.window</code> 显示的矩阵的名称。它也会出现在视频窗口的标题栏中。它可以是任何单词（用引号括起来的话，可以是多个单词）。接下来的两个参数，表示视频窗口显示区域左上角的 x，y 屏幕坐标，后两个参数是显示区域右下角的坐标（左-上-右-下）。选择了这些数字是因为</p><ul><li>它们定义了一个 320x240 的显示区域，与视频尺寸相同</li><li>当考虑操作系统默认的窗口边框、标题栏和菜单栏的尺寸时，窗口刚好隐藏在桌面的左上角。（当然也可以设置标题栏不显示）</li></ul><p>输入 <code>metro</code> 的参数 40，使其每秒发出 25 次 <code>bang</code>消息。QuickTime 视频的帧速率是每秒24帧，因此这个 <code>metro</code> 持续触发 <code>jit.movi​​e</code> 对象，确保每帧都能显示。</p><p>要播放 QuickTime 视频，请使用 <code>jit.movi​​e</code> 打开文件并将视频的连续帧读入 RAM，然后使用 <code>jit.window</code> 在单独的窗口中显示视频。使用输入的参数指定视频的尺寸，以及屏幕上显示区域的精确坐标。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Jitter 对象通过相互发送矩阵的名称，来传递特定视频帧的信息——该信息在内存中的位置。 Jitter 对象获得矩阵名称时，它使用该位置的数据执行指定的任务，然后将修改后的数据名称，发送给其他 Jitter 对象。几乎所有 Jitter 对象在收到<code>bang</code>消息 （或 outputmatrix）时都会发出一个名称（包含在<code>jit_matrix</code>消息中）。因此，为了显示视频的连续帧，以某个速率向 <code>jit.movie</code> 发送 <code>bang</code> 消息，然后​​连接到<code>jit.window</code>显示。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01d.png" alt=""><br>跟踪每个对象的消息和角色</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译02 - Jitter 对象的属性(attributes)</title>
    <link href="http://uegeek.com/180822-jitter-02.html"/>
    <id>http://uegeek.com/180822-jitter-02.html</id>
    <published>2018-08-22T09:20:13.000Z</published>
    <updated>2018-08-29T13:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title2.jpg" alt=""></p><a id="more"></a><p><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></p><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter00b_whatareattributes" target="_blank" rel="noopener">Attributes: Editing Jitter object parameters</a></p></blockquote><p>属性是指定 Max 对象行为的方法。大多数 Jitter 对象使用属性来指定当前状态的变量。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_a.png" alt="">            </p><p>许多 Max 对象使用多个参数来确定行为。对象名称后面的这些参数的顺序，决定了对象如何解析它们。在上面的例子中，<code>counter</code> 的第一个参数设置了计数的方向；第二个和第三个参数确定最小值和最大值。</p><p>这些值都是数字，参数个数可能会影响对象的行为，所以它们的顺序很重要。如果 <code>counter</code> 只有两个参数，它们会作为最小和最大值，而不是方向和最小值。参数的位置和数量最为关键，在 <code>counter</code> 的例子中，如果只有两个参数，就没办法创建能够指定方向和最大值的 <code>counter</code> 对象。</p><p>给定的对象参数，通常被视为初始值，可以从其他入口或发送特殊消息给对象来修改这些值。例如，分别发送整数到第 2 个和第 5 个入口，来更改 <code>counter</code> 对象的方向和最大值，它们会替代默认值。同样，你可以向左入口发送消息 <code>min</code> 后跟一个整数，来更改对象的最小值。</p><p>当 Max 对象只有两、三个参数时，天下太平。但是 Jitter 对象通常有很多很多变量（甚至几十个）。如果所有变量都依赖于入口和对象参数的顺序，那么光看文档就够你忙的……</p><h2 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h2><p>与 Max 对象不同，Jitter 对象可以用<strong>属性</strong>来设定行为。将属性与 Jitter 对象的名称一起输入对象框，或者在创建对象后用消息设置（和检索）属性：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_b.png" alt=""><br>具有对象名称后的属性的Jitter对象</p><p>上面是 <code>jit.brcosa</code> 的例子，它有三个属性。使用 <code>@ 符号 + 属性名称 + 一个或多个参数</code>（可以是任意数​​据类型：int，float，symbol 或 list），在对象框中设置属性。</p><p>可以在对象的名称之后，以任意顺序输入个数不限的属性。你可能不知道 <code>jit.brcosa</code> 对象的功能，但可以根据属性的名称以及数据类型来推断。</p><blockquote><p>提示：@符号与属性名称之间没有空格</p><p>同样重要的是：Jitter 对象可以同时具有输入的属性和输入的参数。请参阅下面的 Jitter 对象参数 部分。</p></blockquote><p>与 Max 对象一样，创建 Jitter 对象并设置初始值以后，可以向对象发送消息随时更改这些属性值：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_c.png" alt=""><br>使用 Max 消息更改属性</p><p><code>jit.brcosa</code> 对象的亮度属性初始值为 0.5（在对象框中输入 <code>@brightness 0.5</code>），然后可以发送消息 <code>brightness [float]</code>到对象的左入口来更改。发送带有属性名称的消息（后跟相关参数）到 Jitter 对象的左入口，就可以更改几乎任何属性。</p><p>与 Max 对象一样，Jitter 对象有参数的默认值。上面的 <code>jit.brcosa</code> 对象只设置了亮度的初始值，其他属性都使用默认值。在上面的示例中，使用消息更改对象的对比度(contrast)和饱和度(saturation)属性的值，从而替换对象的默认值。</p><p>下面说明如何设置对象的属性值。</p><h2 id="Jitter-对象参数"><a href="#Jitter-对象参数" class="headerlink" title="Jitter 对象参数"></a>Jitter 对象参数</h2><p>大多数 Jitter 对象有四种<code>输入属性</code>或<code>输入参数</code>。实际上它们都是属性，只不过 Jitter 对象会自动判断应该用作属性还是参数。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_d.png" alt=""><br>Jitter 对象也可以有参数</p><p>上面 <code>jit.rota</code> 对象有两个初始化的属性：<code>anchor_x</code> 和 <code>anchor_y</code>。但其他数字是什么意思呢？</p><p>如果 Jitter 对象处理的是矩阵数据，则参数将被理解为：</p><ol><li>输出矩阵的 planecount</li><li>输出矩阵的类型</li><li>输出矩阵的大小或维度</li></ol><p>现在我们知道，上面的 <code>jit.rota</code> 对象将输出一个由 4 个 char（8位整数）数据平面组成的矩阵，每个平面的维度是 320x240。</p><blockquote><p>注意：如果要指定 Jitter 对象的参数，参数必须出现在任意属性之前。否则 Jitter 对象会将参数误解为属性的值，而不是对象的参数。</p></blockquote><p>所有可以输出矩阵数据的 Jitter 对象，都有几个共同的属性，它们可以设置参数：<strong>planecount，type 和 dim</strong>。可以通过输入属性（不需要指定顺序），也可以用消息触发更改。例如，下面的三个对象是等价的：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_e.png" alt=""><br>参数或属性？你来定</p><ul><li>第一个对象的输出矩阵，直接使用<code>输入的参数</code>来设置。</li><li>第二个对象使用<code>输入的参数</code>设置了 <code>planecount</code> 和 <code>type</code>，但使用了<code>输入的属性</code>设置了 <code>dim</code> 的数量。</li><li>第三个对象使用<code>输入的属性</code>来设置所有内容。</li></ul><p>你也可以用 <code>loadbang</code> 对象触发的消息来初始化对象属性：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_f.png" alt=""><br>另一种初始化属性的方法</p><h2 id="查询属性和对象状态"><a href="#查询属性和对象状态" class="headerlink" title="查询属性和对象状态"></a>查询属性和对象状态</h2><p>查找对象属性设置的最快方法，是查看检查器（inspector）。选中对象，按 <code>cmd/alt + i</code> 或单击右侧工具栏上的 i 图标就可以打开。在窗口底部附近可以找到当前属性设置。</p><p>属性的另一个功能是显示 Jitter 对象属性的当前值。用一个 <code>get</code> 开头的消息，紧跟想要查询的属性名（与get之间没有空格）来触发。比如下图的 <code>getdim</code> 可以触发动作，获取 <code>jit.grab</code> 对象的 dim 当前参数。结果值由 Jitter 对象以消息形式从右输出口输出（以属性的名称 dim 开头）。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_g.png" alt=""><br>查询 Jitter 对象的属性</p><p>使用 <code>get</code> 可以查询出属性的当前值，即使之前从未设置过。例如，下面的 patch 获取了 <code>jit.plur</code> 对象的一些默认值。用 <code>route</code> 对象可以轻松分离每个属性的值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_h.png" alt=""><br>获取属性的默认值</p><p><strong>你可以发送给任何 Jitter 对象<code>getattributes</code> 和 <code>getstate</code> 消息，来获得对象的所有属性。</strong></p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_i.png" alt="">        </p><p><code>getAttributes</code> 消息令 Jitter 对象输出它包含的所有属性列表。查看几个 Jitter 对象，很快就会发现几个频繁出现的属性（例如outputmode，type 和 dim）。其他（例如 jit.brass 对象中的 mask）则是某些对象独有的。</p><p><code>getstate</code> 消息可以一次性输出 Jitter 对象所有属性的值：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_j.png" alt=""><br>查询对象的状态</p><p>这样我们就可以用 <code>route</code>，<code>unpack</code>和其他对象来按需查找属性值了。在后续的教程中会遇到几个 Jitter 对象，其属性基于输入矩阵（或被对象打开的文件）执行的计算而更改。想要找出对象计算结果，就需要查询相关属性值。</p><h2 id="ATTR"><a href="#ATTR" class="headerlink" title="ATTR"></a>ATTR</h2><p>你还可以使用 <code>attrui</code> 对象读取属性值。这是一个 UI 控件，它与对象的入口是双向连接的。<code>attrui</code> 对象有两个部分，左边部分是所有可用的属性的下拉菜单。选择属性后，右侧会显示属性的当前值，并可编辑。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_k.png" alt=""><br>查找对象的状态</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Jitter 对象的属性，让我们可以很好地管理复杂的对象参数。你可以使用属性来初始化、更改和查找存储在 Jitter 对象中的当前值。直接在属性名称后赋值，就免去了记忆参数功能和顺序的麻烦。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p><hr><p>MakeNoise 系列</p><ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li><li><a href="https://www.uegeek.com/180703-make-noise-08.html" target="_blank" rel="noopener">MakeNoise08 - 振荡器和滤波器</a></li><li><a href="https://www.uegeek.com/180706-make-noise-09.html" target="_blank" rel="noopener">MakeNoise09 - 压缩 Compression</a></li><li><a href="https://www.uegeek.com/180708-make-noise-10.html" target="_blank" rel="noopener">MakeNoise10 - 延时和混响 Delay &amp; Reverb</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译01 - 什么是矩阵？</title>
    <link href="http://uegeek.com/180821-jitter-01.html"/>
    <id>http://uegeek.com/180821-jitter-01.html</id>
    <published>2018-08-21T15:57:01.000Z</published>
    <updated>2018-08-29T13:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title1.jpg" alt=""></p><a id="more"></a><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档： <a href="https://docs.cycling74.com/max7/tutorials/jitterchapter00a_whatisamatrix" target="_blank" rel="noopener">What is a Matrix?</a></p></blockquote><p>矩阵即网格，网格的每个格子都包含一些信息。例如，棋盘是一个矩阵，每个方格包含特定的信息：有某个棋子，或没有棋子。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_a.png" alt=""></p><p>方便起见，假设矩阵中每个格子的「信息」都是数字。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_b.png" alt=""><br>电子表格是二维矩阵</p><p>水平的数据组称为<code>行</code>，垂直的数据组称为<code>列</code>。在路线图、棋盘或电子表格中，通常会使用字母和数字标记行和列，这样就可以表示任意一个单元格的位置。在上面例子中，单元格 C3 的数值为 0.319。</p><p>上面的矩阵例子是二维的——宽度和高度。在 Jitter 中，矩阵维度范围在 1~32 维之间。（一维矩阵对应编程中的数组 array。Max 中有一些对象用于存储数组，例如 <code>table</code> 和 <code>multislider</code>。不过有时候 Jitter 中的一维矩阵更适用）虽然在纸上描绘起来有点困难，但我们仍然可以想象一个有宽度/高度/深度的立方体三维矩阵。（例如，矩阵宽/高/深 分别有 3 个单元，总共 3x3x3 = 27个单元）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_c.png" alt=""></p><p>一个 3x3x3 维矩阵共有 27 个单元</p><p>四维或更高维度的矩阵，相当挑战我们的视觉想象力和描述能力，但它们确实存在。</p><h3 id="视频屏幕作为矩阵"><a href="#视频屏幕作为矩阵" class="headerlink" title="视频屏幕作为矩阵"></a>视频屏幕作为矩阵</h3><p>视频屏幕由微小的单个像素组成，每个像素都显示特定的颜色。在计算机显示器上，屏幕的分辨率通常是 1024 像素宽，768 像素高，也可能是800x600 或 640x480。在电视监视器中，分辨率大约为 640×480。上述屏幕的宽高比为 4:3。</p><p>在较宽的 DV 格式中，宽高比为3:2，图像通常为 720x480 像素。高清晰度电视（HDTV）指定了另一种宽高比 16:9。在教程中通常使用 4:3 的宽高比，最常见的尺寸小于 320x240 甚至 160x120，这样可以节省 Max patch 的大小。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_d.png" alt=""></p><p>常见的像素尺寸</p><p>单帧标准视频由 640×480 = 307,200 个像素组成。每个像素显示一种颜色。为了用数字表示眼睛可分辨的像素的颜色，我们需要范围非常大的颜色值。</p><p>用数字表示颜色值有许多方式。描述计算机中每个像素颜色的标准方法，是将颜色分解为红色、绿色和蓝色（也称为RGB），以及透明度（称为Alpha通道）。因此，大多数计算机程序将单个像素的颜色，存储为四个单独的数字，分别表示 α，红色，绿色和蓝色。这种四通道颜色表示方案通常称为 ARGB 或 RGBA。</p><p>Jitter 也遵循这个惯例。为了使矩阵的每个单元表示一个颜色像素，每个单元都包含四个数值（α/红/绿/蓝）。因此存储视频帧数据的矩阵，实际上在每个单元格中包含四个数值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_e.png" alt=""><br>矩阵的每个单元格包含多个数字</p><p>因此，视频帧在 Jitter 中是二维矩阵，每个单元表示帧的像素，并且每个单元包含 α/红/绿/蓝 四个值，范围从 0 到 255。为了区分多单元格与矩阵维度的概念，Jitter 引入了平面(plane)的概念。</p><h3 id="什么是-plane？"><a href="#什么是-plane？" class="headerlink" title="什么是 plane？"></a>什么是 plane？</h3><p>为矩阵中的数字分配内存时，Jitter 需要知道每个维度的范围 - 例如，320x240 - 以及每个单元格中要保存的值的数量。为了跟踪单元格中的不同值，Jitter 把<strong>单元格看做位于某个单独平面上，因此我们将视频帧视为四个数据平面的二维矩阵</strong>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_f.png" alt=""></p><p>矩阵每个单元中的值存在于四个虚拟平面上</p><p>使用这个概念框架，我们可以在需要时单独处理每个平面（以及颜色信息的每个通道）。例如，想要增加图像的红色，只需增加矩阵红色平面中的所有值，保持其他值不变。</p><p>一般在 Jitter 中用四个矩阵的数据-α/红/绿/蓝的 表示视频。这些平面的编号从 0 到 3，因此 Alpha 通道位于平面 0 中，RGB 通道位于平面 1,2 和 3 中。</p><h3 id="矩阵中的数据"><a href="#矩阵中的数据" class="headerlink" title="矩阵中的数据"></a>矩阵中的数据</h3><p>计算机用不同格式来存储数字。如果知道想要存储的数字类型，就可以仅为每个数字分配真正需要的空间来节省内存。例如，用 ASCII 0~255 存储字母字符，只需要 8 位（2 的 8 次方）的空间来存储每个字符。如果想要存储更大范围的数字，可能会使用 32 位（包含的整数范围从 -2,147,483,648 到 2,147,483,647）。为了表示带小数部分的数字，例如 3.1416，我们使用浮点数二进制系统，32 位或 64 位数字的某些位表示值的尾数，其他位表示指数。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/main-qimg-0c6f60196dbaaaa7a2f9178fff29d64d-c.jpg" alt=""></p><p>用 Max 编程的大多数情况下，不需要知道 Max 如何存储数字。但是用 MSP 处理数字音频时，最好了解 MSP 什么情况下使用浮点数（如果不小心用整数替代了浮点数，程序可能会报错）。在 Jitter 中，了解计算机的存储类型非常有帮助。</p><p>Jitter 矩阵可以将数字存储为 64 位浮点（也称为双精度浮点或双精度），32 位浮点（简称浮点数），32 位整数（称为long int，或者只是int）和 8 位字符（称为char）。某些 Jitter 对象仅以一种格式存储，因此不必指定存储类型。但是其他 Jitter 对象允许多种方式存储，因此必须指定数据类型为 char / long / float32 / float64 等。</p><blockquote><p>重要概念：在使用 Jitter 操作视频时，需要了解矩阵中数据存储的知识。矩阵默认以 ARGB 格式保存视频数据，每个单元的数值范围是 0~255 （一般在四个平面中）。最常见的数据存储类型是 char，并不是因为存储的是字符。最常存储的值通常是数字，只需要 256 个不同的可能值来表示，因此 8 位的 char 就足够了。视频数据量一般较大，所以 Jitter 中大多数矩阵对象默认使用 char 存储类型，以减少存储空间。对于单色（灰度）图像或视频，单个 char 数据平面就足够了。</p></blockquote><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p><hr><p>MakeNoise 系列</p><ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li><li><a href="https://www.uegeek.com/180703-make-noise-08.html" target="_blank" rel="noopener">MakeNoise08 - 振荡器和滤波器</a></li><li><a href="https://www.uegeek.com/180706-make-noise-09.html" target="_blank" rel="noopener">MakeNoise09 - 压缩 Compression</a></li><li><a href="https://www.uegeek.com/180708-make-noise-10.html" target="_blank" rel="noopener">MakeNoise10 - 延时和混响 Delay &amp; Reverb</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>破解 AI 时代的焦虑 —— 从人机交互到人机协同创作</title>
    <link href="http://uegeek.com/180717-human-computer-symbiosis.html"/>
    <id>http://uegeek.com/180717-human-computer-symbiosis.html</id>
    <published>2018-07-17T15:11:58.000Z</published>
    <updated>2018-08-22T09:40:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.001.jpeg" alt=""></p><a id="more"></a> <p>这是 4 月做的一次分享。大概是我做过的分享中，现场讨论气氛最热烈的一次了。</p><p>最近抽空整理成文章，希望大家可以继续讨论这个有趣、有争议的话题。</p><p>为什么分享这个话题呢？</p><p>我做了好多年交互设计的工作，所以学习和工作一直有一个离不开的主题——人机交互（Human-Computer Interaction）。</p><h2 id="人机关系的演进"><a href="#人机关系的演进" class="headerlink" title="人机关系的演进"></a>人机关系的演进</h2><p>什么是人机交互？我把它简单理解为：</p><blockquote><p>人如何与机器或是某个复杂系统的沟通和互动过程。</p></blockquote><p>更为完整的版本，请看我在知乎上的回答 <a href="https://www.zhihu.com/question/19788122/answer/119319267" target="_blank" rel="noopener">什么是交互设计？</a></p><p>比如，鼠标就是一个解决人和机器互动问题的经典产品。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.003.jpeg" alt=""></p><p>现在大家都觉得鼠标再平常不过了，但是在当年，Douglas Engelbart 的这一项发明，极好地解决了人们在图形化计算机界面操纵屏幕元素的问题。为了表彰这项发明以及在人机交互领域的开拓式贡献，Douglas Engelbart 在 1997 年获得了「计算机界的诺贝尔奖」——图灵奖。</p><blockquote><p>For an inspiring vision of the future of interactive computing and the invention of key technologies to help realize this vision. – Turing Award Citation</p></blockquote><p>人和机器的对话、交互一直在演进。这也从一个侧面反映了人创造工具的历史：</p><p><img src="http://killerinfographics.com/wp-content/uploads/2014/12/DickiesIGjess.edits12-211.jpg" alt=""></p><p>人创造的工具越来越多样、复杂、强大。想想看，今天我们在手机上能完成多少事情。</p><p>于是，有人慢慢感到这种发展速度似乎不大对劲……奇点要来了，AlphaGo 也出现了。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/human-progress.png" alt=""></p><p>随着深度学习热潮的演进，大家发现，以前为了让机器智能化而不得不做的很多工作，比如，符号化、标准化、模块化、输入大量专家知识、需要庞大的训练数据集、要做苦脏累的特征工程等等，现在都简化了。基本上，只要目标足够清晰、可操作，训练数据和计算资源足够，机器学习产生的结果就可以满足要求。</p><p>我个人也经历了一次切身的体验。</p><p>今年年初在上 Udacity 的 <a href="https://github.com/kidult00/deep_learning_nanodegree_projects" target="_blank" rel="noopener">Deep Learning Nano Degree 课程</a>的时候，最后一个实践项目，是基于人脸图像库，用生成对抗网络（GAN）算法自动生成人脸。</p><p>虽然在学习过程中，早已对算法能实现的结果有所预期。但是当我把程序放到 AWS 的 GPU 上面跑了不到二十分钟，看到结果时还是忍不住隐隐感到机器的强大和压迫。</p><p>这是最开始几个训练迭代生成的模糊不清的轮廓：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/face-gen-before.png" alt=""></p><p>这是十几分钟训练结束后生成的人脸：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/face-gen-after.png" alt=""></p><p>说一点儿都不焦虑是假的。</p><p>何况各种媒体还铺天盖地强化这种焦虑，今天是一百零八种会被机器取代的工作，明天是哪个比赛机器又战胜了人……</p><p>于是大家经不住会问：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.010.jpeg" alt=""></p><p>似乎只有像诗词、小说、爵士乐、即兴表演这些领域，机器看起来就是不太擅长。</p><p>但，也不好说。</p><p>Paul 是一个专门给人画肖像画的机器。从 2011 年至今已经创做了非常多的作品。看起来非常有艺术感，不是吗？</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.011.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/emoji-desperate.png" alt=""></p><p>有时候在焦虑之余，又忍不住会想：这种焦虑到底从何而来？</p><p>如果看过莱考夫「我们赖以生存的隐喻」的同学都知道，隐喻 Metaphor 对我们的影响有多么大。仔细想想，感到机器的威胁，是不是也源于人机关系的一些基本隐喻？</p><p>我们基本上都是以一种对立或一分为二的方式来看待这些基本词汇：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.014.jpeg" alt=""></p><p>看到这些词汇，我们会下意识地觉得它们是对立关系。逻辑、精确、冰冷的工程思维，怎么跟想象、感性、个性、创作融为一炉呢？</p><p>这大概就是问题所在了。</p><h2 id="隐喻和可能"><a href="#隐喻和可能" class="headerlink" title="隐喻和可能"></a>隐喻和可能</h2><p>语言有边界。这是语言能高效传递信息的代价之一。</p><p>所以，打破语言或者说概念的界限，也许就是找到新出路的起点。</p><p>（PS. 在心理咨询中，咨询师很重要的一部分工作，是帮助来访者呈现问题、reframe 问题，而不是直接插手去替他解决问题。）</p><p>其实早在 50 多年前，就有人探讨过人机关系的「未来简史」。</p><p>美国心理学家和计算机科学家 Licklider 在 Man-Computer Symbiosis 这篇论文中，讨论人跟机器的关系存在什么样的可能性，提出「人机共生」的概念。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.016.jpeg" alt=""></p><p>快 60 年过去了，技术的发展让「蠢机器」第一次有可能成为人类的「好基友」，我们为什么首先感到的是焦虑而不是兴奋呢？</p><p>还记得 2016 年，在 AlphaGo 战胜李世石后，跟安猪老师在大理有过一次讨论。当时我的感慨是，为 AlphaGo 的胜利感到挺开心的，但并不是因为我是技术的脑残粉，而是因为我觉得到了这个时候，人不得不去面对这样一个问题：</p><blockquote><p>人到底擅长什么？</p></blockquote><p>也就是说，当接受生物智能无法跟上非生物智能的发展时：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.018.jpeg" alt=""></p><p>人到底有哪些可以让机器「羡慕」（当然，机器不会有这种情绪）的天赋呢？</p><p>至今我还没有答案，但我想，大概会包括：直觉、洞察力、探索和意外的创造。人欣赏「意外」的审美、运用「意外」的创造力，应该会长期秒杀机器。</p><blockquote><p>人跟机器最大的区别到底是什么？</p></blockquote><p>我一直在问自己这个问题。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.021.jpeg" alt=""></p><p>意图，可能是现阶段人跟机器最大的差别。</p><p>人因为时间、空间、认知方面的三大局限，因为生命时长极其有限、可触达的空间极其有限、工作记忆（内存）极其有限，决定了人类的一些基本 drive 和价值观。人的美妙与荒谬，可能都来自于两行二选一的核心代码：</p><blockquote><p>Be numb/sober and Duplicate</p><p>Be insane/self-distroying and Love</p></blockquote><p>所以我（naive地）认为，突破时间、空间、认知限制，渴望无限，是人类物种永恒的追求，换一个词来概括，那就是——意图。</p><p>我们在基本意图上发展出复杂的能力，会体会微妙的情感，会追求意义，会审美、表达、共情，会讲故事和构建社会关系……</p><p>而机器，无所不能，但就是没有意图！</p><p><strong>这样看来，现在难道不是人类最好的时代吗？有一个毫无私心、任劳任怨、潜力无限的助手，为什么我们担心的是被助手取代，而不是兴高采烈地放开手脚去创造呢？</strong></p><h2 id="人机关系的新阶段"><a href="#人机关系的新阶段" class="headerlink" title="人机关系的新阶段"></a>人机关系的新阶段</h2><p>无论技术如何发展，人类从来没有停止过创造。</p><p>这是用 Google DeepDream 算法生成的作品：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/DeepDream2.jpg" alt=""></p><p>DeepDream 网站的首页，已经为人机关系的新时代做了注脚：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Human-ai-collaboration.png" alt=""></p><p>艺术家们一直在尝试探索人机关系，可能是这样的：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Alex%20Kiessling.jpg" alt=""></p><p>也可能是这样的：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/di_2016_ars_11-1024x684.jpg" alt=""></p><p>上图是一位叫做 Dragan iLiC 艺术家的项目，人充当机器的笔刷，由机械臂控制着人去作画。</p><p>在分享的现场，这张图引发了热烈的讨论。有的小伙伴表示，这样做的目的到底是什么，她看不出任何意义。有的小伙伴认为这是对人机关系一种悲观的表达。有的小伙伴的态度则更为中立而开放……</p><p>我想，这恰恰就是艺术家的目的吧：激发人们的反思与讨论。并不存在对与错，只是 raise questions，这也许就是最大的善意。</p><h2 id="音乐，人机协同即将爆发的领域？"><a href="#音乐，人机协同即将爆发的领域？" class="headerlink" title="音乐，人机协同即将爆发的领域？"></a>音乐，人机协同即将爆发的领域？</h2><p>最近关注音乐和技术结合的领域比较多，越来越觉得音乐也许会迎来人机共创的繁荣时期。</p><p>音乐本身是符号化、形式化非常强的「语言」。音乐的规律经过数百年的研究和沉淀，几乎已经没有太多规律上的「未知和秘密」，更多的变化会来自文化思潮影响下的风格探索。</p><p>算法作曲早已不是什么新鲜事，基于 AI 自动生成音乐已经有很多成熟的应用。甚至是在对即兴表演要求相当高的爵士乐，也已经有人机共同即兴表演的尝试。比如 Al Biles 教授的 GenJam 项目，从 2005 年至今，已经演出过数十场。</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=z0712pdmu7n&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/z0712pdmu7n.html" target="_blank" rel="noopener">GenJam’s Journey_腾讯视频</a></p><p>而去年的 Qosmo AI DJ 项目也展示了人类 DJ 和 AI DJ 一起 Jam 的效果~</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=t0602v8uxp2&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/t0602v8uxp2.html" target="_blank" rel="noopener">AI DJ Project 人工智能 DJ 与人类合作打碟_腾讯视频</a></p><h2 id="何以解忧？"><a href="#何以解忧？" class="headerlink" title="何以解忧？"></a>何以解忧？</h2><blockquote><p>这是最坏的时代</p><p>也是最好的时代</p></blockquote><p>这取决于我们现在每做的一个决定、每投入的分分秒秒。</p><p>回到主题，如何破解 AI 时代的焦虑呢？</p><p>以下是 00 给（自己）的解药：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.031.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.032.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.033.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.035.jpeg" alt=""></p><p>回归创造者的使命，装备上创造所需要的心、眼、脑、手，去看去爱去体验。知识可以学习，但智慧更多是一种体验。把技术当成伙伴和切磋的对手，去行动，去试验，去创造。</p><p>最后</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.037.jpeg" alt=""></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://web.stanford.edu/dept/SUL/library/extra4/sloan/MouseSite/1968Demo.html" target="_blank" rel="noopener">Doug Engelbart 1968 Demo</a></li><li><a href="http://patricktresset.com/new/" target="_blank" rel="noopener">PATRICK TRESSET |</a></li><li><a href="http://worrydream.com/refs/Licklider%20-%20Man-Computer%20Symbiosis.pdf" target="_blank" rel="noopener">Licklider - Man-Computer Symbiosis.pdf</a></li><li><a href="http://www.draganilic.org/" target="_blank" rel="noopener">www.draganilic.org</a></li><li><a href="http://igm.rit.edu/~jabics/GenJam.html" target="_blank" rel="noopener">GenJam</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.001.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计" scheme="http://uegeek.com/categories/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="交互设计" scheme="http://uegeek.com/tags/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="AI" scheme="http://uegeek.com/tags/AI/"/>
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Deisgn" scheme="http://uegeek.com/tags/Deisgn/"/>
    
      <category term="人工智能" scheme="http://uegeek.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="HCI" scheme="http://uegeek.com/tags/HCI/"/>
    
      <category term="人机交互" scheme="http://uegeek.com/tags/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
      <category term="人机共生" scheme="http://uegeek.com/tags/%E4%BA%BA%E6%9C%BA%E5%85%B1%E7%94%9F/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="跨界" scheme="http://uegeek.com/tags/%E8%B7%A8%E7%95%8C/"/>
    
      <category term="创新" scheme="http://uegeek.com/tags/%E5%88%9B%E6%96%B0/"/>
    
  </entry>
  
</feed>
