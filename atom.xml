<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>00&#39;s Adventure</title>
  
  <subtitle>Why join the navy if you can be a pirate</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://uegeek.com/"/>
  <updated>2018-09-08T10:14:09.000Z</updated>
  <id>http://uegeek.com/</id>
  
  <author>
    <name>kidult00</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译15 - 剪刀和胶水</title>
    <link href="http://uegeek.com/180908-jitter-15.html"/>
    <id>http://uegeek.com/180908-jitter-15.html</id>
    <published>2018-09-08T10:12:52.000Z</published>
    <updated>2018-09-08T10:14:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-6.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter13" target="_blank" rel="noopener">Tutorial 13: Scissors and Glue</a></p></blockquote><p>本教程学习如何使用两个简单的对象来切割和组合二维矩阵的矩形区域。</p><p>教程 patch 有两个互补的 Jitter 对象：将矩阵切割成大小相等的小矩阵的 <code>jit.scissors</code>; 将多个矩阵粘贴到一起的 <code>jit.glue</code>。还会简要介绍 <code>router</code> 对象，它可以将 Max 消息从多个源引导到多个目的地。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13a.png" alt=""><br>读取视频</p><p>patch 左上角的 <code>loadbang</code> 自动发送 <code>read traffic.mov</code> 消息给 <code>jit.movi​​e</code> 加载交通镜头的视频。</p><p>点击 patch 顶部的开关启动 <code>metro</code>。视频出现在底部较大的  <code>jit.pwindow</code> 中。有趣的是，图像被切割成四个象限，出现在分开的的 <code>jit.pwindow</code> 中。</p><h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><p><code>jit.scissors</code> 把包含视频的矩阵分割成四个小矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13b.png" alt="">        </p><p><code>jit.scissors</code> 将任意尺寸/类型/平面数的矩阵切割成更小的矩阵，然后在不同出口发送。@rows 和 @columns 属性指定每次接收到矩阵时分割成多少个小矩阵。这里 <code>jit.scissors</code> 将图像拆分为四个小矩阵（2 列 2 行）。这些单独的矩阵以<strong>列优先</strong>顺序发送到各出口（从左到右，然后从上到下）。</p><p><code>jit.scissors</code> 有两个属性非常重要：</p><p>1）出口数量在创建对象时就确定。只有在对象框中指定行和列属性，才会生成对应数量的出口。例如，<code>jit.scissors @rows 10 @columns 2</code> 将创建一个有 20 个出口的 <code>jit.scissors</code> 实例（包括用于查询属性的最右出口），如果 <code>jit.scissors</code> 没有参数，就只会生成一个出口。可以用 Max 消息更改行和列属性，但是无法添加超过对象初始化时的出口数量。</p><p>2）<code>jit.scissors</code> 发送的矩阵大小等于矩阵切片的大小，而不是整个原始矩阵。例如，教程 patch 中的四个较小的矩阵，每个都是 160x120 个单元，而不是 320x240。</p><h2 id="Routing-the-Matrices"><a href="#Routing-the-Matrices" class="headerlink" title="Routing the Matrices"></a>Routing the Matrices</h2><p>由 <code>jit.scissors</code> 输出的四个小矩阵，被发送到两个不同的地方： <code>jit.pwindow</code> 和 <code>router</code> 对象。彩色接线显示每小矩阵被发送到了哪里。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13c.png" alt=""><br><code>router</code> 对象</p><p><code>router</code> 是 <code>gate</code> 和 <code>switch</code> 的组合。它有两个参数（输入口数量和输出口数量），由左入口的消息指定。<code>router</code> 能处理的大多数消息与 MSP 对象 <code>matrix~</code> 相同。因此可以跟 <code>matrixctrl</code> 对象一起使用。</p><p><code>router</code> 右侧的四个入口从 <code>jit.scissors</code> 的四个矩阵出口获取输入。<code>receive routeit</code> 对象从 patch 的右下方控制 <code>router</code> 的 <code>s routeit</code> 获取消息。<code>router</code> 最左边四个出口连接到 <code>jit.glue</code> 对象，我们稍后会讨论。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13d.png" alt=""><br>控制路由器</p><p>发送消息 <code>patch $1</code> 后跟入口号($1)和出口号到 <code>router</code>， 会在该入口和对象的出口之间建立虚拟连接。到达该入口的任何消息会转发给相应出口。如果先前已有入口连接到该出口，patch 消息将切断该连接以支持新连接。</p><p>patch 中的 <code>radiogroup</code> 对象控制四个小矩阵（到达入口）被发送到 <code>router</code> 的哪些出口。入口和出口从 0 开始编号，所以 <code>2 1</code> 在 <code>router</code> 的 3 入口和 2 出口建立连接。</p><p>单击 <code>radiogroup</code> 控件并观察下方 <code>jit.pwindow</code> 的图像如何变化。注意 <code>router</code> 如何使剪切的矩阵，出现在底部合成图像的四个象限中。</p><h2 id="整合的胶水"><a href="#整合的胶水" class="headerlink" title="整合的胶水"></a>整合的胶水</h2><p>patch 底部的 <code>jit.glue</code> 做与 <code>jit.scissors</code> 相反的事情。行和列的属性指定入口数而不是出口数，以网格排列的输入矩阵合成一个矩阵输出。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13e.png" alt=""><br>将相同的矩阵发送到 <code>jit.glue</code> 的四个入口</p><blockquote><p>要点：与 <code>jit.scissors</code> 一样，<code>jit.glue</code> 只能在对象初始化时创建入口和出口，对象框中的行和列属性将确定入口数。此外，由 <code>jit.glue</code> 生成的输出矩阵的大小，等于所有小矩阵的大小（例如，四个 160x120 矩阵将合成一个 320x240 矩阵）。</p></blockquote><p><code>jit.glue</code> 默认当从左入口接收到新矩阵时，只输出复合矩阵。如果断开 <code>jit.glue</code> 最左边的入口，就不能再获得任何新的输出矩阵。syncinlet 属性可让 <code>jit.glue</code> 发送输出到不同的入口。syncinlet 值为 -1 时，<code>jit.glue</code> 在任一入口收到新矩阵时都输出新的合成矩阵。虽然看似不错，但会增加大量冗余工作，降低 Jitter 的帧处理速率。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.scissors</code> 对象切割矩阵成更小的、大小相等的矩阵。<code>jit.glue</code> 对象把相同大小的矩阵合并到一起生成复合矩阵。两个对象的行和列属性分别确定出/入口的数量，以及矩阵被切割或合成的方式，这在对象创建时就要给出。<code>router</code> 以任意方式连接多个入口处的消息到多个出口，跟 MSP <code>matrix~</code> 对象类似。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译14 - 颜色查找表</title>
    <link href="http://uegeek.com/180907-jitter-14.html"/>
    <id>http://uegeek.com/180907-jitter-14.html</id>
    <published>2018-09-07T11:57:41.000Z</published>
    <updated>2018-09-07T11:58:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-5.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter12" target="_blank" rel="noopener">Tutorial 12: Color Lookup Tables</a></p></blockquote><p>本教程将讲解如何使用颜色查找表（lookup tables）重新映射 Jitter 矩阵内的数据。<code>jit.charmap</code> 对象是为此而设计的。我们还将研究生成查找表矩阵的不同策略，包括 <code>jit.gradient</code> 对象。</p><h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p>查找表（通常称为传递函数/transfer functions）是一个数组，以数字为表的索引。检索存储在该索引（地址或位置）的数字来替换原数字。任何函数 graph - 每个 x 值（地址）有相应的 y 值（输出）- 都可以用作查找表。Max 对象如 <code>funbuff</code>，<code>table</code> 和 MSP <code>buffer~</code> 对象是常用的查找表。本教程将以类似的方式使用 Jitter 矩阵。</p><p>打开教程 patch 读取图像</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12a.png" alt="">            </p><p>patch 左上角有一个 <code>jit.movi​​e</code> 对象，读取两个文件。初始化对象（通过 loadbang）并加载文件 colorwheel.pct。也可以点击 <code>rain.mov</code> 消息加载视频。可以随意切换两个图像源。</p><p>单击 patch 顶部的开关启动 <code>metro</code>。色轮同时出现在顶部和底部的 <code>jit.pwindow</code>。底部第三个（矩形）<code>jit.pwindow</code> 中出现渐变。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12b.png" alt=""><br><code>jit.charmap</code> 的输出和查找表矩阵</p><p>patch 底部有一个<code>jit.charmap</code> 对象，用它来重新映射图像中的单元格值。对象有两个入口，左入口连接到顶部的 <code>jit.movi​​e</code>。右入口连接到 <code>jit.matrix colortable</code>。名为 colortable 的矩阵只有一维共 256 个单元，有四个 char 型数据平面。这是<code>jit.charmap</code> 用来重新映射左边矩阵中单元格的颜色查找表。带有名字 ctable 的<code>receive</code>（一般缩写为 <code>r</code>）对象从 patch 的其他位置接收数据并发送到 <code>jit.matrix</code>。打开顶部的开关发送一个 bang 到 <code>jit.matrix colortable</code>，它将矩阵消息发送到<code>jit.pwindow</code> 和 <code>jit.charmap</code>。</p><p><code>jit.charmap</code> 用输入（左）矩阵中的值，指向（右）矩阵中对应的位置并复制那里的值，生成输出矩阵。如果发送给<code>jit.charmap</code> 的矩阵包含一个在四个平面中值为 <code>100 50 35 20</code> 的单元格。如果查找表在平面 1 第 100 个单元格的值是 73，平面 2 第 50 个单元格的值是 25 ，平面 3 的第 35 个单元格的值是 0，平面 4 第 20 个单元格的值是 203，输出单元的值是 <code>73 25 0 203</code>。</p><p><code>jit.charmap</code> 查找表是有 256 个单元格的一维矩阵，其平面数量与要重新映射的矩阵相同。因为 char 矩阵的值范围是 0~255，因此需要 256 个数字来覆盖查找表。</p><h2 id="生成查找表"><a href="#生成查找表" class="headerlink" title="生成查找表"></a>生成查找表</h2><p>patch 的右上侧包含三个 <code>multislider</code>，可以设计 colortable 查找表矩阵 1-3 平面的传递函数：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12c.png" alt=""><br>用 multislider 的值填充查找表矩阵</p><p><code>multislider</code>（有 256个 整数 slider，范围为 0~255）把列表发送到下面的 <code>jit.fill</code>对象。它用 <code>multislider</code> 的值替换 colortable 矩阵当前存储在平面1-3（即红，绿和蓝）的值。当矩阵采用新值时，<code>jit.fill</code>发出 bang 到 patch 左边连接到 <code>jit.charmap</code> 右入口的 <code>jit.matrix</code>。这里忽略了平面 0，因为只有将 4 平面矩阵视为视频时，它才包含 Alpha 值。</p><p>patch 中的 <code>jit.matrix</code> 和 <code>jit.fill</code> 的名称相同（colortable）。这样两个对象从同一矩阵读取和写入，一个对象（<code>jit.fill</code>）生成另一个对象（<code>jit.matrix</code>）可读取的数据，而不必在两个矩阵之间复制数据。这跟许多 MSP 对象（例如 <code>peek~</code>，<code>play~</code>，<code>groove~</code>）可以共享存储在单个 <code>buffer~</code> 中的样本数据类似。关于命名矩阵请参见<a href="https://www.uegeek.com/180905-jitter-13.html" target="_blank" rel="noopener">教程 13</a>，18 和 19。</p><p>在 <code>multislider</code> 中随意绘制一些形状，看它如何影响查找表（较小的<code>jit.pwindow</code>）和 <code>jit.movi​​e</code> 的输出图像。可以来回切换两个图像源。</p><p>如果想重置任一平面为 <code>y = “x”</code> 传递函数（使所有值保持不变的固定斜率直线），可以单击相应 multislider 上的按钮。名为 <code>p clear</code> 的子 patch 用 <code>uzi</code> 初始化了 <code>multislider</code>。</p><blockquote><p>要点：与许多 Max 对象一样，Jitter 对象会保留存储在一个入口中的矩阵，即使另一个入口接收到了新矩阵。所以这个 patch 的 <code>metro</code> 只需要触发 <code>jit.movi​​e</code>。包含查找表<code>jit.charmap</code> 的<code>jit.matrix</code> 只需要在所存储的数据发生变化时输出值。</p></blockquote><p>以下是一些查找表及其结果：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12d.png" alt=""><br>三组 <code>multislider</code>及其生成的颜色查找表和输出颜色轮</p><p>例 1 中，红色和蓝色查找表调换而绿色正常。结果是输入图像中较大的红色和蓝色值在输出时变小，反之亦然。所以色轮的白色背景现在看起来是绿色的（单元格值 0 255 255 255 映射为 0 0 255 0）。</p><p>例 2 设置绿色平面为 0（查找表在整个输入值范围内设置为 0）。红色和蓝色平面如果超过阈值也设置为 0，这时值会突然上升（红色比蓝色上升得更明显）。结果是色轮大部分都是黑色的（特别是在绿色区域）。红色平面仅在非常高的值（即色轮背景中的品红色）中可见。</p><p>例 3 正常映射红色平面。绿色平面是抛物线形状，极值映射为高，中间阴影映射为低。蓝色平面除了中间调中被归零的范围，其余正常。这种非线性表现为贯穿彩色轮顶部和右侧的红色“断层线”。</p><p>有无数组合可以重新映射矩阵单元格的值。接下来研究另一个以更精确方式重新映射颜色值的对象。</p><h2 id="jit-gradient-对象"><a href="#jit-gradient-对象" class="headerlink" title="jit.gradient 对象"></a>jit.gradient 对象</h2><p>打开 Duotone 子 patch，它显示了使用 <code>jit.gradient</code> 生成查找表的方法：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12e.png" alt=""><br>使用 <code>jit.gradient</code> 对象</p><p><code>jit.gradient</code> 生成两个单元格的值之间平滑渐变的单维 char 矩阵。<code>start</code> 和 <code>stop</code> 属性是指定这些单元格的值列表。例如，start 属性 <code>0 0 0 0</code> 和 end 属性 <code>0 0.5 1.0 0.5</code> 将生成从黑色（矩阵中的单元格 0）到浅绿色（矩阵中最后一个单元格）的渐变。</p><p>我们已经用参数指定 <code>jit.gradient</code> 为 256 单元宽，这样当它改变时可以存储在 <code>jit.matrix colortable</code> 中。请注意， <code>jit.gradient</code> 在属性列表中使用浮点数来指定 char 值（即属性中用值 1.0 指定 char 值为 255）。</p><p>用 <code>swatch</code> 对象输出的 RGB 列表转换为 ARGB 浮点数来获得格式化属性。将属性发送到 <code>jit.gradient</code> 对象后，它接收触发对象发出的 bang，将矩阵输出到 patch 左侧的<code>jit.matrix</code>。</p><p>尝试在 <code>swatch</code> 中选择颜色。start 和 end 属性指定查找表的边界，所以输入图像的值表现为在两种颜色之间变化的双色调外观。patch 顶部的 <code>multislider</code> 将反映 <code>jit.gradient</code> 所生成的查找表。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12f.png" alt=""><br>使用颜色渐变作为查找表</p><p>例 1 是翻转的图像。查找表的 start 是白色（<code>start 0 1.0 1.0 1.0</code>），end 是黑色（<code>end 0. 0. 0. 0</code>）。结果是输入值 0 映射到 255，反之亦然（<code>y = 255 - x</code>）。</p><p>例 2 和 3 是双色调渐变，将色轮的光谱重新映射到红色和橙色（例 2）以及橄榄色和青色（例 3）之间。请注意，根据色轮中不同点的原始颜色，渐变曲线变得更陡峭或更和缓。</p><p><code>jit.gradient</code> 的另一个属性是 cheby，它指定在矩阵开始和结束值之间的变形曲线。cheby 属性的参数列表是浮点数。这些参数是 Chebyshev polynomials（见下文的切比雪夫多项式）不同阶数的振幅。使用查找表时，这些特殊功能曲线会产生不同的效果。patch 中设置 cheby 属性的 <code>multislider</code>，可以指定前 8 个 Chebyshev polynomials 曲线的相对振幅，形状如下（如果将它们视为从黑色到白色的过渡）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12g.png" alt=""><br>用 Chebyshev orders 1-4（顶行）和 5-8（底行）生成的梯度</p><blockquote><p>技术说明：切比雪夫多项式通常用作数字合成算法中波形整形音频信号的查找表（它们的特殊属性可以将正弦波形扭曲成等效于不同阶数幅度的谐波频谱）。MSP <code>lookup~</code> 对象可以与加载到 <code>buffer~</code> 中的函数一起来完成音频信号处理（跟本教程中的图像处理类似）。更多内容请参阅 MSP 手册中的教程 12：综合波形整形。</p></blockquote><p>复位 gradient 中开始和结束点（单击上面的消息框），缓慢调整 <code>multislider</code>控制的 cheby 属性。观察颜色轮在颜色消失并在不同区域重新出现时如何变化。</p><p>在 <code>jit.gradient</code> 中使用 cheby 属性时，即使将渐变起点和终点保留为黑色和白色，也可以得到一些非常有趣的颜色变形效果。以下是视频剪辑 rain.mov 的一些例子：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12h.png" alt=""><br>不同梯度曲线对雨水彩色频谱的影响</p><p>左边图像显示 rain.mov 中未处理的静止图像。中间图像显示了当使用二阶切比雪夫多项式（图像中最暗的区域现在位于色谱的中间）生成梯度时色谱的变化。右侧图像显示更复杂的梯度，色谱显示多个峰和谷。</p><p>patch 顶部的 <code>multislider</code>反映查找表的当前状态（由 <code>jit.gradient</code> 生成的矩阵被发送到 <code>p showit</code> 子 patch 中的 <code>jit.iter</code>，在那里数字被组合以设定 <code>multislider</code> 的状态）。尝试生成渐变，然后调整 multislider 手动修改查找表。这样 <code>jit.gradient</code> 就作为更复杂的查找表的起始点。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/jitterchapter12i.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用 <code>jit.charmap</code> 映射 char 矩阵中单元格的值。<code>jit.charmap</code> 的右入口接收 256 单元矩阵来定义要用于输入矩阵数据的查找表（或传递函数）。可以使用多种方法定义查找表，包括<strong>使用 <code>jit.fill</code>从 Max 列表生成矩阵，或使用 <code>jit.gradient</code> 对象根据 cheby 指定的曲线形状，在开始和结束单元格值之间生成颜色渐变属性。</strong></p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译13 - 列表和矩阵</title>
    <link href="http://uegeek.com/180906-jitter-13.html"/>
    <id>http://uegeek.com/180906-jitter-13.html</id>
    <published>2018-09-06T10:54:22.000Z</published>
    <updated>2018-09-06T10:55:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-4.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter11" target="_blank" rel="noopener">Tutorial 11: Lists and Matrices</a></p></blockquote><p>本教程讲解如何用 Max 列表和 <code>jit.fill</code> 对象来填充（部分）矩阵，以及如何用 <code>jit.spill</code> 检索（部分）矩阵内容作为列表。还将演示通过矩阵名称远程访问矩阵内容。</p><h2 id="矩阵名称"><a href="#矩阵名称" class="headerlink" title="矩阵名称"></a>矩阵名称</h2><p>patch 左侧有一个蓝色的 <code>jit.matrix</code>。第一个参数是矩阵的名称 smallbox。其他参数表示矩阵有 1 个 char 平面，包含一维 12 个单元格。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11a.png" alt=""><br>矩阵唯一名称：smallbox</p><p><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 介绍过，每个矩阵都有一个名称。如果没有另外指定，Jitter 将自动命名（类似 “u040000114” 奇怪的唯一名称）。名称表示存储矩阵的内存位置。为什么要另外给矩阵命名呢？这样可以告诉其他对象如何找到矩阵的内容。引用矩阵的名称，对象之间可以共享数据，无需接收 jit_matrix 消息就可以远程访问矩阵的内容。</p><blockquote><p>Jitter 使用矩阵名称来指代内存位置，这跟 Max 的 <code>value</code> 对象类似。名称相同的对象可以有多个，只在其中一个中存储数值，其他对象就可以检索这个值。该名称实际上只有一个内存位置，它们共享相同的数据。同样，可以有多个名称相同的 <code>jit.matrix</code> 对象，它们共享相同的数据。其他对象（例如 <code>jit.fill</code>）只需知道名称即可访问矩阵内容。</p></blockquote><h2 id="jit-fill"><a href="#jit-fill" class="headerlink" title="jit.fill"></a>jit.fill</h2><p><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 展示了在矩阵特定位置指定数值的 <code>setcell</code>消息，以及检索位置内容的 <code>getcell</code> 消息。现在来看看如何使用 <code>jit.fill</code> 对象将一个值列表存入矩阵中。（本章后面还将展示如何从矩阵中一次检索多个值）</p><p>在 patch 的左上角有一个包含  12 个数值列表的消息框。它连接到 <code>jit.fill smallbox</code> 对象。矩阵名字是 smallBox。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11b.png" alt=""><br> <code>jit.fill</code> 在命名矩阵中存储一个值列表</p><p>单击消息框将列表发送到 <code>jit.fill smallbox</code>。对象在名为 “smallBox” 的矩阵存储这些值。单击 <code>jit.matrix smallbox</code> 上方的按钮显示 smallbox 矩阵的内容来验证。这些值由 <code>jit.print</code> 打印在 Max Console 中，并在狭长的 <code>jit.pwindow</code> 中显示为灰阶。</p><p>这个例子的列表长度恰好可以填充整个矩阵。这不是必须的。可以在 1D 或 2D 矩阵的任意连续部分中放置任何长度的列表。</p><h2 id="偏移属性"><a href="#偏移属性" class="headerlink" title="偏移属性"></a>偏移属性</h2><p>双击打开 <code>random_lists</code> 子 patch。</p><p>默认情况下，<code>jit.fill</code> 将值列表放在矩阵最开头。也可以设置 <code>jit.fill</code> 的 <code>offset</code> 属性将列表指定到矩阵中的任何位置。这里演示如何使用 offset。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11c.png" alt=""><br>首先指定偏移量，后跟列表</p><p>上面的例子随机选择单元格索引作为 <code>jit.fill</code> offset 消息的参数，然后向 randbox 矩阵中的该索引处，发送要存储的 16 个元素的列表。</p><p>点击开关启动 <code>metro</code>。每隔半秒，16 个元素的列表被写入 randbox 矩阵中的新位置。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11d.png" alt=""></p><p>用 <code>clear</code> 消息清除 randbox 矩阵的内容，然后观察 <code>metro</code> 将列表写入新的随机位置。<code>metro</code> 也正在触发 <code>jit.matrix randbox</code> 将其内容发送到 <code>jit.pwindow</code> 显示。</p><h2 id="使用-multislider"><a href="#使用-multislider" class="headerlink" title="使用 multislider"></a>使用 multislider</h2><p>打开 draw_list 子 patch。</p><p>现在我们知道如何将预先定义的值列表存到矩阵中。如果要在 Max 中交互式生成列表并实时放置在矩阵中，需要用构建列表的对象比如  <code>multislider</code> 和 <code>zl</code>。</p><p><code>multislider</code> 对象包含一组 <code>slider</code>，并一次发送所有 slider 的值作为列表（slider 可以小到一个像素宽，这样它看起来更像一个图形而不是一组单独的控件）。在窗口中移动任何 slider 时会发送整个列表，释放鼠标按钮时再次发送列表。在 draw_list 子 patch，有一个包含 256 个滑块的 <code>multislider</code>，可发送从 0~255 的值，它恰好将 256 个 char 值发送给 <code>jit.fill graybox</code>  对象。</p><p>拖动鼠标在 <code>multislider</code> 中设置 256 个滑块。释放鼠标按钮时，256 个值的列表将发送到 <code>jit.fill graybox</code>。注意矩阵单元的亮度如何与滑块的高度相对应。</p><p>一旦 <code>jit.fill</code> 在入口处收到列表，就会写入指定的矩阵（offset 属性指定的）位置。完成时 <code>jit.fill</code> 会发出 bang。可以用它来触发另一个动作，例如显示矩阵。</p><blockquote><p>前两个例子故意不使用 <code>jit.fill</code>左侧出口的 bang，以便清楚看到，<code>jit.fill</code> 远程写入到指定命名的矩阵，而不是通过物理连接。当然 <code>jit.fill</code> 左侧出口的 bang 很方便，只要填充完就会触发矩阵的输出。</p></blockquote><h2 id="使用-zl"><a href="#使用-zl" class="headerlink" title="使用 zl"></a>使用 zl</h2><p>打开 collect_values 子 patch</p><p>某些情况下你可能想用矩阵来存储 patch 某处的数字消息：MIDI消息、来自 UI 对象的数字等。可以向 <code>jit.matrix</code> 发送 <code>setcell</code> 和 <code>getcell</code> 消息，也可以将消息收集到列表中，然后用 <code>jit.fill</code> 将它们一次性存到矩阵中。</p><p><code>zl</code> 是多功能的列表处理对象，由第一个参数指定模式和行为。当第一个参数是 group 时，它会收集左入口的消息直到一定数量，然后将这些数字作为单个列表发送出去（这些值按接收顺序分组）。在 collect_values 子 patch 中有一个 <code>zl group 256</code> 对象，每当它从左入口收集够 256 个值，就把这个列表发送到左出口（并清除内存）。</p><p>向上和向下移动 slider 为 <code>zl</code> 对象生成 256 个输入值。当 <code>zl</code> 收到 256 个数字时，它把这个列表发送到 <code>jit.fill midibox</code>，由它写入 midibox 矩阵，然后 bang <code>jit.matrix midibox 1 char 256</code> 对象以显示矩阵。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11e.png" alt=""><br><code>zl</code> 将包含 256 个元素的列表发送到 midibox 矩阵，然后 bang <code>jit.matrix</code> 来显示结果</p><p>如果电脑连接了 MIDI 键盘，可以使用 MIDI 键盘的 modulation wheel 移动 slider。（MIDI 和 Jitter 的交互将在后面的教程中详细探讨）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11f.png" alt=""><br>值*2 获得 0~254 范围</p><p>可以用<code>list length</code>数字框向右入口发送新的值来更改 <code>zl</code>数据集的列表长度。用 <code>loacation</code> 数字框发送 <code>offset</code> 消息给 <code>jit.fill</code> 告诉它想要存储列表的位置。改变列表长度和位置，可以将任意数量的值放入矩阵的任何连续区域。</p><p>更改 <code>zl</code> 的 list length （如 100），设置 <code>jit.fill</code> 的 offset 属性（如 50），然后移动 slider 把值的列表存到矩阵中的指定位置。</p><h2 id="jit-fill-和多平面矩阵"><a href="#jit-fill-和多平面矩阵" class="headerlink" title="jit.fill 和多平面矩阵"></a>jit.fill 和多平面矩阵</h2><p>打开 <code>fill_separate_panes</code> 子 patch</p><p><code>jit.fill</code> 可用于多平面矩阵，但它一次只能填充一个平面。<code>jit.fill</code> 要处理哪个平面由 <code>@plane</code> 属性指定。在<code>fill_separate_panes</code> 子 patch 中创建了另一个名为 colorbox 的矩阵，这次有四个char 数据平面。设置了三个 <code>multislider</code> 和三个 <code>jit.fill</code> 对象，每个对象都对应 colorbox 框矩阵的不同颜色平面。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11g.png" alt=""><br>各自填充每个平面</p><p>拖动三个彩色 <code>multislider</code> 填充三个颜色平面。</p><p>这样可以快捷生成矩阵中 RGB 平面不同强度的曲线。显示矩阵的 <code>jit.pwindow</code> 宽为 256 像素，所以矩阵 64 个单元格都显示为 4 像素宽的条带。如果打开 <code>jit.pwindow</code> 的 <code>interp</code> 属性，相邻频段之间的差值会被插值平滑。</p><p>单击 <code>interp $1</code> 消息框上方的开关，将消息发送到 <code>jit.pwindow</code>。（注意，这也会发送 bang 到 <code>jit.matrix</code> 重新显示内容）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11h.png" alt=""><br>与前一个示例相同，但打开了 <code>jit.pwindow</code> 的插值</p><h2 id="jit-fill-和二维矩阵"><a href="#jit-fill-和二维矩阵" class="headerlink" title="jit.fill 和二维矩阵"></a>jit.fill 和二维矩阵</h2><p>目前为止所有的例子都是一维矩阵。用列表（一维数组）通过 <code>jit.fill</code> 填充二维矩阵时会发生什么？<code>jit.fill</code> 对象在第一个维度里尽可能排列列表（尽量排满指定的行）然后绕到下一行继续排列。下面演示排列的过程。</p><p>单击标有 2D 的按钮，把 <code>jit.matrix colorbox</code> 对象变成 8x8 二维矩阵，<code>jit.pwindow</code> 也会调整为更合适的形状。无论何时更改矩阵尺寸，它都会清除之前的数据，所以需要再次单击三个 multislider 重新填充矩阵。仍向每个 <code>jit.fill</code> 对象发送 64 个元素的列表，并用 8 个元素填充矩阵的 8 行。</p><blockquote><p>要点：这里没有演示如何使用带有 offset 属性的 2D 矩阵，当 <code>jit.fill</code> 的 name 属性命名 2D 矩阵时，offset 属性需要两个参数： x 偏移量和 y 偏移量。</p><p><code>jit.fill</code>  仅适用于 1D 和 2D 矩阵。</p></blockquote><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11i.png" alt=""><br>相同的例子，列表填充 8x8 矩阵（未插值）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11j.png" alt=""><br>开启插值</p><h2 id="jit-spill"><a href="#jit-spill" class="headerlink" title="jit.spill"></a>jit.spill</h2><p><code>jit.spill</code> 是 <code>jit.fill</code> 的补充。它在入口处接收 <code>jit_matrix</code> 消息，将矩阵值作为列表发送到左出口。当使用红色 <code>multislider</code> ，下面的 <code>jit.spill</code> 发送平面 1（红色）的值到左出口并在消息框显示内容。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11k.png" alt=""><br>用列表显示 colorbox 矩阵的平面 1 的内容</p><blockquote><p><code>jit.spill</code> 也有 list length 和 offset 属性</p></blockquote><p>如果需要发送一系列单个数字消息而不是单个列表消息，<code>iter</code> 对象了解一下。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11l.png" alt=""><br>从矩阵中获取一些值并分成不同的消息</p><h2 id="jit-iter"><a href="#jit-iter" class="headerlink" title="jit.iter"></a>jit.iter</h2><p>打开 individual_values 子 patch。</p><p><code>jit.iter</code> 对象可以检索矩阵中的每个值。当它收到 <code>jit_matrix</code> 消息时，会按矩阵中单元格的顺序发出消息序列：单元格索引（中间出口），然后是该单元格的值（左出口）。如果是一个大矩阵，会有一大堆消息试图在（Max’s scheduler）单个 tick 中发送出去，所以当它完成所有发送后，<code>jit.iter</code> 会向右出口发送一条完成的消息。</p><p>在 individual_values 子 patch 中有一个 <code>jit.iter</code> 对象，它接收来自 <code>jit.matrix readbox 1 char 256</code> 的矩阵信息。我们使用 <code>swap</code> 对象切换单元格索引的顺序（来自 <code>jit.iter</code> 中间出口）和单元格值（来自 <code>jit.iter</code> 左出口）。然后用该单元格的值作为想要存储在表对象中的 y 值，用单元格索引作为 x 轴索引。</p><p>点击 <code>multislider</code> 发送内容给 <code>jit.fill</code>（然后 bang  <code>jit.matrix</code> 并传达其内容给 <code>jit.iter</code>）。双击 <code>tabel</code> 对象打开图形窗口，看到它包含与 readbox 矩阵相同的值。</p><p>请注意，使用 <code>jit.iter</code> 填充表格的技巧适用于中等大小的一维单平面矩阵，因为表格是一维数组。但是像<code>jit.movi​​e</code> 对象的 2D 矩阵有四个平面，<code>jit.iter</code> 的中间（单元索引）出口输出双元素列表，左出口的值列表是四元素列表。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11m.png" alt="">            </p><p>对于一维或小的 2D 矩阵，或者在较大矩阵中搜索特定值或模式， 用 <code>jit.iter</code> 扫描整个矩阵是很方便的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>发送 <code>setcell</code> 和 <code>getcell</code> 消息给 <code>jit.matrix</code>，可以<strong>存储或检索矩阵中的单个值</strong>（如<a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 所示）。<strong>如果要存储或检索列表，就要用 <code>jit.fill</code> 和 <code>jit.spill</code>。</strong>它们可以检索 1D 或 2D 矩阵的任何平面，在任意起始单元位置存储任何长度的列表。</p><p><code>multislider</code> 和 <code>zl</code> 对象用于实时生成列表消息。用鼠标拖动 <code>multislider</code> 可以绘制列表。使用 <code>zl group</code> 收集多个单独的数值到一个列表中，然后一次性发送到 <code>jit.fill</code>。</p><p>可以设置 <code>jit.fill</code>（或 <code>jit.spill</code>）的 offset 属性来指定矩阵中的起始单元格位置。<code>jit.fill</code> 对象要设置名称属性（或者发送<code>name</code> 消息或输入[name]参数），指定它将填补的矩阵名称。它用这个名称访问矩阵，并且在列表写入矩阵完成时发出 bang。可以用它来触发其他操作。</p><p>发送矩阵给 <code>jit.iter</code>，可以输出整个矩阵中所有值。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="列表" scheme="http://uegeek.com/tags/%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译12 - Chromakeying 视频去背景合成</title>
    <link href="http://uegeek.com/180904-jitter-12.html"/>
    <id>http://uegeek.com/180904-jitter-12.html</id>
    <published>2018-09-04T11:16:04.000Z</published>
    <updated>2018-09-06T10:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-3.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter10" target="_blank" rel="noopener">Tutorial 10: Chromakeying</a></p></blockquote><p>本教程介绍如何使用 <code>jit.chromakey</code> 对两个源视频Chromakeying（去背景合成，chroma-纯色，key-抽离颜色）。还将学习如何使用 <code>suckah</code> 对象获取屏幕上任意像素的颜色。</p><p>打开教程 patch，由 <code>loadbang</code> 发送 <code>read</code> 消息到两个 <code>jit.movi​​e</code> 对象，自动读取两个视频（oh.mov 和 traffic.mov）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10a.png" alt=""><br>通过 <code>loadbang</code> 初始化 patch</p><p>其他参数也由连接到右侧消息框的 <code>loadbang</code> 初始化。消息框发送消息到 patch 中其他名为 <code>receive</code> 的对象完成初始化。（参见<a href="https://docs.cycling74.com/max7/tutorials/basicchapter16" target="_blank" rel="noopener">教程 18：Remote Messaging</a>）。</p><p>点击开关启动 <code>metro</code>。三个 <code>jit.pwindow</code> 对象中出现了图像。开关不仅可以启动和停止 <code>metro</code>，还可以启动和停止两个 <code>jit.movi​​e</code> 视频播放。</p><p>教程 patch 的下半部分（三个 <code>jit.pwindow</code> 中的两个）是这样的：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10b.png" alt=""><br><code>jit.chromakey</code> 对象</p><p>点击左侧 <code>jit.pwindow</code> 对象的蓝色区域（即视频中男性头部后面的区域）。</p><p>第三个 <code>jit.pwindow</code>（在 patch 右下角）将显示：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10c.png" alt="">            </p><blockquote><p>历史说明：蓝屏合成（在蓝色哑光背景下拍摄现场镜头的过程）在 20 世纪 30 年代就出现了，目的是为了后期用其他图像替换蓝色。蓝屏合成涉及平版印刷分色，起初是非常昂贵的电影工艺，它（现在更常见的是绿屏合成）已经演变成影视制作中最常见的特效。通过数字叠加完成 Chromakeying（蓝屏处理的术语）让它更普及。Chromakeying 在电视行业中常被称为 CSO（色彩分离叠加），由 1960 年代开发它的 BBC 团队命名。蓝屏发明者 Petro Vlahos 在 1994 年被授予了电影艺术与科学学院终身成就奖，以表彰这项无可替代的技术。</p></blockquote><h2 id="jit-chromakey-对象"><a href="#jit-chromakey-对象" class="headerlink" title="jit.chromakey 对象"></a>jit.chromakey 对象</h2><p>去背景合成 - 将一个图像叠加在另一个上面，选择性替换颜色的过程 - 由 <code>jit.chromakey</code> 对象实现。<strong>通过指定颜色和其他参数， <code>jit.chromakey</code> 在第一个（左侧）矩阵中检测包含该颜色的单元，并在生成输出矩阵时，用第二个（右侧）矩阵中的对应单元替换它们。</strong>这样，来自第一个矩阵的单元叠加到第二个矩阵上。</p><p>可以选择任何颜色为要去除的背景，请尝试点击左侧 <code>jit.pwindow</code> 中的其他区域。不同的颜色会从男人的脸上移除，而显示出第二个视频中的图像。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10d.png" alt=""><br>消失的面孔（第一部分）</p><p><code>jit.chromakey</code> 用 <code>color</code> 属性（称为参考颜色）来定义中心色。这个属性是一个值列表，应用于等待抠图的矩阵中的所有平面。<code>tol</code> 属性定义中心色的<strong>容差范围</strong>。此范围内的颜色也会被去除。</p><p>将 <code>jit.chromakey</code> 与 char 矩阵一起使用时，属性值的范围在 0.0~1.0，然后映射到 char 数据所需的 0~255。所以可以将属性设置为 <code>color 0 0 1.0 0</code>，而不是 <code>0 0 255 0</code>。<code>tol</code> 为 0.5 时会去除距离参考色一半色阶的所有颜色（key all values within half of the chromatic distance from the reference color）。<code>tol</code> 为 0 时只会用精确的参考色来完成抠图。</p><p>再次点击左侧视频中的蓝色区域，然后调整 <code>tol</code> 属性查看输出的变化。在低容差时，左图中的一些蓝屏将保留。容差值非常高时，男人脸部的部分可能会消失。</p><p>在教程 patch 中，我们通过点击不可见的对象来设置 <code>jit.chromakey</code> 的颜色属性。解锁 patch，会看到左侧 <code>jit.pwindow</code> 上面的同心红色方块区域：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10e.png" alt=""><br><code>suckah</code> 对象</p><p>该区域是名为 <code>suckah</code> 的 Max UI 对象，可以在 interface 工具栏找到它：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10f.png" alt=""><br>对象面板中的 suckah 对象</p><p><code>suckah</code> 对象获取它所覆盖的屏幕像素的 RGB 值。当单击对象时（patch 处于锁定状态），它会获取 0.0~1.0 范围内的浮点数值。例如，单击视频中的纯蓝色区域，<code>suckah</code> 会发送 <code>0 0 1.0</code> 列表（suckah 的初始版本使用 0~255 范围。如果需要，可以在 inspector 中选择这个设置）</p><p><code>suckah</code> 对象获取 RGB 颜色列表后，用 <code>prepend 0</code> 在前面加上 0（增加 alpha 值到列表最前面）来设置 <code>jit.chromakey</code> 的颜色属性。然后再 <code>prepend color</code> 并发送给 <code>jit.chromakey</code>。</p><h2 id="Chromakey-选项"><a href="#Chromakey-选项" class="headerlink" title="Chromakey 选项"></a>Chromakey 选项</h2><p><code>jit.chromakey</code> 对象有附加属性：minkey，maxkey 和 fade。当矩阵从左入口进入，<code>jit.chromakey</code> 基于该矩阵在内部创建一个灰度（单平面）遮罩。输入矩阵中，在容差（tol）范围内颜色值的单元格，将设置为遮罩中的 maxkey 属性值（默认为 1）。容差范围之外的区域乘以 minkey 属性（默认为 0）。如果 minkey 和 maxkey 为 0 和 1，生成的图像在去背景的位置应该看起来是白色，而在要保留原始图像的位置看起来是黑色。</p><p>将得到的遮罩及其负片，分别乘以右矩阵和左矩阵。然后添加乘法的结果以形成合成图像。下图说明了这个过程：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10g.png" alt=""><br>遮罩（minkey 为 0，maxkey 为 1）和合成效果</p><p>maxkey 属性设置右边输出矩阵的强度，minkey 属性设置左边矩阵的强度。如果要反转 minkey 和 maxkey 属性，chromakey 将被反转：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10h.png" alt=""><br>minkey 为 1，maxkey 为 0（反向色度键）的合成效果</p><p>fade 属性在被去除和保留的区域之间生成插值，可以生成柔化边缘。左边矩阵中的颜色略微超出了容差范围，但是在参考颜色的 tol + fade 的范围内，在原始颜色和右侧矩阵对应单元格中的颜色之间插值。插值取决于 fade 值的大小，以及颜色距离容差边界有多远。</p><p>尝试不同的 tol，fade，minkey，maxkey 和 color 值。观察五个属性如何影响不同的抠图效果，以及 minkey 和 maxkey 值如何相互补充。</p><p>完全去除背景很困难。选取合适的 tol 和 fade 属性值，才能确保第一个图像中的区域对第二个图像起作用。包含很多细节的图像，通常会在抠图和保留区域之间颜色变化的区域，出现轻微的斑点。此外，单一颜色（例如蓝色）基本上满足不了去背景的需要，必须使用一系列值。但是你会发现，希望去除的颜色会出现在想要保留的区域中！平衡所有因素以获得满意的效果，是使用 <code>jit.chromakey</code> 对象最困难的部分。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.chromakey</code> 对象实现两个 Jitter 对象的 chromakeying。可以使用 color 和 tol 属性设置抠图的颜色范围，并用 fade，minkey 和 maxkey 值来定义两个矩阵在合成时的工作方式。<code>suckah</code> 对象放置在 <code>jit.pwindow</code> 上方，点击即可以获取所在位置的颜色。</p><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Chromakeying" scheme="http://uegeek.com/tags/Chromakeying/"/>
    
      <category term="抠图" scheme="http://uegeek.com/tags/%E6%8A%A0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译11 - 矩阵混合</title>
    <link href="http://uegeek.com/180903-jitter-11.html"/>
    <id>http://uegeek.com/180903-jitter-11.html</id>
    <published>2018-09-03T10:23:32.000Z</published>
    <updated>2018-09-04T10:27:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-2.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter09" target="_blank" rel="noopener">Tutorial 9: More Mixing</a></p></blockquote><p>本教程探讨用 <code>jit.scalebias</code> 和 <code>jit.op</code> 实现交叉渐变的技巧。它比 <code>jit.xfade</code> 方法复杂一些，但更灵活。</p><h2 id="混合和交叉淡化"><a href="#混合和交叉淡化" class="headerlink" title="混合和交叉淡化"></a>混合和交叉淡化</h2><p><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">上一章</a>讲解了 <code>jit.xfade</code> 用缩放（乘法）和加法以不同的比例混合两个矩阵。本教程将使用 <code>jit.scalebias</code> 和 <code>jit.op</code> 对象来自动执行这些数学运算。</p><p>这样做有一些好处。首先能清楚地演示混合和交叉渐变的数学过程。其次能看到 <code>jit.op</code> 如何对两个输入矩阵做数学运算。（在<a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">教程 5 </a>中展示了 <code>jit.op</code> 和标量值如何作用于单个矩阵）。第三，它可以分别指定两个矩阵的缩放因子，比 <code>jit.xfade</code> 更灵活。最后，<code>jit.op</code> 可以实现许多不同类型的数学运算，我们可以尝试其他组合矩阵的方法来得到不同的视觉效果。</p><h2 id="再说-Mixing"><a href="#再说-Mixing" class="headerlink" title="再说 Mixing"></a>再说 Mixing</h2><p>打开教程 patch</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter09a.png" alt=""><br>用乘法和加法混合/交叉渐变矩阵</p><p>缩放因子设置为 0~1 之间的 <code>jit.scalebias</code> 将两个视频 scaled down（变暗）。下面会看到用 <code>jit.op</code> 的不同：两个入口的输入都是矩阵。这时 <code>jit.op</code> 分别对每个值执行指定的数学运算，<strong>将左矩阵中的每个值与右矩阵中的对应值配对</strong>。这样我们可以把两个矩阵的所有值相加来混合图像。</p><p>这些乘法和加法的结果与 <code>jit.xfade</code> 对象做内部运算的结果一样。可以试试用 patch 右上角的控件来交叉渐变视频（与上一章几乎完全相同）。</p><p>启动 <code>metro</code> 并使用 <code>Mixer slider</code> 执行从视频 A 到 B 的交叉渐变。</p><p>请注意，渐变值直接作为视频 B 的缩放因子，同时 <code>!- 1</code> 对象用 1 减去该值，得到视频 A 的缩放因子。这样，两个缩放因子的和总是等于 1，就像在 <code>jit.xfade</code> 中一样。</p><h2 id="使用其他运算符组合矩阵"><a href="#使用其他运算符组合矩阵" class="headerlink" title="使用其他运算符组合矩阵"></a>使用其他运算符组合矩阵</h2><p>加法是两个矩阵最常见的运算。更改 <code>jit.op</code> 的 op 属性，可以尝试许多其他运算并查看其视觉效果。</p><p>在 <code>Transition Time</code> 数字框中设置一个非常长的交叉渐变时间（例如 10000 ms）。在 <code>Operator</code> 弹出菜单中选择 + 以外的运算符。现在点击 <code>Go To switch</code> 开始渐变，可以看到两个视频矩阵的运算如何进行。</p><p>弹出菜单包含 <code>jit.op</code> 各种运算符中的一部分。以下是菜单中选项的简要说明。</p><ul><li><code>+</code> 把 B 值加到 A</li><li><code>-m</code> 从 A 中减去 B，然后取模将结果折算回所需的数值范围</li><li><code>max</code> 使用 A B 中较大的值</li><li><code>absdiff</code>从 A 中减去 B，然后取差值的绝对值</li><li><code>|</code> “按位或”; 二进制操作，A 或 B 为 1，结果为 1</li><li><code>^</code> “按位独占或”; 二进制操作，A 和 B 值不相同，结果为 1，否则为 0</li><li><code>&gt;</code> 如果 A 大于 B，结果为 1（或 char 255），否则为 0</li><li><code>&lt;</code> 如果 A 小于 B，结果为 1（或 char 255），否则为 0</li><li><code>&gt;p</code> 如果 A 大于 B，结果为 A，否则为 0</li><li><code>&lt;p</code> 如果 A 小于 B，结果为 A，否则为 0</li></ul><p>其他运算符请查看 <code>jit.op</code> 对象参考文档。</p><p>你也可以直接拖动 <code>jit.scalebias</code> 上方的数字框，单独设置混合比例。还可以尝试超过 0~1 范围的值。</p><h2 id="jit-scalebias-vs-jit-op-op"><a href="#jit-scalebias-vs-jit-op-op" class="headerlink" title="jit.scalebias vs. jit.op @op *"></a>jit.scalebias vs. jit.op @op *</h2><p>这个 patch 用 <code>jit.scalebias</code> 来做缩放乘法，而没有用 <code>jit.op</code> 与 * 运算符。为什么呢？</p><p>当 <code>jit.op</code> 操作 char 数据时，val 属性范围是 0.0~1.0（浮点数）或 0~255（整数）。如果想将 char 数据乘以 0~1 的某个值，用 <code>jit.op</code> 就可以。如果想乘以其他范围的值，就要用 <code>jit.scalebias</code>，它允许 scale 的值超过 0~1 范围。 <code>jit.scalebias</code> 仅用于处理 4 平面 char 矩阵，在这个例子中没问题。所以在这个 patch 中，因为是在 4 平面 char 矩阵上做运算，并且想使用超过 0~1 范围的缩放因子，所以使用了 <code>jit.scalebias</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你可以用 <code>jit.op</code> 对两个不同矩阵中的值执行各种数学运算。 <strong><code>jit.op</code> 对每个值执行指定的数学运算，将左矩阵中的每个值与右矩阵中的对应值配对。当两个矩阵的 dim，planecount 和 type 属性不同时，<code>jit.op</code> 使用左入口矩阵的属性</strong>。在混合两个视频图像时，不同的数学运算符可以生成各种视觉效果。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Math" scheme="http://uegeek.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译10 - 交叉渐变</title>
    <link href="http://uegeek.com/180902-jitter-10.html"/>
    <id>http://uegeek.com/180902-jitter-10.html</id>
    <published>2018-09-02T10:29:21.000Z</published>
    <updated>2018-09-02T10:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-1.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter08" target="_blank" rel="noopener">Tutorial 8: Simple Mixing</a></p></blockquote><p>本教程介绍如何使用 <code>jit.xfade</code> 对象混合和淡入淡出两个图像。</p><h2 id="混合两个视频源"><a href="#混合两个视频源" class="headerlink" title="混合两个视频源"></a>混合两个视频源</h2><p>混合两个图像是视频处理中最常见和最有用的技巧之一。</p><p>最简单的视频混合是将两个图像叠加起来，可以调整任一图像的强度。逐渐淡出一个图像，同时淡入另一个图像，可以创建图像之间的平滑过渡淡入淡出效果。</p><p>Jitter 处理混合和过渡渐变的对象是 <code>jit.xfade</code>。</p><blockquote><p>技术细节：这种类型的混合，将一个矩阵中的每个值，加到另一个矩阵各单元和各平面的相应值上，并输出所有总和的矩阵。但这样让输出图像的值都大于任何一个输入图像，会比原始图像更亮（如果矩阵包含 char 数据，某些值甚至会在 255 处裁剪）。所以在它们相加之前应该减小一个或两个图像的强度。例如，为了按相同比例混合两个图像，在相加之前将它们缩小相等的量（例如，0.5 倍）。</p></blockquote><h2 id="jit-xfade"><a href="#jit-xfade" class="headerlink" title="jit.xfade"></a>jit.xfade</h2><p><strong><code>jit.xfade</code> 对象接收两个输入口的矩阵，缩放两个矩阵中的值，然后把两个矩阵相加并输出混合后的矩阵</strong>。两个输入矩阵缩放因子由 xfade 属性决定。xfade 是 1~0 之间单个（浮点） 数值，是右输入口矩阵的缩放因子。左输入口的矩阵按 1-xfade 的比例缩放。如果逐渐将 xfade 值从 0 增加到 1，输出矩阵将从左输入到右输入淡入淡出。</p><p>打开教程 patch。<code>loadbang</code> 对象自动读取两个源视频。开启<code>metro</code>。开始只会看到左侧视频。拖动滑块更改 xfade 值来控制左右矩阵的混合。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter08a.png" alt=""><br>值为 0.5 时左右矩阵以相同比例混合</p><h2 id="自动交叉渐变"><a href="#自动交叉渐变" class="headerlink" title="自动交叉渐变"></a>自动交叉渐变</h2><p>交叉渐变是最常见的图像转换方式之一。它可以非常缓慢 - 持续几秒 - 或者非常快速，只持续几分之一秒，只比突然跳帧略微平滑。</p><p>在 patch 左上角，有一个从视频 A 到 B （B 到 A）的自动渐变控制器。交叉渐变可以持续用数字框指定的任意过渡时间。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter08b.png" alt=""><br>自动发送不断变化的 xfade 值</p><p>用数字框设置一个比较长的渐变时间（例如 5000 ms），可以看到交叉渐变器的效果。单击 Go To 右侧的开关淡入视频 B。</p><p>Go To 开关实际上是一个范围为 2 的 <code>slider</code>和一个 <code>* 100</code>乘法器，所以只会发送 0 和 100 两个值。单击开关右侧发出值 100，<code>pack</code> 发出消息 <code>100 5000</code>，<code>line</code> 对象在五秒内发出 0~100 的连续值（每 50 毫秒一个新值）。然后将这些值乘以 0.01，得到平滑变化的从 0~1 的 xfade 值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>叠加两个矩阵是最简单的混合视频图像的方法。想要控制两个图像的混合比例，首先要按某个因子缩放每个矩阵。想从一个图像渐变到另一个图像，将一个图像的缩放因子从 1 减小到 0，另一个从 0 增加到 1。</p><p><code>jit.xfade</code> 对象专门混合和/或交叉渐变两个矩阵。xfade 属性指定两个矩阵之间的混合比例。<strong>将 xfade 值从 0 连续增大到 1 可实现平滑的交叉渐变。</strong>可以使用 <code>line</code> 或其他 Max 计时对象来自动化交叉渐变。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译09 - 调整图像颜色</title>
    <link href="http://uegeek.com/180901-jitter-09.html"/>
    <id>http://uegeek.com/180901-jitter-09.html</id>
    <published>2018-09-01T10:28:20.000Z</published>
    <updated>2018-09-01T10:31:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-9.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter07" target="_blank" rel="noopener">Tutorial 7: Image Level Adjustment</a></p></blockquote><p>本教程介绍如何调整 Jitter 矩阵中图像数据的亮度、对比度和饱和度，以及色调和色调旋转(hue rotation)的概念。</p><p>教程 patch 中有两个新对象：<code>jit.brcosa</code> ，控制矩阵中图像数据的亮度（brightness）、对比度（contrast）和饱和度（saturation），以及 <code>jit.hue</code>，旋转图像的色调。</p><h2 id="亮度，对比度和饱和度"><a href="#亮度，对比度和饱和度" class="headerlink" title="亮度，对比度和饱和度"></a>亮度，对比度和饱和度</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07a.png" alt=""><br>打开并查看图像</p><p>点击 <code>read colorwheel.pct</code> 消息框打开文件 colorwheel.pct。点击开关启动 <code>metro</code> 开始显示视频。</p><p>patch 底部 <code>jit.pwindow</code> 中会出现一个色轮：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07b.png" alt="">            </p><p><code>jit.pwindow</code> 展示了穿越过两个对象的图像。我们先谈谈 <code>jit.brcosa</code>，然后再到 <code>jit.hue</code>。</p><p><code>jit.brcosa</code> 对象将 4 平面 char 矩阵看作 ARGB 图像数据，可以调整矩阵数据的亮度、对比度、饱和度。三个属性的默认值是 1.0，这样矩阵保持不变：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07c.png" alt=""><br>使用 <code>jit.brcosa</code> 对象</p><p>更改 <code>jit.brcosa</code> 对象的属性并观察输出矩阵的变化。</p><p>与参考颜色（通常为黑色）相比，图像的亮度是指整体亮度/暗度。更改亮度属性相当于将矩阵中的值乘以该值。亮度值为 0 的图像是黑色；大于 1.0 的亮度值值将逐渐增加所有非 0 单元格直到白色（255）。值 0.5 使图像明显变暗，将值的范围从 0~255 降到 0~127。下面的色轮显示了一些亮度值：<br><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07d.png" alt=""><br>亮度值分别为 0.5，1.5 和 10 的色轮</p><p>用这种方式调整时，单元格的值会被裁剪为 0 和 255。这就是为什么亮度为 10 的那个图像基本上是白色，颜色只显示在原始矩阵中一/多个可见颜色平面（RGB 或平面 1,2 和 3）为 0 的区域。</p><p>图像对比度可以表示为<strong>图像中的颜色偏离整个原始图像的平均亮度的量</strong>（见下文）。当<code>jit.brcosa</code> 的对比度属性增加到 1.0 以上，高于整个矩阵平均亮度的单元变亮（增加），低于平均值的单元变暗（减少）。结果是矩阵图像 dynamic expansion，亮值更亮，暗值更暗。低于 1.0 的对比度设置则相反，较暗的色调变浅，较浅的色调变暗，直到对比度为 0.0，只保留整个图像的平均灰度。负值会以相同的总体对比度反转图像的颜色。</p><blockquote><p>技术细节：矩阵的平均亮度可以通过平均矩阵中所有单元格的值来计算，各平面互不干扰（获得 Alpha，red，green，blue 平面各自的平均值）。然后将三个平面乘以公式：</p><p><code>L = .299 * Red+ .587 * Green + .114 * Blue</code></p><p>L 值就是整个矩阵的平均亮度，<code>jit.brcosa</code> 用它来确定调整对比度时扩展的阈值。</p></blockquote><p>以下是一些对比度设置：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07e.png" alt=""><br>比度设定为 0.3，2，-1 和 100 的色轮</p><p>第一个例子中色轮的对比度急剧下降（单元格的值都接近矩阵的平均亮度）。第二个例子中对比度增加。请注意色轮中间较浅的色调开始接近白色。第三个示例显示了负值对比度。颜色与原始颜色相反，但矩阵的平均亮度与原始颜色相同。最后一个例子是大幅增强对比的结果。该示例中的单元值被极化为0 或 255。</p><p>图像饱和度反映了单元格中主要颜色与次要颜色的比率。随着饱和度值降至 1.0 以下，单元格中的所有颜色值将变得相似，变成去饱和的灰度。高于 1.0 的值将使颜色彼此远离，从而强化了主色。与对比度类似，饱和度属性的负值将反转颜色，但保留与原始颜色相同的亮度关系。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07f.png" alt=""><br>饱和度值为 0.2,2 和 -1 的色轮</p><p>第一个图像是去饱和的，矩阵中的每个单元格值都趋近于该单元格的亮度值。第二张图像过饱和，颜色比原始图像更亮（或更暗）。第三个图像保持色轮的原始亮度，但反转了颜色。</p><h2 id="Hue-and-Cry"><a href="#Hue-and-Cry" class="headerlink" title="Hue and Cry"></a>Hue and Cry</h2><p><code>jit.hue</code> 对象可以旋转输入矩阵的色调。设置 hue_angle 属性会将输入矩阵的色调旋转指定的度数（以度为单位）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07g.png" alt=""><br>hue_angle 属性旋转输入矩阵的色调</p><p>矩阵单元的色调可以看作是其基本颜色（例如，品红色）。图像色调在色轮上从红色变为绿色、蓝色，再变为红色。用 0-360 度数指定的色调值，以及图像的饱和度和亮度，可用描述特定的颜色，这与 RGB 值描述唯一颜色的方式非常相似。向前旋转图像的色调，我们移动颜色光谱的红色部分，使其显示为绿色，光谱的绿色部分显示为蓝色，蓝色部分显示为红色。饱和度和亮度不会改变。负色调旋转会将红色变为蓝色。以 120 度为增量的色调旋转将使图像与原始色调精确地移位一个（或多个）色彩平面。</p><blockquote><p>技术细节：我们的眼睛通过视网膜锥体的感知器来感知颜色（还有一种被称为 rods 的感知器专门探测微弱的光，但是不识别颜色）。我们眼睛的锥体响应三种不同波长的光来区分：L-senstive receptors 感知长波长的光（红色），M-senstive receptors 感知中波长光（绿色），以及 S-senstive receptors 感知短波长的光（蓝色）。跟听觉系统被加权以更好地感知人类语音范围内的频率一样，为了感知环境最关键的中间波长，我们的视锥细胞的分布也经过了加权处理。于是我们眼睛中的绿色感知器大约是其他两种颜色的两倍。所以上面的亮度公式将几乎 60％ 的感知亮度分配给图像中的绿色值。</p></blockquote><p>单击开关以自动化色轮的 hue_angle。请注意，当 hue_angle 达到 360 度时，会恢复原始矩阵图像。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter07h.png" alt=""><br>色轮在各种色调之间旋转（0~360 度）</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.brcosa</code> 和 <code>jit.hue</code> 对象控制输入矩阵的亮度，对比度，饱和度和色调。你可以使用这两个对象调整动态水平（例如自动曝光），校正色彩或实现指定色调的位移。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译08 - 调整颜色</title>
    <link href="http://uegeek.com/180831-jitter-08.html"/>
    <id>http://uegeek.com/180831-jitter-08.html</id>
    <published>2018-08-31T11:04:49.000Z</published>
    <updated>2018-08-31T11:09:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-8.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter06" target="_blank" rel="noopener">Tutorial 6: Adjust Color Levels</a></p></blockquote><h2 id="jit-scalebias"><a href="#jit-scalebias" class="headerlink" title="jit.scalebias"></a>jit.scalebias</h2><p>本教程进一步讨论了<a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">上一章</a>的颜色话题，并介绍专门用于修改矩阵 ARGB 颜色平面的对象：<code>jit.scalebias</code>。</p><p>“scale” 是缩放因子，乘以给定的数值。”bias” 是加上一定的量来偏移某个值。组合乘法和加法，可以实现输入值到输出值的线性映射。</p><p>因为 <code>jit.scalebias</code> 修改图像中的 ARGB 颜色信息，所以它只处理 char 数据类型的 4 平面矩阵。（有关 ARGB 颜色和 char 数据的内容，请参阅 <a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">教程 7</a>）</p><h2 id="用-char-类型数据计算"><a href="#用-char-类型数据计算" class="headerlink" title="用 char 类型数据计算"></a>用 char 类型数据计算</h2><p><a href="https://www.uegeek.com/180830-jitter-06.html" target="_blank" rel="noopener">前一章讲到</a>，char （8位）数据可以表示 0~255 之间的整数值，或 0~1 之间的小数值。比如在<a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 中，我们用 <code>jit.print</code> 输出 0~255 的整数值。但是很多时候要修改矩阵的 char 值（更改其中一个属性）时，Jitter 对象只接收浮点数属性值。这可能有点费解，让我们来看看本教程的 patch。</p><p>打开教程 patch。双击打开中间的 <code>explain_scalebias</code>查看子 patch：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06a.png" alt=""><br>char 数据的浮点类型演示</p><p>在上面的例子中有一个非常小的矩阵。它有 4 个 char 平面，但只有一个单元。这样我们只需要注意矩阵中单个数值的变化。已将平面 2（绿色平面）的值设置为 100。在右侧，把整数值转换为 0~1 之间的小数值：用 100/255，得到 0~1 之间的值 0.392。</p><p><code>jit.scalebias</code> 对象乘上指定的缩放因子，然后再加上偏移因子。<code>jit.scalebias</code> 计算时会把所有值看做浮点数，然后再转换为 char 数据重新存储到矩阵中。</p><p>这里用 <code>scale 2.0</code> 和 <code>bias 0.2</code>消息来设置缩放和偏移因子。缩放因子（乘数）是 2.0，偏移因子（之后添加的偏移）是 0.2。为了了解 <code>jit.scalebias</code> 内部机制，将绿色值看做 <code>0.392 x 2.0 + 0.2</code>，等于 0.984。<code>jit.iter</code> 对象逐一输出每个单元中每个平面的值（矩阵只有一个单元），（以 char 类型存储在矩阵中）为 251（或是 0~1 范围的 0.984）。</p><p>（作为练习，请计算 <code>jit.scalebias</code> 在上面例子中在红色和蓝色平面中产生的值。在原矩阵中这些平面的值为 0，因此结果矩阵中的值将为 <code>0 x 2.0 + 0.2 = 0.2</code>，在 0~255 的范围内等于 51。因此底部的 <code>jit.pwindow</code> 对象显示的 RGB 值是 51 251 51）</p><h2 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h2><p>如果前一部分的讲解你已经理解得很清楚，可以跳过这部分。如果还是不太清楚 char 数据（特别是 <code>jit.scalebias</code>）的数学运算是如何工作的，这里还有一些例子。</p><p>从左到右逐个点击 <code>preset</code> 对象中的每个预设值。下面我们解释每个预设。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/tut%2006%20presets.png" alt=""></p><ol><li><p>原始矩阵的绿色平面中的值为 255.（相当于 0~1 范围的 1.0） <code>jit.scalebias</code> 将其乘以 0.5 得到 127.5; 但是将值存储为 char 时，<code>jit.scalebias</code> 会截断小数部分，将值存储为 127。</p><blockquote><p>这产生了相当不精确的结果。（0~255 范围的 127 等于 0~1 范围内的 0.498，而不是我们期望的 0.5）但用 8 位 char 数据只能这样了。如果需要更高的精度，char 数据就不适合，需要用 long，float32 或 float64 数据的矩阵，以及 <code>jit.op @op *</code> 和 <code>jit.op @op +</code> 对象。</p></blockquote></li><li><p>原始值为 100，将它加倍（缩放因子 2.0）会得到预期结果 200。这样不会有精度损失。</p></li><li>原始值为 100（0.392）。缩放 1.0 倍保持不变，然后加上 -0.2 （也就是减去 0.2）得到结果 49（即 0.192）。</li><li><code>0.392 x 2.0 + 0.2 = 0.984</code>。在 0~255 的范围内为 251。</li><li>此示例和下一个示例说明当乘法和加法运算的结果超过 8 位字符的容量时会发生什么。<code>jit.scalebias</code> 会直接裁剪结果为 char 的最大或最小值。这里，0.392 x 4.0  = 1.568（即 100x4 = 400），因此取上限为 255。</li><li>在另一个方向，0.392 - 0.5 = -0.108，因此结果为 0。</li></ol><p>注意，这些误差和裁剪只发生在将结果重新存储为 char 时。在此之前，这些值在内部用浮点数计算，可以保证精度。即使乘法使内部值超出0~1 范围，也不会做裁剪，而且加法运算可以让其回到范围。这里 0.392 x 3.0（= 1.176）- 0.5 = 0.676。存储为 char 时会产生小的误差。0.676 在 0~255 范围内等于 172.38，但是小数部分会被截断并存储为 172（即 0.675）。如果没有变化，比例因子应为 1，偏移量应为 0。</p><p>你可以尝试更多的值，直到完全了解 <code>jit.scalebias</code> 以及 8 位 char 数据产生的结果。完成后关闭 [explain_scalebias] 窗口。</p><h2 id="调整图像的颜色亮度"><a href="#调整图像的颜色亮度" class="headerlink" title="调整图像的颜色亮度"></a>调整图像的颜色亮度</h2><p>现在将 <code>jit.scalebias</code> 应用于彩色图像。在教程 patch 的左上角可以看到熟悉的配置：<code>jit.movi​​e</code> 对象，加载视频的 <code>read</code> 消息，和从 <code>jit.movi​​e</code> 触发 jit_matrix 消息的 <code>metro</code>对象。在这个 patch 中，<code>jit.scalebias</code> 用乘法和加法来修改矩阵。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06b.png" alt=""><br>加载图片或视频</p><p>点击 <code>read chilis.jpg</code> 读取 JPEG 静态图像（而非视频）到 <code>jit.movi​​e</code>。QuickTime 可以处理各种媒体格式，包括 PICT 或 JPEG 格式的静止图像。<code>jit.movi​​e</code> 将静止图像视为 1 帧长的视频。</p><p><code>jit.movi​​e</code> 的输出将传到 <code>jit.scalebias</code> 处理，然后显示在 <code>jit.pwindow</code> 中（现在先忽略 <code>jit.matrix</code> 对象。我们在本章后面讨论）。可以修改 <code>jit.scalebias</code> 的 scale 和 bias 属性来更改值。</p><p>点击开关启动 <code>metro</code>。拖动 <code>scale $1</code> 消息框上方的数字框，将 scale 属性值增加到 1.25。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06h.png" alt=""></p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06c.png" alt=""><br>增加图像亮度; scale 值越大亮度越大</p><p>这将使图像的 4 个平面的所有非零值放大到 1.25 倍（增加 25％）。请注意，乘法会让较大的被乘数增加更多值。例如，如果原始矩阵中某单元格的红色值为 200，它将增加到 250（净增加 50），而同一单元格的蓝色值可能从 30 增加到 37（净增加 7）。</p><ul><li>尝试将 scale 增加到非常大，如 20。原始矩阵中 13 或更大的值将被增大到最大值 255（甚至非常小的值也会增加到可见水平），产生人为的过度曝光。</li><li>尝试将 scale 降低到 0~1 之间。这会使图像变暗。scale ≤ 0 会将所有值设置为 0。</li><li>将 scale 属性恢复为 1。现在尝试调整 bias 属性，为矩阵中所有值添加常量。正值使图像变亮，负值使图像变暗。</li></ul><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06d.png" alt=""><br>以常量提升（或降低）亮度</p><p>还可以尝试几种更极端的 scale 和 bias 设置。设置 scale 为 40，bias 为 -20。这会将几乎所有值推到 255 或 0，除白色或黑色之外仅留下少数颜色。尝试设置 scale 为 -1，bias 为 1。高低值会互换，反转颜色。继续降低 scale（比如 -4 或 -8）会产生类似的反转，但只有原始值较低的值才会被正 bias 提升回 0~1 范围。</p><h2 id="单独调整平面"><a href="#单独调整平面" class="headerlink" title="单独调整平面"></a>单独调整平面</h2><p>你可以用 scale，abias，rscale，rbias 等属性在 <code>jit.scalebias</code> 中单独调整每个平面中的亮度。</p><p>将 scale 设置回 1，将 bias 设置回 0。然后提供新的值来独立调整每个颜色平面。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06e.png" alt=""><br>调整每个颜色平面的亮度</p><p>这里有一个可以同时调整三个颜色平面缩放比例的控制器，让过程更具交互性。单击或拖动 <code>swatch</code> 对象时，它发送一个表示鼠标所在位置 RGB 颜色值的列表。这些值之前以 0~255 范围表示，现在已经被改为 0.0~1.0 的值（如果需要，inspector 中有一个复选框可选择用旧样式输出）。用 <code>unpack</code> 拆分列表为三个单独的浮点数来改变 <code>jit.scalebias</code> 的 rscale，gscale 和 bscale 属性 。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06f.png" alt=""><br>用 <code>swatch</code> 的值作为 <code>jit.scalebias</code> 的属性</p><ul><li>拖动 <code>swatch</code> 同时缩放 RGB 三个平面。这会产生 0~1 范围内的缩放值来降低所有亮度，让图像稍微变暗。</li><li>可以在不同图像上尝试这些操作。读取其他彩色图像如 colorswatch.pict 或 wheel.mov， 并尝试调整颜色亮度。</li></ul><h2 id="重新分配矩阵的平面"><a href="#重新分配矩阵的平面" class="headerlink" title="重新分配矩阵的平面"></a>重新分配矩阵的平面</h2><p>在<a href="https://www.uegeek.com/180830-jitter-06.html" target="_blank" rel="noopener">上一个教程</a>中，我们使用 <code>jit.unpack</code> 和 <code>jit.pack</code> 来重新组合矩阵的平面。使用 <code>jit.matrix</code> 对象的<code>planemap</code> 属性也可以做到。在这个例子中，用 <code>jit.matrix</code> 传递 <code>jit.movi​​e</code>的输出来演示如何设置 <code>planemap</code> 属性。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter06g.png" alt="">        </p><p>用 <code>jit.matrix</code> 重新分配矩阵的平面</p><p><code>jit.matrix</code> 的 <code>planemap</code> 属性可以映射（分配）输入矩阵的任何平面到输出矩阵的任何平面上。planemap 后面跟的数字表示矩阵中有多少平面（在本例中为 4）。列表中的每个位置代表输出平面（第一个代表输出平面 0，第二个代表平面 1，等等），数字表示分配给它的输入平面。默认情况下，平面值为 0 1 2 3（等），输入矩阵中的每个平面都分配给输出矩阵中的同一平面。可以随意更改这些映射。例如，如果发送消息 <code>planemap 0 3 2 1</code> 给 <code>jit.matrix</code> ，会把输入平面 3 分配给输出平面 1（3 位于输出平面 1 的列表位置），把输入平面 1 输出到平面 3。这样就调换了图像的红色和蓝色平面。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/tut%2006%20planemap.png" alt="">    </p><ul><li><p>点击 <code>read wheel.mov</code> 消息框并启动 <code>metro</code> 显示视频。（设置<code>jit.scalebias</code> scale 属性为 1，bias 属性为 0，就可以在 <code>jit.pwindow</code> 中看到未改变的图像）在 patch 的右下角，单击<code>planemap 0 3 2 1</code> 消息框交换矩阵的红色和蓝色平面。单击消息框 <code>planemap 0 1 2 3</code> 恢复正常的平面映射。如果设置所有 RGB 输出平面设置为相同的输入平面，将在三个 RGB 平面中得到相等的值，从而产生灰度图像。</p></li><li><p>单击消息框 <code>planemap 0 1 1 1</code> 查看效果。三个 RGB 平面在列表中的值都是 1，因此原始的红色平面用来输出矩阵的所有 RGB 平面。用一个 <code>coll</code> 对象存储所有平面映射的组合，发送到 <code>jit.matrix</code> 来更改 <code>planemap</code> 属性。</p></li><li><p>双击 patcher <code>rotatecolorplanes</code> 查看子 patch。里面有一个 1 到 6 的计数器，逐一执行主 patch 中 <code>coll</code> 对象中的不同映射。（当它关闭时会发出数字 1 重置为默认平面映射）<br>  <img src="http://7xjpra.com1.z0.glb.clouddn.com/tut-06-counter.png" alt=""></p></li><li><p>点击主 patch <code>rotatecolorplanes</code> 对象上方的开关，以每秒切换一次设置的速率，逐一执行不同的平面映射。将右输入口上方的数字框更改为较小的值（例如 80），查看快速重新分配平面的闪烁效果。</p></li></ul><p>在下一章节中，你将了解如何使用 <code>jit.hue</code> 以更微妙的方式调整图像色调，以及使用 <code>jit.brcosa</code> 调整颜色的其他方法。</p><h2 id="读取和导入图像"><a href="#读取和导入图像" class="headerlink" title="读取和导入图像"></a>读取和导入图像</h2><p>在本教程 patch 中，将三种不同类型的图像加载到 <code>jit.movi​​e</code> 中：PICT 和 JPEG 静止图像，以及 QuickTime 视频。在视频对象中读入静止图像看起来有点奇怪，但 QuickTime 确实可以播放多种类型的媒体文件，<code>jit.movi​​e</code> 知道如何读取它们。（<code>jit.movi​​e</code> 还可以读入 AIFF 音频文件，用 start 和 stop 消息播放，用 time 属性跳转到不同的位置等等。当然这时看不到矩阵的任何视觉内容）</p><p><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">如教程 5 所示</a>，用 <code>importmovie</code> 消息加载静止图像到 <code>jit.matrix</code> 中很方便。用这种方式导入 QuickTime 视频，只有一帧存储在 <code>jit.matrix</code> 中。</p><p>在这个 patch 中，我们用 <code>jit.movi​​e</code> 加载所有图像。原因一是我们要加载整个视频（不只是视频的一帧）。原因二是想演示 <code>jit.matrix</code> 的 planemap 属性。矩阵有实际输入（左入口传入 jit_matrix 消息）时，<code>planemap</code> 属性才起作用。如果用 <code>importmovie</code> 直接导入图像到 <code>jit.matrix</code> ，<code>planemap</code> 不起作用。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.scalebias</code> 用乘法和加法来修改 4 平面 char 矩阵中指定的平面（或所有平面）的值。scale 是矩阵中的每个值要乘上的缩放因子；bias 是乘法之后被加到每个单元的值。scale 和 bias 属性影响矩阵的所有平面。如果想一次只影响一个平面，请使用特定的属性例如 ascale，abias，rscale，rbias 等。</p><p>必须用浮点数定义这些属性值。当执行乘法和加法运算时，<code>jit.scalebias</code> 将 char 值视为 0~1 范围内的小数值，使用 floats 执行数学运算，然后将结果转换回 char（0~255 之间的整数）并存储。超出 0~1 范围的结果，在转换回 char 之前截取为 0 或 1。</p><p>可以用 <code>jit.matrix</code> 的 <code>planemap</code> 属性重新分配矩阵的平面。<strong><code>planemap</code> 的参数按顺序列出输出平面，列表中的值是要分配给每个输出平面的输入平面</strong>。例如，要将输入矩阵的平面 1 分配给输出矩阵的所有四个平面，属性应设置为 <code>planemap 1 1 1 1</code>。</p><p><code>jit.scalebias</code> 提供了强大的工具来调整 4 平面 char（ARGB 颜色）矩阵中的颜色值。下一章节将介绍更多此类工具。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译07 - ARGB 颜色</title>
    <link href="http://uegeek.com/180830-jitter-07.html"/>
    <id>http://uegeek.com/180830-jitter-07.html</id>
    <published>2018-08-30T10:00:18.000Z</published>
    <updated>2018-08-31T11:09:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-7.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter05" target="_blank" rel="noopener">Tutorial 5: ARGB Color</a></p></blockquote><h2 id="Jitter-中的颜色"><a href="#Jitter-中的颜色" class="headerlink" title="Jitter 中的颜色"></a>Jitter 中的颜色</h2><p>本节将讨论如何在 Jitter 中处理颜色，主要讲解用数字表示颜色，而不涉及把数字可视化为颜色。用数字表示颜色有许多方法，而关于色彩理论的全面讨论 - 光和物质如何产生色彩感觉 - 远远超出了本教程的范围。如果想了解颜色相关的理论和/或颜色数值表示的更多信息，可以查看参考书目。</p><p>本节重点说明 Jitter 表示颜色的方法，以及如何在矩阵中实现。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/tut5%20patch.png" alt=""></p><h2 id="颜色组成：RGB"><a href="#颜色组成：RGB" class="headerlink" title="颜色组成：RGB"></a>颜色组成：RGB</h2><p>混合红色，绿色和蓝色可以产生任意颜色 - 每种颜色都有一定的亮度（intensity）。这是「加法合成（additive synthesis）」 - 添加一定量的三原色光来生成颜色（与此相反的是减法合成：混合有色颜料，如油漆，吸收某些颜色的光并反射其余部分）。这样就可以用红色，绿色和蓝色相对应的频率强度来描述任意颜色。</p><p>在 Jitter 中一般用红色，绿色和蓝色的精确亮度组合来描述颜色。对于图像的每个像素 - 无论是视频，图片还是其他 2D 矩阵 - 至少需要三个值表示三原色。屏幕上的彩色图像一般使用至少 3 个平面的 2D 矩阵。</p><h2 id="Alpha-通道"><a href="#Alpha-通道" class="headerlink" title="Alpha 通道"></a>Alpha 通道</h2><p>第 4 个平面一般是 alpha 通道 - 它存储像素的透明度信息。Jitter 矩阵中一般都会包含颜色透明度的 alpha 通道。多数情况下，<strong>alpha 通道存储在平面 0（矩阵平面从 0 开始编号），RGB 值存储在 1,2 和 3 平面中</strong>。</p><h2 id="颜色数据：char，long-或-float"><a href="#颜色数据：char，long-或-float" class="headerlink" title="颜色数据：char，long 或 float"></a>颜色数据：char，long 或 float</h2><p>在计算机中用 8 位信息来表示每个基本颜色值。8 位能够表达 256（2 的 8 次幂）个不同值。如果分别用 8 位表示红色、绿色、蓝色，总共可以表示 16,777,216（2 的 24 次方）种不同颜色，足以覆盖人眼能够区分的所有颜色渐变。</p><p>因为 8 位分辨率已经可以表示所有基本颜色值，所以颜色信息矩阵 4 个平面中的值用 8 位 char 类型就足够了。当然 Jitter 也允许用 long，float32 或 float64 类型，只不过这会浪费内存。全帧视频图像要处理大量的像素（640x480 图像有 307,200 像素），为了节省内存和加快处理速度，最好使用 char 数据类型。</p><p>8 位 char 数据可以表示 0~255 之间的数字，或者 0~1 之间的灰度。包含 char 数据的 Jitter 对象，通常以 0~1 范围内浮点数的形式从其他 Max 对象接收数值。然后在内部计算时将浮点数转换为对应的 char 值（有一些例外，例如 <code>jit.op</code> 可以接收 0~1 的浮点数或右入口的 0~255 的整数）。关于在 Jitter 矩阵中使用 char 数据类型的更多内容，请参阅教程<a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">什么是矩阵？</a></p><h2 id="分离矩阵的平面"><a href="#分离矩阵的平面" class="headerlink" title="分离矩阵的平面"></a>分离矩阵的平面</h2><p>在示例 patch 的顶部有两个视频。一个是街机游戏，另一个是视频校准的标准颜色条。打开 <code>metro</code>对象（用来反复触发矩阵对象）可以查看。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05a.png" alt=""><br>观看视频或静止图像</p><p>单击 <code>metro 30</code>对象上方标有 “show movie” 的按钮查看视频</p><p>示例 patch 用 <code>jit.unpack</code> 对象将颜色信息矩阵分解为 4 个平面，可以单独查看和修改每个平面。与 Max 对象 <code>unpack</code> 将列表拆开成单个数字类似，<code>jit.unpack</code> 将多平面矩阵分解为单平面矩阵。可以输入参数来指定矩阵中有多少个平面，默认是 4 个平面，这是颜色数据的标准。想看到红色，绿色和蓝色屏幕的内容，就将平面 1,2 和 3 发送到 <code>jit.pwindow</code>。因为这里不关心 alpha，所以不显示平面 0。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05b.png" alt=""><br>将多平面矩阵拆为单平面矩阵</p><p>可以用三个单色图像查看每个颜色平面的内容。较亮的像素表示该颜色值较大。将每个矩阵发送到 <code>jit.op</code> 可以单独控制每种颜色的强度，并改变颜色平衡。然后将单个（改变后的）矩阵发送到 <code>jit.pack</code>，重新组合为 4 平面矩阵在 <code>jit.pwindow</code> 中显示。</p><p>尝试将绿色和蓝色的强度降低到 0.12，生成更偏红色的图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05c.png" alt=""><br>降低某些颜色的亮度来改变颜色平衡</p><h2 id="颜色交换"><a href="#颜色交换" class="headerlink" title="颜色交换"></a>颜色交换</h2><p>为了演示另一种技巧，将每个颜色平面发送到 <code>gate</code> 对象，这样每个矩阵都可以 <code>route</code> 到 <code>jit.pack</code> 的不同入口（颜色平面）。这样就重新定义了每个平面，并且从 patch 左侧的 <code>coll</code> 对象中选择选项来尝试所有可能的颜色组合。</p><p>拖动标记为 “Rotate RGB planes” 的数字框，尝试重新分配三个颜色平面。（请注意，平面 0 直接从 <code>jit.unpack</code> 发送到 <code>jit.pack</code> ; 它是触发矩阵输出到 <code>jit.pwindow</code>的 <code>jit.pack</code>的左入口收到的 <code>jit_matrix</code> 消息）如果选择 coll 中的选项 3，会得到如下结果：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05d.png" alt=""><br>重新分配各个颜色平面; 红色和绿色平面相互交换</p><p>上面的示例显示原始的绿色和蓝色平面减少为原来的 0.12，并在发送到 <code>jit.pack</code>之前，用 <code>gate</code> 调换红色和绿色平面，得到更偏绿色的图像。<code>coll</code> 对象包含 RGB 平面所有可能的排列组合。</p><p>双击 <code>coll</code> 对象可以查看其内容：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05f.png" alt=""><br>RGB 平面分配的排列组合</p><p>来自 <code>coll</code> 列表中的元素被 <code>unpack</code> 并发送给 3 个 <code>gate</code> 对象。发送到 <code>coll</code> 的数字也会发送给 umenu（标签模式）用单词显示颜色状态 - 现在显示为 “Green-Red-Blue”。</p><h2 id="颜色自动变化"><a href="#颜色自动变化" class="headerlink" title="颜色自动变化"></a>颜色自动变化</h2><p>让我们再来做一个颜色修改练习：制作不断更改颜色的缩放和旋转的自动化流程。</p><p>点击标记为 “Automate color changes” 的开关。三个颜色平面的缩放因子都在不断变化。双击 patch <code>colorgames</code> 对象查看子 patch 的内容。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter05e.png" alt=""><br>[colorgames]子 patch</p><p>子 patch 用 <code>line</code> 对象为每个颜色缩放因子发送 0.5~1 的值。红色系数每 3 秒变化一次，绿色每 4 秒变化一次，蓝色每 5 秒变化一次（这三个 line 对象每 60 秒同步一次）。每隔 60 秒，<code>metro</code> 计数器会选择一个新的颜色组合。</p><p>你可以在不同的源图像上尝试所有颜色组合。回到主 patch，点击标记为 “Show movie” 的开关停止 <code>metro</code>。（也可以用这个开关来启动和停止 <code>jit.movi​​e</code> 播放视频。如果不需要观看，就没必要持续播放）现在点击标有 “Show colorbars ” 的开关来显示颜色栏。试着更改此图像上的 scale 和 rotation 系数。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>当 <code>jit.window</code> 或 <code>jit.pwindow</code> 接收<strong>单平面</strong> 2D 矩阵时，会显示为单色（灰度）图像。当接收到 <strong>4 平面</strong> 2D 矩阵时，会将平面解析为 alpha，red，green 和 blue 值并显示相应颜色。<strong>Jitter 最常用 ARGB 4 平面矩阵来表示颜色。</strong></p><p>Jitter 颜色数据以 char 数据类型存储，因为所有基本颜色只需要 8 位精度就可以完全覆盖。大多数与 QuickTime 相关的对象（例如 <code>jit.movi​​e</code>）和许多专门用于操作颜色的对象（例如 <code>jit.brcosa</code> 和 <code>jit.colorspace</code>）都使用 4 平面 char 数据的 2D 矩阵。（许多对象会自适应其他数据类型。如有疑问请查看相应文档）。<strong>char 数据的范围是 0~255 的证书，或者 0~1 的浮点数</strong>。大多数情况下，包含 char 数据的对象从其他 Max 对象接收 0~1 的浮点数值。</p><p><strong><code>jit.unpack</code> 可以拆分多平面矩阵为单平面矩阵。<code>jit.pack</code> 打包单平面矩阵成一个多平面矩阵。</strong>单独处理每个平面可以控制图像的色彩平衡，甚至可以重新定义各个平面。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译06 - 控制视频播放</title>
    <link href="http://uegeek.com/180829-jitter-06.html"/>
    <id>http://uegeek.com/180829-jitter-06.html</id>
    <published>2018-08-29T13:15:21.000Z</published>
    <updated>2018-08-29T13:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-6.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter04" target="_blank" rel="noopener">Tutorial 4: Controlling Movie Playback</a></p></blockquote><p>本教程讲解在 Jitter 中播放 QuickTime 视频的进阶知识。我们将学习如何获得正在播放的视频的信息，以及如何更改速度、音量和循环点来控制视频的播放。</p><p>你应该已经熟悉 patch 中的两个 Jitter 对象： <code>jit.movi​​e</code> 和 <code>jit.pwindow</code>。其余部分尝试改变已加载到 <code>jit.movi​​e</code> 对象中的视频的播放行为。</p><p>patch 的左边部分我们很熟悉了：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04a.png" alt=""><br>打开并播放视频</p><p>点击消息框 <code>read crashtest.mov</code>，打开文件。</p><p><code>jit.movi​​e</code> 一读入视频就开始播放。这个视频有配乐，因此视频加载后会立即听到音乐。视频配乐由计算机内置音响而不是 MSP 播放。如果不希望听到声音，可以将消息框 <code>vol $</code> 的数字 1 改为 0。</p><p>即使视频正在播放，<code>jit.pwindow</code> 没有显示任何东西，因为 <code>jit.movi​​e</code> 需要 bang 消息才能发送矩阵到 <code>jit.pwindow</code>。单击连接到其入口的开关，启动 <code>metro</code> 对象。这时视频图像出现在 <code>jit.pwindow</code> 中。先忽略 <code>gettime</code> 消息，等会我们会提到。</p><h2 id="获取视频信息"><a href="#获取视频信息" class="headerlink" title="获取视频信息"></a>获取视频信息</h2><p><code>jit.movi​​e</code> 打开新的视频时，会读取视频的大量信息（包含在视频的标题中），包括视频的长度、有多少帧、播放速度等。我们用这些元数据来控制视频播放。</p><blockquote><p>要点：与许多可手动设置或由对象本身设置的 Jitter 属性不同， <code>jit.movi​​e</code> 的许多属性都依赖于当前的视频文件。不同视频生成不同的设置。</p></blockquote><p>要对 QuickTime 视频做的第一件事是读取元数据属性。可以向 <code>jit.movi​​e</code> 发送 <code>get</code> 消息来检索。然后解析对象最右输出口的响应消息。我们需要的信息是帧速率，时间单位(time scale)（一秒钟内 “QuickTime 时间单位” 的数量），持续时间（QuickTime 的单位），播放速率和音量。这些都通过带有 <code>getfps, gettimescale, getduration, getrate, getvol</code>的消息框获得。</p><p>让 <code>jit.movi​​e</code> 打开一个视频并播放时（发送<code>read</code>消息），它会向右输出口发送一条消息，告诉你它已找到视频并知道如何播放。如果要将打印对象连接到 <code>jit.movi​​e</code> 的右输出口并重新加载影片，会在 Max Console 中看到：<code>read crashtest.mov 1</code>。</p><p>在这个 patch 中，<code>jit.movi​​e</code> 的右输出口连接了一个 <code>route</code> 对象。加载成功后它收到 <code>read</code> 消息并传递给 <code>unpack</code> 和 <code>select</code>，再触发 <code>get</code>消息。如果无法找到 crashtest.mov 文件，会在文件名后看到 1 以外的数字，并且不会发出请求。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04b.png" alt=""><br>自动查询 <code>jit.movi​​e</code> 对象</p><p>除了捕获 <code>read</code> 消息之外，<code>route</code> 对象在接收到视频信息后做分发。Jitter 属性一般都由在 patch 中设置为相同格式的对象输出：属性的名称，后跟需要设置的信息。<code>route</code> 出口连接了数字框，以显示分发的值。虽然还不知道那些值代表什么，但是每次 <code>jit.movi​​e</code> 成功加载新视频时都会显示属性。</p><h2 id="开始，停止和减速"><a href="#开始，停止和减速" class="headerlink" title="开始，停止和减速"></a>开始，停止和减速</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04c.png" alt=""><br>一些简单的视频播放控件</p><p>patch 的顶部有一些可以更改 <code>jit.movi​​e</code> 回放行为的控件。向 <code>jit.movi​​e</code> 发送 <code>stop</code>消息，将在视频当前帧停止播放。发送 <code>start</code> 消息将从上次停止的位置恢复播放。视频播放停止时，视频文件中的所有音轨也都将停止。停止和启动视频对 <code>jit.movi​​e</code> 对象的矩阵输出没有影响，该输出仍然由 <code>metro</code> 对象控制。如果在开启 <code>metro</code> 的情况下停止播放视频，仍将以 <code>metro</code> 的速度收到新的矩阵对象（这里是每秒 25 次），虽然所有矩阵都是相同的。</p><p>更改视频的速率将改变音视频内容的播放速度。正的速率值使视频向前播放，值为 1 表示正常播放速度。负值将使视频倒退，速率为 0 将停止播放。<code>jit.movi​​e</code> 的速度属性以浮点数为参数，因此值 0.5 会使视频播放速度减半，值 -2.3 以超过两倍的速度向后回放。调整这个值时，音轨会加速、减速、向后播放，跟视频保持同步。一旦视频到达其最后一帧（或回放时的第一帧），它将循环到文件的另一端。将 <code>jit.movi​​e</code> 的 loop 属性设置为 0（无循环），1（常规循环）或 2（回文循环），可以更改此行为。</p><p><code>vol</code> 属性控制视频音轨的音量（响度）。1 为全音量，0 将关闭声音。</p><p>加载视频时，速率和音量属性都由 pathc 中间的消息框初始化。它们会给出每个 QuickTime 影片中存储的值。</p><h2 id="时间属性"><a href="#时间属性" class="headerlink" title="时间属性"></a>时间属性</h2><p>之前查询了三个属性：duration，timescale 和 fps，告诉我们视频文件如何处理时间。Duration 说明了视频的总长度。这个值不以毫秒或帧表示，而是以 QuickTime 时间单位表示。每个时间单位的实际长度，取决于视频的时间单位。视频的 timescale 是每秒视频的分辨率。视频的duration / timescale 会得出视频的大致长度，以秒为单位。例如， crashtest.mov 文件有一个持续时间为 2836 个时间单位和 600 的 timescale。视频大约持续 4.73 秒。如果想要用 2 秒钟播放视频，可以将 <code>jit.movi​​e</code> 设置 <code>time 1200</code>（1200 时间单位除以 600 单位/秒的时间刻度得到 2 秒）。</p><p>视频中的 fps （或每秒帧数）说明每秒显示多少单独的视频图像。fps 越高，视频播放就越平滑（假设每帧都不一样）。常见的 fps 速率是15, 24, 29.97 和 30. 这个例子中的视频以每秒 15 帧的速度播放，也就是每 40 个时间单位，或大约每 66.7毫秒，会更新一个视频帧。如果用 crashtest.mov 的持续时间，除以视频中每帧的 time units，可以得到视频文件有 70 帧。如果需要，可以用 <code>getframecount</code> 消息查询 <code>jit.movi​​e</code> 视频中的总帧数。</p><h2 id="截取和循环"><a href="#截取和循环" class="headerlink" title="截取和循环"></a>截取和循环</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04d.png" alt=""><br>显示和设置当前播放帧</p><p>patch 底部区域包含两个进一步操作视频播放的控件。左侧的数字框显示视频当前正在播放的帧。该值由 patch 顶部的 <code>metro</code> 对象发送到 <code>jit.movi​​e</code> 的 <code>gettime</code> 消息更新; 每次输出新的一帧时，时间都会更新。如果停止视频传输（向 <code>jit.movi​​e</code> 发送 <code>stop</code>消息），可以拖动数字框来“截取”视频。视频会跳转到 <code>frame</code> 消息指定的参数那一帧。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter04e.png" alt=""><br>设置视频中的循环点</p><p>用两个整数参数设置 <code>looppoints</code>属性，可以将循环点（指定循环开始和结束的时间值）发送到 <code>jit.movi​​e</code>。教程 patch 中的 rslider 可以指定 <code>jit.movi​​e</code> 的循环区间。在加载视频时查询属性，将 rslider 的大小设置为视频的时长。可以发送不带参数的  <code>looppoints</code> 消息重置循环点。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.movi​​e</code> 提供了一些简单的属性来改变 QuickTime 播放内容的方式。可以使用这些消息停止和开始播放视频。速度属性可以改变播放速度和视频播放的方向。使用 vol 属性控制视频音轨的音量。</p><p>查询 duration，time scale 和 fps 等属性可获取加载到 <code>jit.movi​​e</code> 中视频的属性。用 <code>frame</code> 消息可跳转到视频中的特定帧，并且可以设置和检索循环点。发送 <code>gettime</code> 消息可以查询视频的当前时间位置​​。</p><p>更多强大的功能（例如编辑和保存视频）将在后面的教程中讨论。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译05 - 矩阵的数学运算</title>
    <link href="http://uegeek.com/180828-jitter-05.html"/>
    <id>http://uegeek.com/180828-jitter-05.html</id>
    <published>2018-08-28T11:37:40.000Z</published>
    <updated>2018-08-29T13:22:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-5.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter03" target="_blank" rel="noopener">Tutorial 3: Math Operations on a Matrix</a></p></blockquote><p>本教程介绍如何对存储在 Jitter 矩阵中的数据做简单的数学运算，使用 <code>jit.op</code> 对象来缩放矩阵单元格或单个平面。</p><p>教程分为三个​​简单的例子，你可以使用 <code>jit.op</code> 对象执行这些操作。<code>jit.op</code> 对矩阵的所有对象而不是单个数字执行数学运算。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03a.png" alt=""><br>向矩阵中的所有单元格添加常量</p><p>第一个示例显示了连接到 <code>jit.op</code> 的 <code>jit.matrix</code> 对象，其输出可由 <code>jit.pwindow</code> 查看。每次改变连接到 <code>jit.op</code> 右输入口的数字框，都会从 <code>jit.matrix</code> 输出一个新的矩阵。从参数中可以看出，<code>jit.matrix</code> 生成一个 4x3 的单平面 char（0-255） 矩阵。<code>jit.pwindow</code> 把这个矩阵可视化为一个灰度图像。拖动数字框将改变显示的灰度级别（黑色 0 ~ 白色 255）。</p><p>请注意，<code>jit.matrix</code> 输出了一个所有单元格都为 0 的矩阵。如果将 <code>jit.matrix</code> 和 <code>jit.pwindow</code> 对象绕过 <code>jit.op</code> 连接在一起，无论向 <code>jit.matrix</code> 发送多少次 bang 消息，都只能看到黑色图像。<code>jit.op</code> 向 <code>jit.matrix</code> 和 <code>jit.op</code> 之间的矩阵的所有单元都加上了一个值（由数字框给定）。</p><h2 id="操作符"><a href="#操作符" class="headerlink" title="@ 操作符"></a>@ 操作符</h2><p><code>jit.op</code> 根据参数指定的运算（用 @op 表示）向矩阵加了一个值（不是乘或除）。@op 之后的参数是一个符号（或符号列表），它定义了 <code>jit.op</code> 在输入矩阵上执行的数学运算。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03a.png" alt=""></p><p>在这个例子中，op 属性设置为 + ，它对从左入口输入的任何矩阵都执行加法操作。右侧入口中的整数值会加到矩阵中的所有单元格。这个值被称为标量（scalar），因为它向整个矩阵添加了相同的值（在教程 11 中我们会展示 <code>jit.op</code> 如何使用两个矩阵进行数学运算）。</p><blockquote><p>要点：更改 <code>jit.op</code> 右侧入口中的标量值不会输出新矩阵。如果断开数字框和按钮之间的接线，<code>jit.pwindow</code> 将停止显示任何新内容。原因在于，大多数 Jitter 对象与大多数 Max 对象一样，仅在数据进入其最左侧入口时才会输出数据。</p><p>在上面的例子中，每次更改数字框时 <code>jit.op</code> 都会存储新的标量值。此时按钮发送一个 bang 给 <code>jit.matrix</code>，让它将新的矩阵（所有值设置为 0）发送到 <code>jit.op</code> 的左入口，触发输出矩阵。</p><p>如果在按钮上方的接线上放置一个断点，然后 shift-cmd-T 逐步执行消息，就能看到它是如何运作的。（有关如何使用断点功能跟踪 Max 消息，请参阅教程：消息顺序和调试）</p></blockquote><p>使用 <code>jit.op</code> 的 val 属性，标量值也可以作为常量。例如，如果想要为矩阵的所有单元格添加 134，可以使用 val 属性并省去数字框：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03b.png" alt="">            </p><p>类似地，如果想要更改由任何给定的 <code>jit.op</code> 对象执行的数学运算，可以用消息 <code>op</code> 后跟数学符号，发送到对象的左入口。</p><h2 id="多平面数据的数学运算"><a href="#多平面数据的数学运算" class="headerlink" title="多平面数据的数学运算"></a>多平面数据的数学运算</h2><p>第二个示例显示了使用 <code>jit.op</code> 将值传入矩阵的更复杂的例子。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03c.png" alt=""><br>为矩阵的每个平面使用单独的标量</p><p>这个 patch 跟第一个类似，区别在于现在使用的是 4 平面矩阵。这由 <code>jit.matrix</code> 的第一个参数给出。<code>jit.pwindow</code> 现在有颜色了，它正在解析矩阵 α/红/绿/蓝 4 个单独存储颜色通道的平面。这个例子中的 <code>jit.op</code> 包含 op 属性的四个符号的列表：每个符号设置输入矩阵的一个平面的数学运算。在这个 patch 中，保留第一个（alpha）平面不做改动，而为其他 3 个平面做加法运算。</p><p><code>pak</code> 对象向 <code>jit.op</code> 右输入口传送四个打包的整数。<code>pak</code> 和 <code>pack</code> 的唯一区别是，当更改任何数字时，<code>pak</code> 都会输出一个新列表（<code>pack</code> 需要一个新数字或左侧入口的一个 bang 来触发输出新列表）。由 <code>pak</code> 生成的四个数字决定了传入 <code>jit.op</code> 矩阵的每个平面的标量值。</p><p>在上面的示例中，平面 0 没有添加任何内容（op 属性的第一个参数是 pass）。平面 1,2 和 3 将分别添加 161,26 和 254。<code>jit.pwindow</code> 将输出矩阵的单元格解析为洋红色（即使只看到一种颜色，矩阵中实际上有 12 个单元格，都设置为相同的值）。</p><blockquote><p>要点：如果<code>jit.op</code> 对象的 op 属性只有一个值（只使用一个数字作为标量），<code>jit.op</code> 将在输入矩阵的所有平面都使用该运算符号和标量值。</p></blockquote><h2 id="修改图像中的颜色"><a href="#修改图像中的颜色" class="headerlink" title="修改图像中的颜色"></a>修改图像中的颜色</h2><p>第三个例子说明如何在矩阵中使用 <code>jit.op</code>，这个矩阵已经存储了相关数据：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03d.png" alt=""><br>将单个平面与标量相乘</p><p>单击消息框 <code>importmovie colorbars.png</code>，<code>jit.matrix</code> 的 <code>importmovie</code> 消息将图像或 QuickTime 视频文件中的单帧图像加载到对象存储的矩阵中。它会将原图像缩放到矩阵的尺寸（320 x 240）。</p><p>单击按钮，<code>jit.pwindow</code> 中显示图像校准颜色条。这时 <code>jit.op</code> 的算术运算符设置为：alpha 平面不做修改（pass）， 其他平面设置为 *（乘）。这个矩阵有 4 个平面，因此使用 4 个浮点数列表设置每个标量。平面 1~3 中的值都是 1.，结果是显示原始的图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03e.png" alt=""><br>所有标量均为 1</p><p>如果将标量设置为 1.0，0 和 0.，会看到以下图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03f.png" alt=""></p><p>包含颜色条的矩阵的所有平面（平面 1 除外）都乘以 0。这将消除矩阵的α，绿色和蓝色平面，仅留下红色（平面 1）。</p><p>将中间值（例如 0.,0.,1. 和 0.5）设置为 <code>jit.op</code> 的标量，会得到颜色栏看起来不同的图像：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03g.png" alt=""></p><p>在这种情况下，忽略 alpha 通道并将红色通道归零。蓝色平面的值是它们的一半。绿色通道（平面 2）保持不变。</p><blockquote><p>要点： <code>jit.op</code> 中的一些数学标量使用浮点数，有些则使用整数。这取决于相关运算符（由 op 属性定义）以及输入矩阵的类型。本教程所有示例都使用了 char 矩阵，因此在添加时可以使用整数（任何浮点数都将被截断，因为矩阵数据保留 0-255 范围内的整数）。</p><p>如果使用 float32 矩阵作为输入，就需要添加浮点数。同样，用 char 乘以浮点标量的矩阵也可以（240 * 0.5 = 120，整数）。但是，由于 <code>jit.op</code> 输出的矩阵仍然是 char 矩阵（参见下面的注释），因此仍然只能获得 0-255 范围内的值。</p></blockquote><p>如果你尝试使用标量值，容易看到某些颜色条消失或与相邻条形图合并。这是因为颜色条都设置为范围相似的标准颜色值。如果一次只显示一个通道（设置一个平面为 1，其余为 0），顶部七个条形中的四个将显示颜色。</p><p>本教程中只演示了 + 和 * 运算符，实际上 <code>jit.op</code> 对象可以执行许多其他的数学运算。运算符的完整列表请查看参考文档，或双击 <code>jit.op</code> 帮助文件中的 p op_list 子 patch。</p><h2 id="调整大小"><a href="#调整大小" class="headerlink" title="调整大小"></a>调整大小</h2><p>创建 <code>jit.pwindow</code> 对象时，它默认显示为 80 像素宽，60 像素高。它可以像 Max 中的许多 UI 对象一样改变大小。如果要精确地指定大小，可以使用 inspector 或向其发送尺寸消息，后跟宽度和高度（以像素为单位）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter03h.png" alt=""><br>更改 <code>jit.pwindow</code> 的大小</p><p>如果给某个固定尺寸（像素）的 <code>jit.pwindow</code> 发送不同的尺寸的矩阵，<code>jit.pwindow</code> 会按自身的大小来缩放传入的矩阵。如果将非常小的矩阵发送到非常大的 <code>jit.pwindow</code> ，会做像素化处理（图像中颜色完全相同的矩形区域）。如果发送大矩阵到一个小的 <code>jit.pwindow</code>，可能会丢失不同程度的细节。</p><blockquote><p>要点：在上面的示例中，含有颜色块的 <code>jit.matrix</code> 的大小（由其维度决定）为 320 x 240 个单元格，planecount 为 4，类型是 char。<code>jit.op</code> 对象（以及大多数 Jitter 对象）识别出信息并自动适配计算、输出相同规格的矩阵。</p><p>如果要更改 <code>jit.matrix</code> 的大小， <code>jit.op</code> 将立即识别变化并重新适应。<code>jit.pwindow</code> 也适配传入的矩阵，但方式略有不同。如果输入矩阵小于其自身的尺寸，则使用重复数据填充所有像素。（这会产生前一段中描述的像素化效果）如果输入矩阵大于其自身的维度，则必须忽略某些数据，只显示它可以显示的内容。因此，即使教程 patch 中的 <code>jit.pwindow</code>跟输入矩阵的大小不同，它们也会尽可能适配 <code>jit.op</code> 矩阵。</p><p>最后一个例子中的 <code>jit.pwindow</code> 尽可能显示了 <code>jit.op</code> 输出的整个矩阵，但它必须忽略所有其他行和列，以使其接收的 320x240 矩阵适合自己的 160x120 显示区域。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.op</code> 对矩阵上的所有数据进行数学运算。可以分别对矩阵单元格中的整体或每个平面执行计算。<code>jit.op</code> 的 op 属性决定要执行什么数学运算，可以输入 <code>@op [operator]</code> 属性参数，或者由左入口中的 <code>op [operator]</code> 消息提供。</p><p>对于多平面矩阵（例如彩色图片和视频），可以给出运算符列表（例如，op pass <em> </em> *）来指定每个平面的操作，并且可以为每个平面提供不同的标量值。在教程 11 中我们会看到如何使用矩阵来代替简单的标量。</p><p>你可以使用 <code>size [width] [height]</code> 消息设置 <code>jit.pwindow</code> 的大小。<code>jit.pwindow</code> 将尽可能适应接收到的矩阵的大小。如果输入矩阵小于其维度，它将复制数据；如果输入矩阵大于其自身维度，它将忽略某些数据。大多数 Jitter 对象都尽量适应它们接收的矩阵的维度、类型和平面数量。对 <code>jit.op</code> 而言，它没有自己的维度，所以它自动适配传入的矩阵大小。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="数学" scheme="http://uegeek.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译04 - 创建矩阵</title>
    <link href="http://uegeek.com/180826-jitter-04.html"/>
    <id>http://uegeek.com/180826-jitter-04.html</id>
    <published>2018-08-26T10:59:41.000Z</published>
    <updated>2018-08-29T13:22:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-4.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter02" target="_blank" rel="noopener">Tutorial 2: Create a Matrix</a></p></blockquote><h2 id="什么是矩阵？"><a href="#什么是矩阵？" class="headerlink" title="什么是矩阵？"></a>什么是矩阵？</h2><p>本教程讲解处理矩阵数据的方法。可以先回顾一下 <a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></p><p>矩阵用虚拟的网格来存储和修改大批的数值数据。数据存储在矩阵中，就可以通过网格位置查找，并指定整个矩阵或部分矩阵来批量修改多个值。</p><p>在<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">上一篇教程</a>中，我们使用 <code>jit.window</code> 对象打开一个窗口，并将矩阵的内容显示为彩色像素。</p><p>显示的矩阵来自 <code>jit.movi​​e</code> 对象，它用 QuickTime 视频的当前帧连续填充矩阵。<code>jit.window</code> 之所以能显示视频，只不过因为被告知要显示哪些矩阵的内容; 事实上，矩阵中的任何数值都可以显示。本教程通过一个更简单的例子帮助你理解矩阵，它是 Jitter 的核心思想。</p><p>以下是本节完整的 patcher 截图</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/02patcher.png" alt=""></p><h2 id="jit-matrix-对象"><a href="#jit-matrix-对象" class="headerlink" title="jit.matrix 对象"></a>jit.matrix 对象</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02a.png" alt=""><br>为单个 8 位值创建 16x12 存储空间</p><p><code>jit.matrix</code> 对象创建矩阵并在内存中声明存储空间，以便我们存储和检索数值，并打印或显示出来。 <code>jit.matrix</code> 的参数包括：</p><ul><li>[name]（可选，本例中未包含）</li><li>[planecount]（在矩阵的每个单元格中存储多少个值）</li><li>[type]（用多少个字节来表示每个数字）</li><li>[dim]（维度，描述矩阵的大小）</li></ul><p>括号 [] 里面应填入实际的赋值。上面的例子创建了 1 个平面（每个矩阵单元包含 1 个数字）、尺寸为 16x12（共 192 个单元格）的 char 型（单字节值）矩阵。由此可以推断出矩阵能够保存 192 个单独的数值，每个值的范围是 0~255（单个字节的范围）。</p><blockquote><p>注意：在 Max 中用 x，y（宽度，高度）格式描述二维矩阵的维数，先给出水平维度的范围，然后是垂直维度。这跟视频和计算机屏幕坐标处理尺寸的方式一致（例如，640x480 视频图像）。即，先说明有多少列（宽），再说明有多少行（高）。需要注意，Jitter 描述行和列，与线性代数中描述矩阵的惯例（先表示行，然后是列）不同。</p></blockquote><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02a.png" alt=""></p><p>回到例子中，一个按钮连接到 <code>jit.matrix</code> 的入口。当 Jitter 对象在左入口接收到 <code>bang</code> 消息时会发送矩阵名称，这个按钮会触发 <code>jit.matrix</code> 发送它的矩阵名称（以 <code>jit_matrix</code> 消息的形式）。</p><h2 id="jit-print对象"><a href="#jit-print对象" class="headerlink" title="jit.print对象"></a>jit.print对象</h2><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02b.png" alt=""><br>打印 <code>jit.matrix</code> 的内容</p><p>在 <code>jit.matrix</code> 下面有一个新的 Jitter 对象：<code>jit.print</code>。它在入口处接收矩阵名称（<code>jit_matrix</code> 消息）并格式化矩阵的值，以便在 Max Console 中打印。它将格式化的值打印到 Max Console，就像 Max 的 <code>print</code> 对象一样，然后在 <code>jit_matrix</code> 消息中以矩阵名称的形式传递出来。</p><p>单击标记为 “output” 的按钮，这会让 <code>jit.matrix</code> 传递矩阵名称给 <code>jit.print</code>，后者格式化值并在 Max Console 中显示：<code>jit_matrix [somename]</code>。左边的单词表示这是由 <code>jit.print</code>  对象打印的，这是 <code>jit.matrix</code> 出口的结果。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/max%20console.png" alt=""></p><p>因为我们没有指定矩阵的名称（没有指定 <code>jit.matrix</code> 的第一个输入参数），所以 <code>jit.matrix</code> 自己会生成唯一名称（类似 “u330000007”）。这里我们并不关心名称是什么，但它能够告诉 <code>jit.print</code> 对象要显示哪个矩阵的数据。</p><p>上图显示了来自 <code>jit.print</code> 矩阵中的所有值，按 16 列和 12 行整齐排列。它们现在都是 0，因为我们还没有在矩阵中填充任何内容。</p><h2 id="在矩阵中设置和查询值"><a href="#在矩阵中设置和查询值" class="headerlink" title="在矩阵中设置和查询值"></a>在矩阵中设置和查询值</h2><p>在<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">上一章</a>中，我们知道如何使用 QuickTime 视频中的彩色数据帧自动填充整个矩阵。还可以将数值放置在矩阵的特定单元格中，并从特定位置检索。</p><p>在下面的例子中，<code>jit.matrix</code> 上方有一些消息框，可以设置和获取矩阵中的值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02c.png" alt=""><br>消息 setcell 和 getcell 可以访问矩阵中的特定值</p><p>使用 <code>setcell</code> 消息可以在特定的矩阵位置中存储值。语法是： <code>setcell [cell coordinates] val [value（s）]</code>。</p><p>例如， <code>jit.matrix</code> 消息 <code>setcell 0 0 val 127</code> 会将矩阵的第一个单元格（即左上角的单元格）的值设置为 127。每个维度中对单元格坐标的编号从 0 开始，最大值比维度小 1。在此矩阵中，x 维度中的位置编号为 0~15，y 维度中的位置编号为 0~11。因此右下角的单元格坐标是 15 11.</p><p><code>pack 0 0 0</code> 对象组合多个数字提供给<code>setcell</code> 消息发送给 <code>jit.matrix</code>。首先设置想要存储值的 x 和 y 位置，然后指定要存储在那里的值。当 x 和 y 位置为 0 0 时，用标有“value” 的数字框发送 127 到 <code>pack 0 0 0</code> 的左侧入口。这将触发消息 <code>setcell 0 0 val 127</code> 发送给  <code>jit.matrix</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02d.png" alt=""><br>消息 <code>setcell 0 0 val 127</code> 设置单元位置 0,0 的值为 127</p><p>（如果矩阵中有多个平面，可以在单元格的特定/所有平面中设置值）</p><p>为了演示之前提过的单元格位置编号，现在尝试将消息 <code>setcell 15 11 val 255</code> 发送到 <code>jit.matrix</code>。在 “X position” 下面的数字框输入 15，在 “Y position” 下面的数字框输入 11 ，在 “value” 下面的数字框输入 255。然后点击 “output” 按钮查看矩阵的变化。<code>jit.print</code>在 Max 控制台中打印出整个矩阵。请注意，单元格位置 0,0 和 15,11 中的值已变为 127 和 255。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02e.png" alt=""><br>消息 <code>setcell 15 11 val 255</code>将单元格位置 15,11 的值设置为 255</p><p>在 Patch 窗口中，你可能已经注意到黑色矩形区域的变化。它的左上角和右下角已经改变了。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02f.png" alt=""><br><code>jit.pwindow</code> 对象显示的数值为颜色（或灰度值）</p><p>该区域是一个名为 <code>jit.pwindow</code> 的用户界面对象。在添加对象面板中可以找到它：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02g.png" alt=""><br>对象选项板中的 <code>jit.pwindow</code> 图标</p><p>在添加对象面板中单击或将其拖动到 patch 窗口时，它会创建一个小的矩形对象（可以拖动对象右下角调整尺寸）。它在功能上与 <code>jit.window</code> 非常相似，区别是它在 Patch 窗口中显示矩阵数据，而不是在一个单独的窗口。</p><p>于是我们看到数值显示为颜色（char 数值范围是 0~255）。矩阵中只有一个平面，所以是单色（即灰度）。0 表示黑色，其他值是某种灰度，最大值255 是白色。因此，单元格 15,11 的 255 值显示为白色，0,0 的 127 值显示为黑色和白色之间的 50％ 灰色。</p><p>你可能会觉得这样填充矩阵相当繁琐。没错。所以 Max 允许我们编写程序来自动填充。</p><h2 id="以算法方式填充矩阵"><a href="#以算法方式填充矩阵" class="headerlink" title="以算法方式填充矩阵"></a>以算法方式填充矩阵</h2><p>双击 <code>patcher  fillmatrix</code> 对象打开子 patch。它将不同的数字传入数学表达式，生成 192 个不同的值到矩阵中的每个单元。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02h.png" alt=""><br>通过算法生成值来填充矩阵的单元格</p><p>当 <code>uzi 12</code> 对象收到 <code>bang</code>（点击主 Patch 窗口中标记为 “fill” 的按钮）时，它会快速从右侧出口进行 1 到 12 计数，并向左侧出口发送每个计数的 bang。</p><p>那些 bang 触发了<code>uzi 16</code>对象，因此它每次都会发出 1~16 的数字。然后把这些数字减去 1，这样值的范围就限定在 0~11 和 0~15，输出的结果作为矩阵中的 y 和 x 位置。对于 12 个 y 位置中的每一个，<code>uzi 16</code>对象指定所有 x 位置，然后在数学表达式（expr）中使用这些数字来计算要存储在该位置的值。这些数字从 outlet 发送给主 patch 创建定义好的 <code>setcell</code> 消息，就像我们之前手动做的那样。</p><p>这里不需要关注具体的数学表达式。它可以生成任何公式。刚才我们用一个公式在每列中产生亮度的正弦梯度，这将让列的整体亮度从左向右增加（即随 x 增加）。</p><p>关闭 <code>patcher fillmatrix</code> ，然后单击标记为 “fill” 的按钮。矩阵在 Max 的 scheduler 的每个时钟节拍中填充值（由子 patch 中的 uzi 对象生成）。现在单击标有 “output” 的按钮查看矩阵的内容。数值将打印在 Max Console 中，并显示在 <code>jit.pwindow</code> 中。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/max%20console%20fill.png" alt=""></p><p>即使对于像 16x12 这样的小型矩阵，仅仅查看 Max Console 中的数字打印输出，我们很难看到数值数据的趋势。而 <code>jit.pwindow</code> 中的显示能够清楚而直观地展示值在矩阵中的变化情况。这是数据可视化的好处。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/output%20display.png" alt=""></p><p>你可以想象在 Max 中以算法方式填充矩阵的其他方法，我们将在后面的教程中演示。</p><h2 id="jit-matrix-可以响应的其他消息"><a href="#jit-matrix-可以响应的其他消息" class="headerlink" title="jit.matrix 可以响应的其他消息"></a>jit.matrix 可以响应的其他消息</h2><p><code>jit.matrix</code> 还可以接收许多其他消息。例如可以使用相同的值填充所有 <code>jit.matrix</code>。发送给<code>jit.matrix</code> 的 <code>clear</code>消息将所有值设置为 0，<code>setall</code> 消息（setall 后跟一个值）将矩阵中的所有单元设置为同一个值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter02i.png" alt=""><br>查询矩阵位置 8,6 处的值; 报告单元格 8 6 val [value(s)]</p><p>还有 <code>getcell</code>消息。单词 <code>getcell</code> 后跟矩阵中的位置（x和y）会让 <code>jit.matrix</code> 将单元格坐标和该位置的值发送到右侧出口。</p><p>在 <code>getcell $1 $2</code> 消息框上方的数字框中输入 y 值，然后输入 x 值，并观察 Max Console 中打印的内容。请注意，该矩阵位置的值在 <code>jit.matrix</code> 的右侧出口输出。</p><p>在后面的教程中，你将看到从矩阵中检索值的各种方法。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.matrix</code> 对象可以为任何尺寸、平面数和数据类型的矩阵数据创建存储空间。该矩阵可以填充来自另一个 Jitter 对象（例如 <code>jit.movi​​e</code> ）的数据，或者用 <code>setall [value]</code>之类的消息来设置所有单元格中的值，或者 <code>setcell [position] val [value（s）]</code>来设置特定单元。可以使用 patch 中其他位置的算法根据公式或一组规则来填充矩阵。</p><p>要获取特定单元格中的数据，可以使用 <code>getcell [position]</code>消息。要查看在 Max Console 中打印的所有数值数据，请使用 <code>jit.print</code> 对象格式化矩阵数据并打印。要查看显示为颜色的矩阵数据，请使用 <code>jit.pwindow</code> 对象。这类似于<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">教程1</a>中演示的 <code>jit.window</code> 对象。</p><p>在本教程中，我们查看了自己生成的数据，而不是上一篇中的数字视频。两种情况下的存储原理是相同的。无论矩阵是存储来自数字视频帧的每个像素的颜色信息，还是表示颜色的数字，它们都存储在二维矩阵中，并且通过 <code>jit.window</code> 或 <code>jit.pwindow</code> 显示。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译03 - 播放 QuickTime 视频</title>
    <link href="http://uegeek.com/180825-jitter-03.html"/>
    <id>http://uegeek.com/180825-jitter-03.html</id>
    <published>2018-08-24T16:05:34.000Z</published>
    <updated>2018-08-29T13:22:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title-3.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter01" target="_blank" rel="noopener">Tutorial 1: Playing a QuickTime Movie</a></p></blockquote><p>这个教程教你使用 Jitter 执行最简单但最有用的任务之一：在窗口中播放 QuickTime 视频。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01a.png" alt=""><br>打开 QuickTime 电影文件</p><p>这个 Patch 中有两个 Jitter 对象：<code>jit.movi​​e</code> 和 <code>jit.window</code>。<code>jit.window</code> 会自动打开电脑屏幕上的窗口。<code>jit.movi​​e</code> 则打开 QuickTime 视频并开始播放。</p><p>单击 <code>read countdown.mov</code> 的消息框，<code>jit.movi​​e</code> 就会打开 QuickTime 视频文件 countdown.mov 并开始读取。</p><p>默认情况下，<code>jit.movi​​e</code> 会在打开文件后立即播放。但是请注意，即使 <code>jit.movi​​e</code> 对象正在播放电影，窗口中却没有显示，因为：</p><p>Jitter 中的每个对象都执行特定任务——可能非常简单，也可能相当复杂。播放 QuickTime 视频实际上被分解为两个任务：</p><ol><li>从硬盘上的文件中将每帧视频数据读入 RAM</li><li>获取 RAM 中的数据，并将其显示为屏幕上的彩色像素</li></ol><p>第一个任务由 <code>jit.movi​​e</code> 执行，第二个任务由 <code>jit.window</code> 执行。为了让 <code>jit.window</code> 知道要显示什么，这两个对象需要进行通信。</p><h2 id="Jitter-对象如何通信"><a href="#Jitter-对象如何通信" class="headerlink" title="Jitter 对象如何通信"></a>Jitter 对象如何通信</h2><blockquote><p>重要概念：Jitter 对象相互通信的关键是<strong>矩阵的名称</strong> —— 它指定了数据在内存中的位置。Jitter 对象输出其他 Jitter 对象能理解的消息（<code>jit_matrix</code>，后跟空格和存储数据的矩阵名称）。此消息通过接线在对象之间传递。</p><p><strong>接收的对象从入口接收消息，从内存中的指定位置获取数据，以某种方式修改数据，并发送修改后的名称数据，输出到对象的左侧出口。</strong></p><p>这样每个对象查看内存中相应的位置来获取所需的数据，执行各自的任务，而不必知道其他对象正在做什么。大多数 Jitter 对象只有从另一个对象获取 jit_matrix 消息，得知该查看相应的矩阵，才会对那里的数据做一些事情。</p></blockquote><p>在多数情况下，Jitter 对象自己会生成唯一的名称。你也可以指定名称（最好是这样）。显式地命名矩阵，不同对象就可以使用相同的内存空间。</p><h2 id="由-Jitter-对象触发动作"><a href="#由-Jitter-对象触发动作" class="headerlink" title="由 Jitter 对象触发动作"></a>由 Jitter 对象触发动作</h2><p>是什么让一个 Jitter 对象将 <code>jit_matrix</code> 消息发送给另一个对象呢？大多数 Jitter 对象在收到消息 <code>outputmatrix</code> 或 <code>bang</code> 时，会发出 <code>jit_matrix</code> 消息。另外，一个对象收到消息并修改了数据后，它会自动发出一条 <code>jit_matrix</code> 消息，通知其他包含相同矩阵名称的对象。</p><p>也就是说，当一个对象收到 <code>jit_matrix</code> 消息时，它会做一些事情并发出自己的 <code>jit_matrix</code> 消息。当一个对象收到 <code>outputmatrix</code> 或 <code>bang</code> 时，它会发送一个 <code>jit_matrix</code> 消息，而不做任何其他事情。</p><p>因此在示例中，<code>jit.movi​​e</code> 对象正在播放 QuickTime 视频，不断存储当前的视频帧，但 <code>jit.window</code> 对象只会在从 <code>jit.movi​​e</code> 对象接收到 <code>jit_matrix</code> 消息时显示内容。只有当 <code>jit.movi​​e</code> 收到消息<code>bang</code>（或 outputmatrix）时才会发生这种情况。那时，<code>jit.window</code> 将显示当前正在电影中播放的任何视频帧。</p><p>为了使 <code>jit.window</code> 以一定速度更新并不断显示视频帧，就需要以同样的速度发送 <code>bang</code> 消息给 <code>jit.movi​​e</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01b.png" alt=""><br>视频在 jit.movi​​e 中播放，每当要显示一帧时都要发送 bang 消息</p><ul><li>单击标记了 play 的开关，<code>metro</code> 对象就会启动。这将以每秒 25 次（每 40 毫秒）的速度发出 <code>bang</code> 消息。这个速度足以显示该视频的每一帧。只要 <code>bang</code> 继续，我们就能看到窗口中显示的视频。</li></ul><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01c.png" alt=""><br>jit.window 显示矩阵的内容</p><ul><li><p>点击开关停止 <code>metro</code>。<code>jit.window</code> 对象停止更新电影窗口，现在只会看到最后显示的静止图像。电影仍在播放 - <code>jit.movi​​e</code> 仍在逐帧更新内存 - 但 <code>jit.window</code> 会忽略这些更新，因为 <code>jit.movi​​e</code> 不再发送消息。</p></li><li><p>你可以单击 <code>metro</code> 下方的按钮，来验证电影是否仍在播放。这会让 <code>jit.movi​​e</code> 将 <code>jit_matrix</code> 消息发送到 <code>jit.window</code>，当前帧会更新 Movie 窗口。连续点几次，会看到电影在鼠标点击之间有变化。</p></li></ul><p>总而言之，<code>jit.movi​​e</code> 以视频正常速率逐帧读取 QuickTime 文件的一帧。当 <code>jit.movi​​e</code> 收到 <code>bang</code> 消息时，会将该数据的位置传达给 <code>jit.window</code>，然后 <code>jit.movi​​e</code> 收到 <code>bang</code> 时所包含的任何帧都由 <code>jit.window</code> 显示出来。</p><h2 id="对象中的参数"><a href="#对象中的参数" class="headerlink" title="对象中的参数"></a>对象中的参数</h2><p>本教程中的 <code>jit.movi​​e</code> 的两个参数 320 和 240，指定了对象在内存中保留单帧视频时的宽度和高度。它会声明足够的 RAM 来存储这些帧。因此，使用 read 消息输入希望读入的视频的尺寸是 ok 的。这样我们知道 QuickTime 视频的尺寸是 320x240。</p><p>如果输入的维度小于读入的视频的尺寸，<code>jit.movi​​e</code> 没法声明足够的存储空间，就不得不忽略每帧的一些像素。相反，如果输入的维度大于读入的视频尺寸，则每一帧中都没有足够的像素来填充已分配的内存空间，因此 <code>jit.movi​​e</code> 会平均分发数据，并用重复数据填充空余的内存。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01b.png" alt="">    </p><p><code>jit.window</code> 对象有五个输入的参数：<code>Movie 5 41 325 281</code>。第一个参数是 <code>jit.window</code> 显示的矩阵的名称。它也会出现在视频窗口的标题栏中。它可以是任何单词（用引号括起来的话，可以是多个单词）。接下来的两个参数，表示视频窗口显示区域左上角的 x，y 屏幕坐标，后两个参数是显示区域右下角的坐标（左-上-右-下）。选择了这些数字是因为</p><ul><li>它们定义了一个 320x240 的显示区域，与视频尺寸相同</li><li>当考虑操作系统默认的窗口边框、标题栏和菜单栏的尺寸时，窗口刚好隐藏在桌面的左上角。（当然也可以设置标题栏不显示）</li></ul><p>输入 <code>metro</code> 的参数 40，使其每秒发出 25 次 <code>bang</code>消息。QuickTime 视频的帧速率是每秒24帧，因此这个 <code>metro</code> 持续触发 <code>jit.movi​​e</code> 对象，确保每帧都能显示。</p><p>要播放 QuickTime 视频，请使用 <code>jit.movi​​e</code> 打开文件并将视频的连续帧读入 RAM，然后使用 <code>jit.window</code> 在单独的窗口中显示视频。使用输入的参数指定视频的尺寸，以及屏幕上显示区域的精确坐标。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Jitter 对象通过相互发送矩阵的名称，来传递特定视频帧的信息——该信息在内存中的位置。 Jitter 对象获得矩阵名称时，它使用该位置的数据执行指定的任务，然后将修改后的数据名称，发送给其他 Jitter 对象。几乎所有 Jitter 对象在收到<code>bang</code>消息 （或 outputmatrix）时都会发出一个名称（包含在<code>jit_matrix</code>消息中）。因此，为了显示视频的连续帧，以某个速率向 <code>jit.movie</code> 发送 <code>bang</code> 消息，然后​​连接到<code>jit.window</code>显示。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter01d.png" alt=""><br>跟踪每个对象的消息和角色</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title-3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译02 - Jitter 对象的属性(attributes)</title>
    <link href="http://uegeek.com/180822-jitter-02.html"/>
    <id>http://uegeek.com/180822-jitter-02.html</id>
    <published>2018-08-22T09:20:13.000Z</published>
    <updated>2018-08-29T13:22:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title2.jpg" alt=""></p><a id="more"></a><p><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></p><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter00b_whatareattributes" target="_blank" rel="noopener">Attributes: Editing Jitter object parameters</a></p></blockquote><p>属性是指定 Max 对象行为的方法。大多数 Jitter 对象使用属性来指定当前状态的变量。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_a.png" alt="">            </p><p>许多 Max 对象使用多个参数来确定行为。对象名称后面的这些参数的顺序，决定了对象如何解析它们。在上面的例子中，<code>counter</code> 的第一个参数设置了计数的方向；第二个和第三个参数确定最小值和最大值。</p><p>这些值都是数字，参数个数可能会影响对象的行为，所以它们的顺序很重要。如果 <code>counter</code> 只有两个参数，它们会作为最小和最大值，而不是方向和最小值。参数的位置和数量最为关键，在 <code>counter</code> 的例子中，如果只有两个参数，就没办法创建能够指定方向和最大值的 <code>counter</code> 对象。</p><p>给定的对象参数，通常被视为初始值，可以从其他入口或发送特殊消息给对象来修改这些值。例如，分别发送整数到第 2 个和第 5 个入口，来更改 <code>counter</code> 对象的方向和最大值，它们会替代默认值。同样，你可以向左入口发送消息 <code>min</code> 后跟一个整数，来更改对象的最小值。</p><p>当 Max 对象只有两、三个参数时，天下太平。但是 Jitter 对象通常有很多很多变量（甚至几十个）。如果所有变量都依赖于入口和对象参数的顺序，那么光看文档就够你忙的……</p><h2 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h2><p>与 Max 对象不同，Jitter 对象可以用<strong>属性</strong>来设定行为。将属性与 Jitter 对象的名称一起输入对象框，或者在创建对象后用消息设置（和检索）属性：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_b.png" alt=""><br>具有对象名称后的属性的Jitter对象</p><p>上面是 <code>jit.brcosa</code> 的例子，它有三个属性。使用 <code>@ 符号 + 属性名称 + 一个或多个参数</code>（可以是任意数​​据类型：int，float，symbol 或 list），在对象框中设置属性。</p><p>可以在对象的名称之后，以任意顺序输入个数不限的属性。你可能不知道 <code>jit.brcosa</code> 对象的功能，但可以根据属性的名称以及数据类型来推断。</p><blockquote><p>提示：@符号与属性名称之间没有空格</p><p>同样重要的是：Jitter 对象可以同时具有输入的属性和输入的参数。请参阅下面的 Jitter 对象参数 部分。</p></blockquote><p>与 Max 对象一样，创建 Jitter 对象并设置初始值以后，可以向对象发送消息随时更改这些属性值：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_c.png" alt=""><br>使用 Max 消息更改属性</p><p><code>jit.brcosa</code> 对象的亮度属性初始值为 0.5（在对象框中输入 <code>@brightness 0.5</code>），然后可以发送消息 <code>brightness [float]</code>到对象的左入口来更改。发送带有属性名称的消息（后跟相关参数）到 Jitter 对象的左入口，就可以更改几乎任何属性。</p><p>与 Max 对象一样，Jitter 对象有参数的默认值。上面的 <code>jit.brcosa</code> 对象只设置了亮度的初始值，其他属性都使用默认值。在上面的示例中，使用消息更改对象的对比度(contrast)和饱和度(saturation)属性的值，从而替换对象的默认值。</p><p>下面说明如何设置对象的属性值。</p><h2 id="Jitter-对象参数"><a href="#Jitter-对象参数" class="headerlink" title="Jitter 对象参数"></a>Jitter 对象参数</h2><p>大多数 Jitter 对象有四种<code>输入属性</code>或<code>输入参数</code>。实际上它们都是属性，只不过 Jitter 对象会自动判断应该用作属性还是参数。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_d.png" alt=""><br>Jitter 对象也可以有参数</p><p>上面 <code>jit.rota</code> 对象有两个初始化的属性：<code>anchor_x</code> 和 <code>anchor_y</code>。但其他数字是什么意思呢？</p><p>如果 Jitter 对象处理的是矩阵数据，则参数将被理解为：</p><ol><li>输出矩阵的 planecount</li><li>输出矩阵的类型</li><li>输出矩阵的大小或维度</li></ol><p>现在我们知道，上面的 <code>jit.rota</code> 对象将输出一个由 4 个 char（8位整数）数据平面组成的矩阵，每个平面的维度是 320x240。</p><blockquote><p>注意：如果要指定 Jitter 对象的参数，参数必须出现在任意属性之前。否则 Jitter 对象会将参数误解为属性的值，而不是对象的参数。</p></blockquote><p>所有可以输出矩阵数据的 Jitter 对象，都有几个共同的属性，它们可以设置参数：<strong>planecount，type 和 dim</strong>。可以通过输入属性（不需要指定顺序），也可以用消息触发更改。例如，下面的三个对象是等价的：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_e.png" alt=""><br>参数或属性？你来定</p><ul><li>第一个对象的输出矩阵，直接使用<code>输入的参数</code>来设置。</li><li>第二个对象使用<code>输入的参数</code>设置了 <code>planecount</code> 和 <code>type</code>，但使用了<code>输入的属性</code>设置了 <code>dim</code> 的数量。</li><li>第三个对象使用<code>输入的属性</code>来设置所有内容。</li></ul><p>你也可以用 <code>loadbang</code> 对象触发的消息来初始化对象属性：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_f.png" alt=""><br>另一种初始化属性的方法</p><h2 id="查询属性和对象状态"><a href="#查询属性和对象状态" class="headerlink" title="查询属性和对象状态"></a>查询属性和对象状态</h2><p>查找对象属性设置的最快方法，是查看检查器（inspector）。选中对象，按 <code>cmd/alt + i</code> 或单击右侧工具栏上的 i 图标就可以打开。在窗口底部附近可以找到当前属性设置。</p><p>属性的另一个功能是显示 Jitter 对象属性的当前值。用一个 <code>get</code> 开头的消息，紧跟想要查询的属性名（与get之间没有空格）来触发。比如下图的 <code>getdim</code> 可以触发动作，获取 <code>jit.grab</code> 对象的 dim 当前参数。结果值由 Jitter 对象以消息形式从右输出口输出（以属性的名称 dim 开头）。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_g.png" alt=""><br>查询 Jitter 对象的属性</p><p>使用 <code>get</code> 可以查询出属性的当前值，即使之前从未设置过。例如，下面的 patch 获取了 <code>jit.plur</code> 对象的一些默认值。用 <code>route</code> 对象可以轻松分离每个属性的值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_h.png" alt=""><br>获取属性的默认值</p><p><strong>你可以发送给任何 Jitter 对象<code>getattributes</code> 和 <code>getstate</code> 消息，来获得对象的所有属性。</strong></p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_i.png" alt="">        </p><p><code>getAttributes</code> 消息令 Jitter 对象输出它包含的所有属性列表。查看几个 Jitter 对象，很快就会发现几个频繁出现的属性（例如outputmode，type 和 dim）。其他（例如 jit.brass 对象中的 mask）则是某些对象独有的。</p><p><code>getstate</code> 消息可以一次性输出 Jitter 对象所有属性的值：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_j.png" alt=""><br>查询对象的状态</p><p>这样我们就可以用 <code>route</code>，<code>unpack</code>和其他对象来按需查找属性值了。在后续的教程中会遇到几个 Jitter 对象，其属性基于输入矩阵（或被对象打开的文件）执行的计算而更改。想要找出对象计算结果，就需要查询相关属性值。</p><h2 id="ATTR"><a href="#ATTR" class="headerlink" title="ATTR"></a>ATTR</h2><p>你还可以使用 <code>attrui</code> 对象读取属性值。这是一个 UI 控件，它与对象的入口是双向连接的。<code>attrui</code> 对象有两个部分，左边部分是所有可用的属性的下拉菜单。选择属性后，右侧会显示属性的当前值，并可编辑。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterattributes_k.png" alt=""><br>查找对象的状态</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Jitter 对象的属性，让我们可以很好地管理复杂的对象参数。你可以使用属性来初始化、更改和查找存储在 Jitter 对象中的当前值。直接在属性名称后赋值，就免去了记忆参数功能和顺序的麻烦。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p><hr><p>MakeNoise 系列</p><ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li><li><a href="https://www.uegeek.com/180703-make-noise-08.html" target="_blank" rel="noopener">MakeNoise08 - 振荡器和滤波器</a></li><li><a href="https://www.uegeek.com/180706-make-noise-09.html" target="_blank" rel="noopener">MakeNoise09 - 压缩 Compression</a></li><li><a href="https://www.uegeek.com/180708-make-noise-10.html" target="_blank" rel="noopener">MakeNoise10 - 延时和混响 Delay &amp; Reverb</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译01 - 什么是矩阵？</title>
    <link href="http://uegeek.com/180821-jitter-01.html"/>
    <id>http://uegeek.com/180821-jitter-01.html</id>
    <published>2018-08-21T15:57:01.000Z</published>
    <updated>2018-08-29T13:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Max-title1.jpg" alt=""></p><a id="more"></a><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档： <a href="https://docs.cycling74.com/max7/tutorials/jitterchapter00a_whatisamatrix" target="_blank" rel="noopener">What is a Matrix?</a></p></blockquote><p>矩阵即网格，网格的每个格子都包含一些信息。例如，棋盘是一个矩阵，每个方格包含特定的信息：有某个棋子，或没有棋子。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_a.png" alt=""></p><p>方便起见，假设矩阵中每个格子的「信息」都是数字。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_b.png" alt=""><br>电子表格是二维矩阵</p><p>水平的数据组称为<code>行</code>，垂直的数据组称为<code>列</code>。在路线图、棋盘或电子表格中，通常会使用字母和数字标记行和列，这样就可以表示任意一个单元格的位置。在上面例子中，单元格 C3 的数值为 0.319。</p><p>上面的矩阵例子是二维的——宽度和高度。在 Jitter 中，矩阵维度范围在 1~32 维之间。（一维矩阵对应编程中的数组 array。Max 中有一些对象用于存储数组，例如 <code>table</code> 和 <code>multislider</code>。不过有时候 Jitter 中的一维矩阵更适用）虽然在纸上描绘起来有点困难，但我们仍然可以想象一个有宽度/高度/深度的立方体三维矩阵。（例如，矩阵宽/高/深 分别有 3 个单元，总共 3x3x3 = 27个单元）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_c.png" alt=""></p><p>一个 3x3x3 维矩阵共有 27 个单元</p><p>四维或更高维度的矩阵，相当挑战我们的视觉想象力和描述能力，但它们确实存在。</p><h3 id="视频屏幕作为矩阵"><a href="#视频屏幕作为矩阵" class="headerlink" title="视频屏幕作为矩阵"></a>视频屏幕作为矩阵</h3><p>视频屏幕由微小的单个像素组成，每个像素都显示特定的颜色。在计算机显示器上，屏幕的分辨率通常是 1024 像素宽，768 像素高，也可能是800x600 或 640x480。在电视监视器中，分辨率大约为 640×480。上述屏幕的宽高比为 4:3。</p><p>在较宽的 DV 格式中，宽高比为3:2，图像通常为 720x480 像素。高清晰度电视（HDTV）指定了另一种宽高比 16:9。在教程中通常使用 4:3 的宽高比，最常见的尺寸小于 320x240 甚至 160x120，这样可以节省 Max patch 的大小。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_d.png" alt=""></p><p>常见的像素尺寸</p><p>单帧标准视频由 640×480 = 307,200 个像素组成。每个像素显示一种颜色。为了用数字表示眼睛可分辨的像素的颜色，我们需要范围非常大的颜色值。</p><p>用数字表示颜色值有许多方式。描述计算机中每个像素颜色的标准方法，是将颜色分解为红色、绿色和蓝色（也称为RGB），以及透明度（称为Alpha通道）。因此，大多数计算机程序将单个像素的颜色，存储为四个单独的数字，分别表示 α，红色，绿色和蓝色。这种四通道颜色表示方案通常称为 ARGB 或 RGBA。</p><p>Jitter 也遵循这个惯例。为了使矩阵的每个单元表示一个颜色像素，每个单元都包含四个数值（α/红/绿/蓝）。因此存储视频帧数据的矩阵，实际上在每个单元格中包含四个数值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_e.png" alt=""><br>矩阵的每个单元格包含多个数字</p><p>因此，视频帧在 Jitter 中是二维矩阵，每个单元表示帧的像素，并且每个单元包含 α/红/绿/蓝 四个值，范围从 0 到 255。为了区分多单元格与矩阵维度的概念，Jitter 引入了平面(plane)的概念。</p><h3 id="什么是-plane？"><a href="#什么是-plane？" class="headerlink" title="什么是 plane？"></a>什么是 plane？</h3><p>为矩阵中的数字分配内存时，Jitter 需要知道每个维度的范围 - 例如，320x240 - 以及每个单元格中要保存的值的数量。为了跟踪单元格中的不同值，Jitter 把<strong>单元格看做位于某个单独平面上，因此我们将视频帧视为四个数据平面的二维矩阵</strong>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jittermatrix_f.png" alt=""></p><p>矩阵每个单元中的值存在于四个虚拟平面上</p><p>使用这个概念框架，我们可以在需要时单独处理每个平面（以及颜色信息的每个通道）。例如，想要增加图像的红色，只需增加矩阵红色平面中的所有值，保持其他值不变。</p><p>一般在 Jitter 中用四个矩阵的数据-α/红/绿/蓝的 表示视频。这些平面的编号从 0 到 3，因此 Alpha 通道位于平面 0 中，RGB 通道位于平面 1,2 和 3 中。</p><h3 id="矩阵中的数据"><a href="#矩阵中的数据" class="headerlink" title="矩阵中的数据"></a>矩阵中的数据</h3><p>计算机用不同格式来存储数字。如果知道想要存储的数字类型，就可以仅为每个数字分配真正需要的空间来节省内存。例如，用 ASCII 0~255 存储字母字符，只需要 8 位（2 的 8 次方）的空间来存储每个字符。如果想要存储更大范围的数字，可能会使用 32 位（包含的整数范围从 -2,147,483,648 到 2,147,483,647）。为了表示带小数部分的数字，例如 3.1416，我们使用浮点数二进制系统，32 位或 64 位数字的某些位表示值的尾数，其他位表示指数。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/main-qimg-0c6f60196dbaaaa7a2f9178fff29d64d-c.jpg" alt=""></p><p>用 Max 编程的大多数情况下，不需要知道 Max 如何存储数字。但是用 MSP 处理数字音频时，最好了解 MSP 什么情况下使用浮点数（如果不小心用整数替代了浮点数，程序可能会报错）。在 Jitter 中，了解计算机的存储类型非常有帮助。</p><p>Jitter 矩阵可以将数字存储为 64 位浮点（也称为双精度浮点或双精度），32 位浮点（简称浮点数），32 位整数（称为long int，或者只是int）和 8 位字符（称为char）。某些 Jitter 对象仅以一种格式存储，因此不必指定存储类型。但是其他 Jitter 对象允许多种方式存储，因此必须指定数据类型为 char / long / float32 / float64 等。</p><blockquote><p>重要概念：在使用 Jitter 操作视频时，需要了解矩阵中数据存储的知识。矩阵默认以 ARGB 格式保存视频数据，每个单元的数值范围是 0~255 （一般在四个平面中）。最常见的数据存储类型是 char，并不是因为存储的是字符。最常存储的值通常是数字，只需要 256 个不同的可能值来表示，因此 8 位的 char 就足够了。视频数据量一般较大，所以 Jitter 中大多数矩阵对象默认使用 char 存储类型，以减少存储空间。对于单色（灰度）图像或视频，单个 char 数据平面就足够了。</p></blockquote><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/maxgroup0825.png" alt=""></p><hr><p>MakeNoise 系列</p><ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li><li><a href="https://www.uegeek.com/180703-make-noise-08.html" target="_blank" rel="noopener">MakeNoise08 - 振荡器和滤波器</a></li><li><a href="https://www.uegeek.com/180706-make-noise-09.html" target="_blank" rel="noopener">MakeNoise09 - 压缩 Compression</a></li><li><a href="https://www.uegeek.com/180708-make-noise-10.html" target="_blank" rel="noopener">MakeNoise10 - 延时和混响 Delay &amp; Reverb</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/Max-title1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
  </entry>
  
  <entry>
    <title>破解 AI 时代的焦虑 —— 从人机交互到人机协同创作</title>
    <link href="http://uegeek.com/180717-human-computer-symbiosis.html"/>
    <id>http://uegeek.com/180717-human-computer-symbiosis.html</id>
    <published>2018-07-17T15:11:58.000Z</published>
    <updated>2018-08-22T09:40:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.001.jpeg" alt=""></p><a id="more"></a> <p>这是 4 月做的一次分享。大概是我做过的分享中，现场讨论气氛最热烈的一次了。</p><p>最近抽空整理成文章，希望大家可以继续讨论这个有趣、有争议的话题。</p><p>为什么分享这个话题呢？</p><p>我做了好多年交互设计的工作，所以学习和工作一直有一个离不开的主题——人机交互（Human-Computer Interaction）。</p><h2 id="人机关系的演进"><a href="#人机关系的演进" class="headerlink" title="人机关系的演进"></a>人机关系的演进</h2><p>什么是人机交互？我把它简单理解为：</p><blockquote><p>人如何与机器或是某个复杂系统的沟通和互动过程。</p></blockquote><p>更为完整的版本，请看我在知乎上的回答 <a href="https://www.zhihu.com/question/19788122/answer/119319267" target="_blank" rel="noopener">什么是交互设计？</a></p><p>比如，鼠标就是一个解决人和机器互动问题的经典产品。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.003.jpeg" alt=""></p><p>现在大家都觉得鼠标再平常不过了，但是在当年，Douglas Engelbart 的这一项发明，极好地解决了人们在图形化计算机界面操纵屏幕元素的问题。为了表彰这项发明以及在人机交互领域的开拓式贡献，Douglas Engelbart 在 1997 年获得了「计算机界的诺贝尔奖」——图灵奖。</p><blockquote><p>For an inspiring vision of the future of interactive computing and the invention of key technologies to help realize this vision. – Turing Award Citation</p></blockquote><p>人和机器的对话、交互一直在演进。这也从一个侧面反映了人创造工具的历史：</p><p><img src="http://killerinfographics.com/wp-content/uploads/2014/12/DickiesIGjess.edits12-211.jpg" alt=""></p><p>人创造的工具越来越多样、复杂、强大。想想看，今天我们在手机上能完成多少事情。</p><p>于是，有人慢慢感到这种发展速度似乎不大对劲……奇点要来了，AlphaGo 也出现了。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/human-progress.png" alt=""></p><p>随着深度学习热潮的演进，大家发现，以前为了让机器智能化而不得不做的很多工作，比如，符号化、标准化、模块化、输入大量专家知识、需要庞大的训练数据集、要做苦脏累的特征工程等等，现在都简化了。基本上，只要目标足够清晰、可操作，训练数据和计算资源足够，机器学习产生的结果就可以满足要求。</p><p>我个人也经历了一次切身的体验。</p><p>今年年初在上 Udacity 的 <a href="https://github.com/kidult00/deep_learning_nanodegree_projects" target="_blank" rel="noopener">Deep Learning Nano Degree 课程</a>的时候，最后一个实践项目，是基于人脸图像库，用生成对抗网络（GAN）算法自动生成人脸。</p><p>虽然在学习过程中，早已对算法能实现的结果有所预期。但是当我把程序放到 AWS 的 GPU 上面跑了不到二十分钟，看到结果时还是忍不住隐隐感到机器的强大和压迫。</p><p>这是最开始几个训练迭代生成的模糊不清的轮廓：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/face-gen-before.png" alt=""></p><p>这是十几分钟训练结束后生成的人脸：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/face-gen-after.png" alt=""></p><p>说一点儿都不焦虑是假的。</p><p>何况各种媒体还铺天盖地强化这种焦虑，今天是一百零八种会被机器取代的工作，明天是哪个比赛机器又战胜了人……</p><p>于是大家经不住会问：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.010.jpeg" alt=""></p><p>似乎只有像诗词、小说、爵士乐、即兴表演这些领域，机器看起来就是不太擅长。</p><p>但，也不好说。</p><p>Paul 是一个专门给人画肖像画的机器。从 2011 年至今已经创做了非常多的作品。看起来非常有艺术感，不是吗？</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.011.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/emoji-desperate.png" alt=""></p><p>有时候在焦虑之余，又忍不住会想：这种焦虑到底从何而来？</p><p>如果看过莱考夫「我们赖以生存的隐喻」的同学都知道，隐喻 Metaphor 对我们的影响有多么大。仔细想想，感到机器的威胁，是不是也源于人机关系的一些基本隐喻？</p><p>我们基本上都是以一种对立或一分为二的方式来看待这些基本词汇：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.014.jpeg" alt=""></p><p>看到这些词汇，我们会下意识地觉得它们是对立关系。逻辑、精确、冰冷的工程思维，怎么跟想象、感性、个性、创作融为一炉呢？</p><p>这大概就是问题所在了。</p><h2 id="隐喻和可能"><a href="#隐喻和可能" class="headerlink" title="隐喻和可能"></a>隐喻和可能</h2><p>语言有边界。这是语言能高效传递信息的代价之一。</p><p>所以，打破语言或者说概念的界限，也许就是找到新出路的起点。</p><p>（PS. 在心理咨询中，咨询师很重要的一部分工作，是帮助来访者呈现问题、reframe 问题，而不是直接插手去替他解决问题。）</p><p>其实早在 50 多年前，就有人探讨过人机关系的「未来简史」。</p><p>美国心理学家和计算机科学家 Licklider 在 Man-Computer Symbiosis 这篇论文中，讨论人跟机器的关系存在什么样的可能性，提出「人机共生」的概念。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.016.jpeg" alt=""></p><p>快 60 年过去了，技术的发展让「蠢机器」第一次有可能成为人类的「好基友」，我们为什么首先感到的是焦虑而不是兴奋呢？</p><p>还记得 2016 年，在 AlphaGo 战胜李世石后，跟安猪老师在大理有过一次讨论。当时我的感慨是，为 AlphaGo 的胜利感到挺开心的，但并不是因为我是技术的脑残粉，而是因为我觉得到了这个时候，人不得不去面对这样一个问题：</p><blockquote><p>人到底擅长什么？</p></blockquote><p>也就是说，当接受生物智能无法跟上非生物智能的发展时：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.018.jpeg" alt=""></p><p>人到底有哪些可以让机器「羡慕」（当然，机器不会有这种情绪）的天赋呢？</p><p>至今我还没有答案，但我想，大概会包括：直觉、洞察力、探索和意外的创造。人欣赏「意外」的审美、运用「意外」的创造力，应该会长期秒杀机器。</p><blockquote><p>人跟机器最大的区别到底是什么？</p></blockquote><p>我一直在问自己这个问题。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.021.jpeg" alt=""></p><p>意图，可能是现阶段人跟机器最大的差别。</p><p>人因为时间、空间、认知方面的三大局限，因为生命时长极其有限、可触达的空间极其有限、工作记忆（内存）极其有限，决定了人类的一些基本 drive 和价值观。人的美妙与荒谬，可能都来自于两行二选一的核心代码：</p><blockquote><p>Be numb/sober and Duplicate</p><p>Be insane/self-distroying and Love</p></blockquote><p>所以我（naive地）认为，突破时间、空间、认知限制，渴望无限，是人类物种永恒的追求，换一个词来概括，那就是——意图。</p><p>我们在基本意图上发展出复杂的能力，会体会微妙的情感，会追求意义，会审美、表达、共情，会讲故事和构建社会关系……</p><p>而机器，无所不能，但就是没有意图！</p><p><strong>这样看来，现在难道不是人类最好的时代吗？有一个毫无私心、任劳任怨、潜力无限的助手，为什么我们担心的是被助手取代，而不是兴高采烈地放开手脚去创造呢？</strong></p><h2 id="人机关系的新阶段"><a href="#人机关系的新阶段" class="headerlink" title="人机关系的新阶段"></a>人机关系的新阶段</h2><p>无论技术如何发展，人类从来没有停止过创造。</p><p>这是用 Google DeepDream 算法生成的作品：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/DeepDream2.jpg" alt=""></p><p>DeepDream 网站的首页，已经为人机关系的新时代做了注脚：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Human-ai-collaboration.png" alt=""></p><p>艺术家们一直在尝试探索人机关系，可能是这样的：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/Alex%20Kiessling.jpg" alt=""></p><p>也可能是这样的：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/di_2016_ars_11-1024x684.jpg" alt=""></p><p>上图是一位叫做 Dragan iLiC 艺术家的项目，人充当机器的笔刷，由机械臂控制着人去作画。</p><p>在分享的现场，这张图引发了热烈的讨论。有的小伙伴表示，这样做的目的到底是什么，她看不出任何意义。有的小伙伴认为这是对人机关系一种悲观的表达。有的小伙伴的态度则更为中立而开放……</p><p>我想，这恰恰就是艺术家的目的吧：激发人们的反思与讨论。并不存在对与错，只是 raise questions，这也许就是最大的善意。</p><h2 id="音乐，人机协同即将爆发的领域？"><a href="#音乐，人机协同即将爆发的领域？" class="headerlink" title="音乐，人机协同即将爆发的领域？"></a>音乐，人机协同即将爆发的领域？</h2><p>最近关注音乐和技术结合的领域比较多，越来越觉得音乐也许会迎来人机共创的繁荣时期。</p><p>音乐本身是符号化、形式化非常强的「语言」。音乐的规律经过数百年的研究和沉淀，几乎已经没有太多规律上的「未知和秘密」，更多的变化会来自文化思潮影响下的风格探索。</p><p>算法作曲早已不是什么新鲜事，基于 AI 自动生成音乐已经有很多成熟的应用。甚至是在对即兴表演要求相当高的爵士乐，也已经有人机共同即兴表演的尝试。比如 Al Biles 教授的 GenJam 项目，从 2005 年至今，已经演出过数十场。</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=z0712pdmu7n&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/z0712pdmu7n.html" target="_blank" rel="noopener">GenJam’s Journey_腾讯视频</a></p><p>而去年的 Qosmo AI DJ 项目也展示了人类 DJ 和 AI DJ 一起 Jam 的效果~</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=t0602v8uxp2&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/t0602v8uxp2.html" target="_blank" rel="noopener">AI DJ Project 人工智能 DJ 与人类合作打碟_腾讯视频</a></p><h2 id="何以解忧？"><a href="#何以解忧？" class="headerlink" title="何以解忧？"></a>何以解忧？</h2><blockquote><p>这是最坏的时代</p><p>也是最好的时代</p></blockquote><p>这取决于我们现在每做的一个决定、每投入的分分秒秒。</p><p>回到主题，如何破解 AI 时代的焦虑呢？</p><p>以下是 00 给（自己）的解药：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.031.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.032.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.033.jpeg" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.035.jpeg" alt=""></p><p>回归创造者的使命，装备上创造所需要的心、眼、脑、手，去看去爱去体验。知识可以学习，但智慧更多是一种体验。把技术当成伙伴和切磋的对手，去行动，去试验，去创造。</p><p>最后</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.037.jpeg" alt=""></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://web.stanford.edu/dept/SUL/library/extra4/sloan/MouseSite/1968Demo.html" target="_blank" rel="noopener">Doug Engelbart 1968 Demo</a></li><li><a href="http://patricktresset.com/new/" target="_blank" rel="noopener">PATRICK TRESSET |</a></li><li><a href="http://worrydream.com/refs/Licklider%20-%20Man-Computer%20Symbiosis.pdf" target="_blank" rel="noopener">Licklider - Man-Computer Symbiosis.pdf</a></li><li><a href="http://www.draganilic.org/" target="_blank" rel="noopener">www.draganilic.org</a></li><li><a href="http://igm.rit.edu/~jabics/GenJam.html" target="_blank" rel="noopener">GenJam</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/AI-co-keynote_imges.001.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计" scheme="http://uegeek.com/categories/%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="交互设计" scheme="http://uegeek.com/tags/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="AI" scheme="http://uegeek.com/tags/AI/"/>
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Deisgn" scheme="http://uegeek.com/tags/Deisgn/"/>
    
      <category term="人工智能" scheme="http://uegeek.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="HCI" scheme="http://uegeek.com/tags/HCI/"/>
    
      <category term="人机交互" scheme="http://uegeek.com/tags/%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    
      <category term="人机共生" scheme="http://uegeek.com/tags/%E4%BA%BA%E6%9C%BA%E5%85%B1%E7%94%9F/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="跨界" scheme="http://uegeek.com/tags/%E8%B7%A8%E7%95%8C/"/>
    
      <category term="创新" scheme="http://uegeek.com/tags/%E5%88%9B%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise10 - 延时和混响 Delay &amp; Reverb</title>
    <link href="http://uegeek.com/180708-make-noise-10.html"/>
    <id>http://uegeek.com/180708-make-noise-10.html</id>
    <published>2018-07-08T04:50:44.000Z</published>
    <updated>2018-08-22T09:40:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li><li><a href="https://www.uegeek.com/180703-make-noise-08.html" target="_blank" rel="noopener">MakeNoise08 - 振荡器和滤波器</a></li><li><a href="https://www.uegeek.com/180706-make-noise-09.html" target="_blank" rel="noopener">MakeNoise09 - 压缩 Compression</a></li></ul><p>音乐是时间的艺术。</p><p><strong>时间也是信号的天然属性。而声音设计，同时还是空间的艺术。</strong></p><p>声音必定产生在某个空间当中，人对声音的印象和记忆，多少都包含了对空间线索的直觉和感受。比如，密友之间的低语声，比较可能发生在一个小房间里；而轮船驶过的汽笛声，大概是在一个临海、开阔的码头，夹杂着繁忙的机械马达声和喧闹的人声。如果是清晨的港湾，大概又是不同的景象了。</p><embed src="http://www.xiami.com/widget/58846_1770984629,_300_146_cccccc_dddddd_0/multiPlayer.swf" type="application/x-shockwave-flash" width="300" height="146" wmode="opaque"><p>调整声音信号的方式有很多，延迟（delay）是必不可少的一种。混响（reverb）是塑造声音的空间感的秘密。今天我们就来一探究竟吧。</p><h2 id="Delay-延时"><a href="#Delay-延时" class="headerlink" title="Delay 延时"></a>Delay 延时</h2><blockquote><p>Delay is an audio effect and an effects unit which records an input signal to an audio storage medium, and then plays it back after a period of time. — Wiki￼</p></blockquote><p>延时可以在时间上平移一个信号。延迟效果器储存并保留音频信号一段时间后再将其释放。</p><p><img src="https://wiki.audacityteam.org/w/images/5/53/Delay.png" alt=""></p><p>延时是很多音效的核心，比如混响 Reverb、滤波 Filters 、和唱 Chorusing、Flanger（镶边，利用原音叠上稍微延迟的音，产生出金属感的回旋声）。</p><p>通过控制多条延迟的声音，可以产生回声效果。以一定顺序衰减并释放每条延迟声音，可以模拟出真实的回声效果。</p><p>延迟效果有很多种形式。比如在 Pink Floyd 的 <a href="https://open.spotify.com/track/5HNCy40Ni5BZJFw1TKzRsC" target="_blank" rel="noopener">Comfortably Numb</a> 里面，第一句歌词「Hello…Hello…Hello」是一个长延迟的效果。</p><iframe width="100%" height="166" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/4126197&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true"></iframe><p><img src="https://is4-ssl.mzstatic.com/image/thumb/Music49/v4/0f/f8/be/0ff8be03-465c-c0ce-4fe1-2db52ea50753/886445635850.jpg/1200x630bb.jpg" alt=""></p><p>Delay 的参数：</p><ul><li>Time/tap: the amount of time between the dry, unprocessed signal and the wet, processed signal.</li><li>Repeat/feedback: controls how many repeats of a delayed sound</li></ul><h2 id="Reverb-混响"><a href="#Reverb-混响" class="headerlink" title="Reverb 混响"></a>Reverb 混响</h2><p>混响可以帮助我们营造合适的空间「场所感」。</p><blockquote><p>混响(reverberation)是声源发音停止后，声音继续存在的声学现象。—wiki</p></blockquote><p>声音在空间中传播，会遇到不同的物体，发生反射（reflection）、吸收（absorption）和扩散（diffusion）。混响产生于声波的传播被墙壁或周围障碍物反射而滞后于发声。<br>￼<br><img src="http://www.prestigeacoustics.com.au/wp-content/uploads/2015/01/About-Sound5-copy3.png" alt=""></p><p>不同的材料对声音的吸收效果不同，常常需要精密的计算和搭配，才能营造出理想的声音效果。</p><p><img src="https://www.acousticpanelsreview.com/wp-content/uploads/2014/09/Sound-Absorption-Coefficient.png" alt=""></p><p>混响时间是指从其最初的反射声强度衰落 60 dB (降低到 -60dB)所花费的时间。<br>￼<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6e/Reverberation_time_diagram.svg/440px-Reverberation_time_diagram.svg.png" alt=""></p><p>延时时间的最小值，应该至少为混响时间的四分之一，而且延时的长度应为质数（或各延时时长是互质的）。合理的混响效果建议每秒有 1000 个回声。</p><p>室内环境的声学效果涉及非常复杂的声学知识，尤其是录音棚和音乐厅。</p><p><img src="http://www.constructioncanada.net/wp-content/uploads/2016/02/Fig-4.jpg" alt=""></p><p>下图是 00 所拍摄的上海交响乐团音乐厅的一角，舞台上方使用了很多木质材料，来获得最佳的混响和其他声音效果。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/SSO.jpg" alt=""></p><h3 id="在-Ableton-Live-里处理混响"><a href="#在-Ableton-Live-里处理混响" class="headerlink" title="在 Ableton Live 里处理混响"></a>在 Ableton Live 里处理混响</h3><p>下面来看看 Ableton Live 里面是如何调整音频的混响的。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5Dreverb.png" alt=""></p><p>混响的参数：</p><ul><li>Dry/Wet: 没有混响/最大混响</li><li>Input: 控制对多少原始信号做混响处理</li><li>Reflect: 混响初期（early reflection），对混响感知影响更大</li><li>Diffuse: 混响末期（late reflection）</li><li>Size: 模拟不同大小的空间的混响 (对 Reflect 的影响大于 Diffuse)</li><li>Decay time: 混响消失所需时间</li><li>Predelay: 原始信号做混响处理之前的等待时间</li></ul><p>以下视频详细讲解了 Reverb 效果器的使用：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=a0714gvoo1l&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/a0714gvoo1l.html" target="_blank" rel="noopener">Reverb in Ableton Live_腾讯视频</a></p><h2 id="Max-MSP-里的延时和混响"><a href="#Max-MSP-里的延时和混响" class="headerlink" title="Max/MSP 里的延时和混响"></a>Max/MSP 里的延时和混响</h2><p>Max/MSP 有丰富的控制延时的方法和对象。</p><p><code>delay~</code></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Ddelay~.png" alt=""></p><p><code>tapin/tapout</code></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dtapin-tapout.png" alt=""></p><p><code>teeth~</code></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dteeth~.png" alt=""></p><p>还有处理非信号的延时器：<code>pipe</code></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dpipe.png" alt=""></p><p>如果对如何从信号层面实现混响有兴趣，可以到 Max/MSP 里面拆开 BEAP 组件里面的 Reverb2，看看到底是怎么实现的。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dreverb2.png" alt=""></p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dreverb2-patch.png" alt=""></p><p>(小编 0 已晕…… 后会有期)</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://book.douban.com/subject/7069885/" target="_blank" rel="noopener">Audio Engineering 101 - A Beginner’s Guide to Music Production</a></li><li><a href="https://www.wikiwand.com/en/Reverberation" target="_blank" rel="noopener">Reverberation - Wikiwand</a></li><li><a href="https://www.acousticpanelsreview.com/acoustic-sound-absorption/" target="_blank" rel="noopener">Acoustic Sound Absorption - Acoustic Panels Review</a></li><li><a href="https://www.wikiwand.com/en/Delay_(audio_effect" target="_blank" rel="noopener">Delay (audio effect) - Wikiwand</a>)</li><li><a href="https://www.wikiwand.com/en/Comb_filter" target="_blank" rel="noopener">Comb filter - Wikiwand</a></li><li><a href="http://aquoibon.li/mixing_guide/" target="_blank" rel="noopener">混音指南（2016） | À quoi bon</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Delay" scheme="http://uegeek.com/tags/Delay/"/>
    
      <category term="Reverb" scheme="http://uegeek.com/tags/Reverb/"/>
    
      <category term="混响" scheme="http://uegeek.com/tags/%E6%B7%B7%E5%93%8D/"/>
    
      <category term="延迟" scheme="http://uegeek.com/tags/%E5%BB%B6%E8%BF%9F/"/>
    
      <category term="音效" scheme="http://uegeek.com/tags/%E9%9F%B3%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise09 - 压缩 Compression</title>
    <link href="http://uegeek.com/180706-make-noise-09.html"/>
    <id>http://uegeek.com/180706-make-noise-09.html</id>
    <published>2018-07-06T03:31:22.000Z</published>
    <updated>2018-08-22T09:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li><li><a href="https://www.uegeek.com/180703-make-noise-08.html" target="_blank" rel="noopener">MakeNoise08 - 振荡器和滤波器</a></li></ul><p>在音频处理中，压缩可以指数据压缩格式（如 mp3 格式），如何压缩可以减少文件大小。本文学习的则是动态范围（Dynamic range）的压缩。<br>￼<br><img src="http://artsites.ucsc.edu/ems/music/equipment/signal_processors/processors_intro/comp.gif" alt=""></p><p>EQ（均衡器） 和 Compressor（压缩器）是 Sound engineering 里面最基础最常用的效果器。压缩器是动态处理器的一种。动态处理器最简单的形式就像一个<strong>自动的音量控制器</strong>（gain control），当音量太大时减低音量，当音量太小时调高音量。</p><p>想象一下，你家的电视有两个不同的频道。一个频道总是很小声，需要用遥控器调整到 20 才听得清楚。另外一个频道却很大声，必需用遥控器调到 12 才不会吵到邻居。</p><p>Compressor 的作用，就相当于每次切换这两个频道的时候，自动帮你调整声音大小，使之保持在合适的范围。<br>￼<br><img src="http://www.yamahaproaudio.com/global/en/Images/pa_beginners_comp12_2.jpg" alt=""></p><p>在音频处理中，<strong>压缩的目的是让乐器、人声或录音的动态范围保持在我们想要的范围</strong>：</p><ul><li>控制动态性能</li><li>填补漏洞</li><li>声音包络控制/塑形</li><li>调控音色</li><li>调整峰值和失真</li><li>Sidechain compression(ducking/dipping/pumping)</li></ul><p>￼<img src="https://www.howtogeek.com/wp-content/uploads/2011/04/clipping_compared_to_limiting.png" alt=""></p><p>更直观来说，压缩处理可以：</p><ul><li>使音频的动态范围更平整（even out）</li><li>融合两种乐器的声音（如bass 和底鼓），听起来更为整体</li><li>提亮音量比较小的声音</li><li>控制太响的声音</li><li>使声音获得特定的音色效果</li><li>创造特别的声音</li></ul><p>所有的动态处理器基本上都是指定一个开始工作的信号电平，然后对信号做出某种形式动态变化。</p><p><img src="https://www.residentadvisor.net/images/features/2012/tech-compress-dynamic-range.jpg" alt=""></p><p>不同压缩方法对 dynamic range 的影响：<br>￼<br><img src="https://dt7v1i9vyp3mf.cloudfront.net/styles/header/s3/imagelibrary/P/Pcomp-02-scales-5vGDFjBDltP2gtc.qx_VD3N2xWxwZHMy.jpg" alt=""></p><p>在 <a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise 06 中我们学习了均衡器(EQ)</a>。那么在处理音频时，应该是先调 EQ 还是先调 Compressor 呢？</p><blockquote><p>Placing an EQ before a compressor can have the effect of  exaggerating the applied EQ. Placing an EQ after a compressor you can often attain more audible results with less EQ, producing results that often do not “sound EQ’s EQ” – Chuck Zwicky</p></blockquote><p>一般来说，EQ 在 Compressor 之前，主要为了调整 Compressor 的反应；EQ 在 Compressor 之后，是为了调整波形达到更好的混音效果。当然也要<a href="http://a85115230.pixnet.net/blog/post/313698829-%E5%85%88eq%EF%BC%9F%E9%82%84%E6%98%AF%E5%85%88compressor%EF%BC%9F" target="_blank" rel="noopener">取决于声音素材和想要的效果</a>。</p><h2 id="在-Ableton-Live-里压缩不同的音轨"><a href="#在-Ableton-Live-里压缩不同的音轨" class="headerlink" title="在 Ableton Live 里压缩不同的音轨"></a>在 Ableton Live 里压缩不同的音轨</h2><p>进入 Ableton Live，在效果库里面找到 Compressor，拖到音轨上，就看到 Compressor 面板中调整压缩的参数：</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5Dcompressor.jpg" alt=""></p><ul><li>Threshold/Input：控制何时触发压缩</li><li>Gain reduction (GR)：有多少 dynamic range 被去掉</li><li>Output/Makeup gain：补偿因压缩导致的音量减小，设定输出的最高电平</li><li>Attack：当信号达到阈值时，压缩器在多少时间内开始处理。Fast attcak 0.01~10 ms, slow attack &gt; 50 ms</li><li>Release：当压缩时，原始信号被保留多久。通常以音频的 tempo 为基准</li><li>Ratio：以输入为基础，按比例设定输出值</li><li>Link：连接双声道/单声道压缩器到另外一个单声道，形成立体效果</li><li>Side chain：使用信号而不是主输入来控制压缩</li><li>Bypass：压缩过滤</li></ul><p>如何调整不同乐器音轨的压缩器，请看下面视频里的详细讲解：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=d0711gj2yf2&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/d0711gj2yf2.html" target="_blank" rel="noopener">Compressor in Ableton Live_腾讯视频</a></p><h2 id="用-Max-MSP-实现-Compressor"><a href="#用-Max-MSP-实现-Compressor" class="headerlink" title="用 Max/MSP 实现 Compressor"></a>用 Max/MSP 实现 Compressor</h2><p>更进一步，我们到 MSP 里拆解 Compressor 是如何实现的。</p><p>官方文档里提供了详细的说明和例子。00 调整和补充了一些注释：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dcompression.png" alt=""></p><p>压缩器主要有三部分构成：参数、压缩流程和处理算法。下面分别看看每一部分的实现。</p><p>可控制的参数主要有 Input gain, Threshold, Ratio, Attack time, Release time，之前我们在 Ableton Live 的 Compressor 面板里都看到了：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dcompression-para.png" alt=""></p><p>压缩处理的主流程：先实时监测 input level，把信号从 amplitude 转换为 dB，然后跟阈值参数比较，判断是否进行压缩：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dcompression-compressor.png" alt=""></p><p>如果达到阈值后开始压缩，需要降低的 gain 由以下部分计算。公式是 <code>(Threshold - Level) * (1 -  1/ratio)</code>：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dcompression-math.png" alt=""></p><p>然后将计算值再换算为 amplitude，输出到 compression 的主流程中，最后再加一道 <code>rampsmooth~</code> 来平滑 gain 的变化。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://book.douban.com/subject/7069885/" target="_blank" rel="noopener">Audio Engineering 101 - A Beginner’s Guide to Music Production</a></li><li><a href="https://zhuanlan.zhihu.com/p/32562033" target="_blank" rel="noopener">什么是动态处理器？</a></li><li><a href="https://docs.cycling74.com/max7/tutorials/17_msp_compress_00" target="_blank" rel="noopener">MSP Compression Introduction: What is Compression?</a></li><li><a href="https://www.soundonsound.com/techniques/parallel-compression" target="_blank" rel="noopener">Parallel Compression |</a></li><li><a href="https://www.residentadvisor.net/features/1595" target="_blank" rel="noopener">RA: Understanding compression</a></li><li><a href="http://a85115230.pixnet.net/blog/post/313698829-%E5%85%88eq%EF%BC%9F%E9%82%84%E6%98%AF%E5%85%88compressor%EF%BC%9F" target="_blank" rel="noopener">先EQ？還是先Compressor？ @ Balanced Audio Lab 平衡音訊實驗室 :: 痞客邦 ::</a></li><li><a href="https://www.kadenze.com/courses/sound-production-in-ableton-live-for-musicians-and-artists-v/sessions/compression-and-dynamics" target="_blank" rel="noopener">Session 6: Compression and Dynamics</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="EQ" scheme="http://uegeek.com/tags/EQ/"/>
    
      <category term="Compressor" scheme="http://uegeek.com/tags/Compressor/"/>
    
      <category term="动态压缩" scheme="http://uegeek.com/tags/%E5%8A%A8%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise08 - 振荡器和滤波器</title>
    <link href="http://uegeek.com/180703-make-noise-08.html"/>
    <id>http://uegeek.com/180703-make-noise-08.html</id>
    <published>2018-07-03T10:35:56.000Z</published>
    <updated>2018-08-22T09:39:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li><li><a href="https://www.uegeek.com/180701-make-noise-07.html" target="_blank" rel="noopener">MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</a></li></ul><p>制造声音，总的来说有两种思路：加性和减性。加性的方法逐步叠加多个声源，减性的方法逐步剔除声音中不想要的部分。</p><p>所以，<strong>声音设计的过程，无外乎是发出声音，修剪、调整为想要的效果</strong>。</p><p>对应的，振荡器是最主要的发声对象，而滤波器是最主要的过滤修整对象。所以这一篇的内容比较多，也会需要回顾之前所讲的一些概念。</p><p><img src="https://is3-ssl.mzstatic.com/image/thumb/Purple5/v4/ce/b8/62/ceb862e4-b96e-912a-cca2-c4169002a0f7/pr_source.png/643x0w.jpg" alt=""></p><h2 id="振荡器和谐振器"><a href="#振荡器和谐振器" class="headerlink" title="振荡器和谐振器"></a>振荡器和谐振器</h2><p>在所有能够产生声音的东西（包括所有乐器）中，绝大部分都是振荡器 (Oscillators)、共振器 (Resonators) 或是两者的组合。</p><h3 id="OSC-振荡器"><a href="#OSC-振荡器" class="headerlink" title="OSC 振荡器"></a>OSC 振荡器</h3><p>电子振荡器是用来产生具有周期性的模拟信号（通常是正弦波或方波）的电子电路。音频振荡器产生频率约为 16 Hz~20 kHz。</p><p>振荡器（OSC）产生原始波形与音高，是所有合成器发声的源头。合成器一般由多个 OSC 或 Wavetable 的声音叠合而成一个音色。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/OSC_2.jpg" alt=""></p><p>如果没有 OSC 振动发出原始音高，其他元件也就没有存在的意义了。（还记得大明湖畔 440 Hz 的中央 A 音高吗？）</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=l0699omxbcq&tiny=0&auto=0" allowfullscreen></iframe><p><a href="http://v.qq.com/x/page/l0699omxbcq.html" target="_blank" rel="noopener">MakeNoise02-frequency_in_max</a></p><p>在 <a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a> 中介绍过基础的波形，它们都产生于基础的振荡器：<br>￼<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Waveforms.svg/700px-Waveforms.svg.png" alt=""></p><h3 id="Resonator-共振器-谐振器"><a href="#Resonator-共振器-谐振器" class="headerlink" title="Resonator 共振器/谐振器"></a>Resonator 共振器/谐振器</h3><blockquote><p>In physics, resonance is a phenomenon in which a vibrating system or external force drives another system to oscillate with greater amplitude at specific frequencies. —Wiki</p></blockquote><p>振荡器和共振器的区别在于，它们出现在能量流动链的什么位置，<strong>是作为原初的波源还是作为被振动源驱动（受力）的系统</strong>。 </p><p>如果两个点有相同的固有频率，则相互冲突的力就变为零。即，由一个点提供给对方的阻抗变为 0 ，这被称为共振/谐振 (resonance)。共振通过在特定频率上施力，来增加震动的幅度 。</p><p>这么说真的好抽象哦……还是直接到 Ableton Live 里面体验一下吧。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5DResonators.png" alt=""></p><p>拖进一段 beats，然后对比开启和关闭 Resonators 的效果：</p><iframe frameborder="0" width="640" height="498" src="https://v.qq.com/iframe/player.html?vid=j0710ontjtv&tiny=0&auto=0" allowfullscreen></iframe><p><a href="https://v.qq.com/x/page/j0710ontjtv.html" target="_blank" rel="noopener">Resonator in Ableton Live_腾讯视频</a></p><h3 id="低频振荡器-LFO"><a href="#低频振荡器-LFO" class="headerlink" title="低频振荡器 LFO"></a>低频振荡器 LFO</h3><blockquote><p>Low-frequency oscillation (LFO) is an electronic signal which is usually below 20 Hz and creates a rhythmic pulse or sweep. – Wiki</p></blockquote><p>低频振荡器发出低于 20Hz 的信号，主要用来<strong>驱动其他参数、调制合成器/延迟等形成周期性响应</strong>，以此来制造出特定的音效，而不是作为主频发声振荡器。</p><p><img src="https://impmoocmath.files.wordpress.com/2013/04/lfo.png" alt=""></p><p>LFO 的主要参数：</p><ul><li>Shape：Sine、Square、Pulse、Triangle、Sawtooth 等波形</li><li>Rate：控制振动時間的快慢，可以调为预设的 BPM</li><li>Amount/Depth：控制振动的强度</li><li>Phase/Offset：波形起始位置</li></ul><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5DAuto_filter.png" alt=""></p><p>LFO的使用范围很广泛，当需要<strong>制造往复变化的周期性效果</strong>，如音高一高一低的 Vibrato，相位一左一右的 AutoPan，音量一强一弱的 Tremolo…等等，都可以利用 LFO 来生成。在一部强大的合成器上，方便且多功能的 LFO 是不可或缺的。</p><h2 id="滤波器-Filter"><a href="#滤波器-Filter" class="headerlink" title="滤波器 Filter"></a>滤波器 Filter</h2><p>声音由振荡器/谐振器产生以后，<strong>声音塑形的第二个关键，就是调整其频率分布</strong>。Filter 起到限制信号的频率范围的作用，它其实就是<a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">最简单的 EQ</a>。</p><p><img src="https://static.kvraudio.com/i/b/sanfordsuperfilter.jpg" alt=""></p><p>按过滤的频率来区分，滤波器可分为以下几类：</p><ul><li>Low Pass Filter 低通滤波（LP）：允许低于其中心频率的信号更多的通过（过滤掉高频信号）</li><li>High Pass Filter 高通滤波（HP）：允许高于其中心频率的信号更多的通过（过滤掉低频信号）</li><li>Band Pass Filter 带通滤波（BP）：允许指定频段的频率通过，过滤掉两侧的频率</li><li>Band Reject 带阻（陷波）（BR）：在频谱中过滤掉一部分频率，保留其他频段</li></ul><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/basic%20filters.jpg" alt=""></p><p>在 Ableton Live 的 EQ Eight 中，八个调节点都可以选择采用哪种滤波形式：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5DEQ8.png" alt=""></p><p>按响应方式来区分，滤波器有两类：</p><ul><li>FIR：输出仅取决于输入的过往数值，称为有限冲激响应 Finite Impulse Respons</li><li>IIR：输出取决于过往的输入值和过往的输出值，围绕延时元件有一个反馈环路，称为循环（recursive）或无限冲激响应（Infinite Impulse Response）滤波器。可用作累加器，如果反馈很高，当前输入会被加到所有先前输入值上。</li></ul><p>Filter 的主要参数包括 Cutoff / Freq 和 Resonance / Res。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5DAuto_filter.png" alt=""></p><p>选定 Filter 波形后，需要指定过滤的频率界点(Cutoff)。比如选择低通滤波，将 Cutoff freq 指定为 800Hz，那么高于 800Hz 的频率将被滤除。通过指定 Cutoff 的落点，达到调整音色的目的。Res 的作用则主要是为了凸显 Cutoff 所在的频率位置（放大 db）。</p><h2 id="Max-MSP-里的滤波器"><a href="#Max-MSP-里的滤波器" class="headerlink" title="Max/MSP 里的滤波器"></a>Max/MSP 里的滤波器</h2><p>Max/MSP 提供了一系列滤波器任君选择。</p><p><code>Onepole~</code>: 单系数滤波器，也是最简单的 IIR(Infinite Impulse Response) 低通滤波器，常用来减少刺耳的高频信号，或者用来平滑信号。</p><p>虽然<code>onepole~</code>的基础用法是低通滤波，不过只要做一个简单的信号减法操作，就可以起到高通滤波的效果：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Donepole.png" alt=""></p><p>单系数不够？那么 <code>Biquad~</code> 双系数过滤器 了解一下~</p><p>为什么叫双系数呢？因为滤波公式为：</p><blockquote><p>y[n] = a0 <em> x[n] + a1 </em> x[n-1] + a2 <em> x[n-2] - b1 </em> y[n-1] - b2 * y[n-2]</p></blockquote><p>其中 a0, a1, a2, b1, b2 都是可调参数。</p><p>双系数不够？那么了解一下：<code>cascade~</code> 级联滤波器（多个<code>biquad~</code>）</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dcascade~.png" alt=""></p><p>级联可调性较差？那么 <code>filtergraph~</code> 了解一下：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dfiltergraph~2.png" alt=""></p><p>如果还是无法满足需求，请尽情折腾更为灵活的<code>filterdesign</code>……</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BMax%5Dfilterdesign.png" alt=""></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://book.douban.com/subject/27057297/" target="_blank" rel="noopener">设计声音</a></li><li><a href="https://www.wikiwand.com/en/Resonance" target="_blank" rel="noopener">Resonance - Wikiwand</a></li><li><a href="https://www.coursera.org/lecture/technology-of-music-production/lfo-low-frequency-oscillator-zBCiz" target="_blank" rel="noopener">LFO (Low Frequency Oscillator) - Synthesis | Coursera</a></li><li><a href="https://www.zuirens.com/%E6%8E%A2%E7%B4%A2%E5%90%88%E6%88%90%E5%99%A8%E7%9A%84%E5%A5%A7%E5%A6%99/" target="_blank" rel="noopener">探索合成器的奧妙 | Zuirens 燧人氏</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="EQ" scheme="http://uegeek.com/tags/EQ/"/>
    
      <category term="Oscilator" scheme="http://uegeek.com/tags/Oscilator/"/>
    
      <category term="Filter" scheme="http://uegeek.com/tags/Filter/"/>
    
      <category term="LFO" scheme="http://uegeek.com/tags/LFO/"/>
    
      <category term="过滤器" scheme="http://uegeek.com/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>MakeNoise07 - 音频的分辨率 Sample rate/Bit depth</title>
    <link href="http://uegeek.com/180701-make-noise-07.html"/>
    <id>http://uegeek.com/180701-make-noise-07.html</id>
    <published>2018-07-01T09:57:02.000Z</published>
    <updated>2018-08-22T09:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png" alt=""></p><a id="more"></a> <ul><li><a href="https://www.uegeek.com/180621-make-noise-01.html" target="_blank" rel="noopener">MakeNoise01 - 声音是什么？</a></li><li><a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">MakeNoise02 - 频率和音高</a></li><li><a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03 - 振幅/响度/音量/增益 大乱斗</a></li><li><a href="https://www.uegeek.com/180626-make-noise-04.html" target="_blank" rel="noopener">MakeNoise04 - 波形和相位</a></li><li><a href="https://www.uegeek.com/180628-make-noise-05.html" target="_blank" rel="noopener">MakeNoise05 - Envelope 包络（ADSR）</a></li><li><a href="https://www.uegeek.com/180629-make-noise-06.html" target="_blank" rel="noopener">MakeNoise06 - 音色和均衡器(EQ)</a></li></ul><p>在 <a href="https://www.uegeek.com/180624-make-noise-03.html" target="_blank" rel="noopener">MakeNoise03</a> 中，我们区分了第一捆容易混淆的概念：振幅/响度/音量/增益。</p><p>今天来捋一捋第二捆概念们——Sample rate / Bit depth / Dynamic range / Bit rate，它们影响了声音的分辨率。</p><p>图像的分辨率是大家比较熟悉的概念。在一个固定尺寸的图像里包含多少像素，决定了图像的分辨率。</p><p><img src="http://www.andor.com/Portals/0/Intro_10_Small.jpg" alt=""></p><p>由此可以类比声音的「分辨率」。</p><p><strong>一个声音信号的质量由两个变量决定：采样速率 Sample rate 和 比特深度（位深度）Bit depth。</strong></p><p>图像分辨率由横纵坐标的像素数量所决定。对应到声音，Sample rate 设定了能够捕捉音频信号的最高频率，可以看做横坐标；Bit depth 决定了每一个 sample 的精度，可以看做纵坐标。两者在两个维度上共同决定了音频的分辨率。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/bit-depth-low.png" alt=""><br>￼<br><img src="http://7xjpra.com1.z0.glb.clouddn.com/bit-depth-high.png" alt=""></p><h2 id="采样率-Sample-rate"><a href="#采样率-Sample-rate" class="headerlink" title="采样率 Sample rate"></a>采样率 Sample rate</h2><blockquote><p>The sampling frequency or sampling rate, fs, is the average number of samples obtained in one second (samples per second) — wiki</p></blockquote><p>采样率决定了每一秒内会从音频信号中采集多少样本。</p><p>在现实世界中的音频采样，是不连续或离散的信号，每个梯级值都是一个数值，表示一个单一时间点上的幅度。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/50/Signal_Sampling.png/600px-Signal_Sampling.png" alt=""></p><p>多少采样点算是足够多，能够精确编码一个声音信号呢？这就要提到 The Nyquist Theorem （尼奎斯特定理）了：</p><blockquote><p>States that the signal’s sample rate must be at least two times greater than the highest desired frequency. </p></blockquote><p>采样率/2是一个特殊数字，被称为奈奎斯特点 Nyquist point，它是在任何声音中能够被一个给定采样率所编码的最高频率。 也就是说，每秒的采样至少是信号中的最高频率的 2 倍，就可以完美地还原声音信号。</p><p>所以，为了覆盖<a href="https://www.uegeek.com/180623-make-noise-02.html" target="_blank" rel="noopener">人类的听觉范围（20Hz~20kHz）</a>，每秒需要 40000 个采样点。</p><p>那么问题来了，既然 40 kHz 就够了，为什么现在音频 CD 的标准采样率是 44.1 kHz 呢？</p><p>一方面原因是工程的需要。</p><p>现实中，麦克风所能接收、采集到的空气振动的频率范围非常大，远远超过人耳听力。如果直接采样会出现混叠。所以要先使用一个低通滤波器，把高于阈值的信号过滤掉。超过 40 kHz 的频段，给低通滤波器留出空间，使得那一段不怎么完美的下降曲线落在 20KHz 之外，不影响音频效果。</p><p>另一方面是技术历史问题。</p><p>在数字存储媒介被发明之前，早期的数字音频录制在模拟录像带上。当时世界上的录像机主要有二大制式：欧洲的 PAL 和美国日本的 NTSC。当时的 CD 是 SONY（美日制式）与 PHILIPS（欧洲制式）合作的。适用于 PAL 制式录像机的编码器采样频率是 44.1kHz。适用于 NTSC 制式录像机的编码器采样频率是 44.056。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/cd.png" alt=""></p><p>那么 44.1 和 44.056kHz 这两个数字是怎么来的呢？</p><blockquote><p>44,100=294 x 50 x 3</p><p>44,056=245 x 59.94 x 3</p></blockquote><p>50Hz 和 59.94Hz 分别是 PAL 和 NTSC 的场频， PAL 制式下可用扫描线数是 294 线，而 NTSC 则是 245 线。至于x3，则是在一条视频扫描线的磁迹中，纪录三个数码音频数据块。44.056KHz 标准并不能很好地被 NTSC 系统兼容，有一定的误差，所以没有被市场接受。索尼提出了以  44.1KHz/16bit 的方式录制，在数字信号和模拟信号的过渡期，大获全胜。哪怕最后出现了数字CD，也没有敌得过用户的使用惯性。</p><p>更多这个话题的讨论，可以参考知乎问题：<a href="https://www.zhihu.com/question/27644914" target="_blank" rel="noopener">人耳 20kHz 封顶，为什么数字音频都要记录和解析到更高的频率上去？</a></p><p>那该用什么样的采样率呢？</p><blockquote><p>The Audio Engineering Society recommends 48 kHz sampling rate for most applications but gives recognition to 44.1 kHz for CD and other consumer uses, 32 kHz for transmission-related applications, and 96 kHz for higher bandwidth or relaxed anti-aliasing filtering. — wiki</p></blockquote><h2 id="比特深度-Bit-Depth"><a href="#比特深度-Bit-Depth" class="headerlink" title="比特深度 Bit Depth"></a>比特深度 Bit Depth</h2><blockquote><p>In digital audio using pulse-code modulation (PCM), bit depth is the number of bits of information in each sample, and it directly corresponds to the resolution of each sample.  — Wiki</p></blockquote><p>在 CD 的采样标准中，44.1 kHz 的 Sample Rate 我们有所了解了。那么 16 Bit Depth 又是什么意思呢？</p><p>在音频采样中，每个采样的 amplitude 用二进制数字编码。这个编码的分辨率就是比特深度。</p><p>把数据存储成二进制，意味着如果用 n 个二进制位来存储每个幅度值，总共可以表示的数值数量为 2 的 n 次方-1。1 bit 代表采样的值: 0 或 1。如果是 2 bit，采样值范围就是 0, 1, 2, 3。2 的 16 次方是 65536，所以 16 bit 的采样深度分辨率是 -32768~32768。</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/bit%20depth.png" alt=""></p><p>Bit depth 实际上决定的是 dynamic range 的分辨率。</p><h2 id="动态范围-Dynamic-Range"><a href="#动态范围-Dynamic-Range" class="headerlink" title="动态范围 Dynamic Range"></a>动态范围 Dynamic Range</h2><blockquote><p>Dynamic range is the ratio between the largest and smallest values that a certain quantity can assume. It is measured either as a ratio or as a base-10 (decibel) or base-2 (doublings, bits or stops) logarithmic value of the difference between the smallest and largest signal values.</p></blockquote><p>声音的 dynamic range 由信号的最大值和最小值所决定。</p><p>在音频处理中，dynamic range 与最大振幅和 noise floor 的比值有关：</p><p>￼<img src="http://7xjpra.com1.z0.glb.clouddn.com/calculate-dynamic_range.png" alt=""></p><p>假设 1 bit 表示听觉的门限，16 位 bit depth 可以给出 98 dB 的 dynamic range，32 位为 192 dB，64 位为 385 dB。现在很多数字音频系统都用 64 位。</p><h2 id="比特率-Bit-Rate"><a href="#比特率-Bit-Rate" class="headerlink" title="比特率 Bit Rate"></a>比特率 Bit Rate</h2><p>还有一个容易与采样率、比特深度混淆的概念，叫比特币，哦不对，比特率。</p><blockquote><p>在数字多媒体领域，比特率是单位时间播放连续的媒体(如压缩后的音频或视频)的比特数量，常用码流或码率表示，单位是kbps（千位每秒）。——wiki</p></blockquote><p>高音质 MP3 的 Bit rate 可达 256-320 kbps ，低音质的 MP3 大概在 100 kbps 。</p><p>音频数据的比特率文件大小计算公式如下：</p><blockquote><p>Bit rate = sample rate <em> bit depth </em> channels</p><p>Size in bits = sample rate <em> bit depth </em> channels * length of time</p></blockquote><p>所以，Sample rate 和 Bit depth 会影响 Bit rate 和文件大小。</p><p>一般原始的多媒体文件都比较大，为了便于使用需要对其进行压缩，而码流就对应了压缩时的取样率。单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件也会越大。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天我们又梳理了一捆容易混淆的概念们：</p><ul><li>Sample rate：每秒采集的音频信号样本</li><li>Bit depth：每个信号样本的幅度范围分辨率</li><li>Dynamic range：信号的范围极限值区间</li><li>Bit rate：单位时间传送的媒体信号量</li></ul><p>以后，看见 DAW 里面相关的选项，就心里有数啦：</p><p><img src="http://7xjpra.com1.z0.glb.clouddn.com/%5BAbleton%5Dexport.png" alt=""></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>在数字音频领域，常用的采样率有：</p><table><thead><tr><th>Sample Rate</th><th>Use</th></tr></thead><tbody><tr><td>8,000 Hz</td><td>电话所用采样率，对于人的说话已经足够</td></tr><tr><td>22,050 Hz</td><td>无线电广播所用采样率</td></tr><tr><td>32,000 Hz</td><td>miniDV数码视频camcorder、DAT（LP mode）所用采样率</td></tr><tr><td>44,100 Hz</td><td>音频CD,也常用于MPEG-1音频（VCD, SVCD, MP3）所用采样率</td></tr><tr><td>47,250 Hz</td><td>Nippon Columbia（Denon）开发的世界上第一个商用PCM录音机所用采样率</td></tr><tr><td>48,000 Hz</td><td>miniDV、数字电视、DVD、DAT、电影和专业音频所用的数字声音所用采样率</td></tr><tr><td>50,000 Hz</td><td>二十世纪七十年代后期出现的3M和Soundstream开发的第一款商用数字录音机所用采样率</td></tr><tr><td>50,400 Hz</td><td>三菱X-80数字录音机所用所用采样率</td></tr><tr><td>96,000或者192,000 Hz</td><td>DVD-Audio、一些LPCM DVD音轨、Blu-ray Disc（蓝光碟）音轨、和HD-DVD（高清晰度DVD）音轨所用所用采样率</td></tr><tr><td>2.8224 MHz</td><td>SACD、索尼和飞利浦联合开发的称为Direct Stream Digital的1位sigma-delta modulation过程所用采样率。</td></tr></tbody></table><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://book.douban.com/subject/7069885/" target="_blank" rel="noopener">Audio Engineering 101 - A Beginner’s Guide to Music Production</a></li><li><a href="https://book.douban.com/subject/27057297/" target="_blank" rel="noopener">设计声音</a></li><li>Max_MSP<em>Jitter for music </em> a practical guide to developing interactive music systems for education and more</li><li><a href="https://www.wikiwand.com/en/Sampling_(signal_processing" target="_blank" rel="noopener">Sampling (signal processing) - Wikiwand</a>#/Sampling_rate)</li><li><a href="https://www.wikiwand.com/en/Audio_bit_depth" target="_blank" rel="noopener">Audio bit depth - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Dynamic_range" target="_blank" rel="noopener">Dynamic range - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Bit_rate" target="_blank" rel="noopener">Bit rate - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Nyquist_rate" target="_blank" rel="noopener">Nyquist rate - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh-hans/%E9%87%87%E6%A0%B7%E7%8E%87" target="_blank" rel="noopener">采样率 - Wikiwand</a></li><li><a href="https://www.zhihu.com/question/27644914" target="_blank" rel="noopener">人耳 20kHz 封顶，为什么数字音频都要记录和解析到更高的频率上去？- 知乎</a></li><li><a href="https://www.zhihu.com/question/22027722/answer/119031221" target="_blank" rel="noopener">CD为什么采用44.1kHz采样频率? - 知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://7xjpra.com1.z0.glb.clouddn.com/MakeSound-title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Music" scheme="http://uegeek.com/tags/Music/"/>
    
      <category term="Sound" scheme="http://uegeek.com/tags/Sound/"/>
    
      <category term="声音" scheme="http://uegeek.com/tags/%E5%A3%B0%E9%9F%B3/"/>
    
      <category term="Ableton Live" scheme="http://uegeek.com/tags/Ableton-Live/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Sample rate" scheme="http://uegeek.com/tags/Sample-rate/"/>
    
      <category term="采样率" scheme="http://uegeek.com/tags/%E9%87%87%E6%A0%B7%E7%8E%87/"/>
    
      <category term="Bit rate" scheme="http://uegeek.com/tags/Bit-rate/"/>
    
      <category term="Bit depth" scheme="http://uegeek.com/tags/Bit-depth/"/>
    
      <category term="Dynamic range" scheme="http://uegeek.com/tags/Dynamic-range/"/>
    
  </entry>
  
</feed>
