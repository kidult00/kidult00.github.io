<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>00&#39;s Adventure</title>
  
  <subtitle>Why join the navy if you can be a pirate</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://uegeek.com/"/>
  <updated>2018-11-20T12:54:55.373Z</updated>
  <id>http://uegeek.com/</id>
  
  <author>
    <name>kidult00</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生成式艺术和算法创作06-形状语法</title>
    <link href="http://uegeek.com/181120-generative-art-creativity-06.html"/>
    <id>http://uegeek.com/181120-generative-art-creativity-06.html</id>
    <published>2018-11-20T12:51:14.000Z</published>
    <updated>2018-11-20T12:54:55.373Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><p># </p><ul><li><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></li><li><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></li><li><a href="https://www.uegeek.com/181021-generative-art-creativity-03.html" target="_blank" rel="noopener">生成式艺术和算法创作03-混沌和分形</a></li><li><a href="https://www.uegeek.com/181023-generative-art-creativity-04.html" target="_blank" rel="noopener">生成式艺术和算法创作04-规则系统</a></li><li><a href="https://www.uegeek.com/181107-generative-art-creativity-05.html" target="_blank" rel="noopener">生成式艺术和算法创作05-Tessellation</a></li></ul><p>形状语法/形状文法（Shape grammars）是生成特定类别几何形状的生产系统。</p><p>1971年，<a href="https://www.wikiwand.com/en/George_Stiny" target="_blank" rel="noopener">George Stiny</a> 和 <a href="https://www.wikiwand.com/en/James_Gips" target="_blank" rel="noopener">James Gips</a> 在一篇开创性的文章中定义了形状语法的基础。形状语法是一种计算机辅助设计方法，是研究二维和三维语言的一种方式，它可以按照人们的设计思想和要求，按照一定的规则自动产生新形态。</p><p><img src="http://web.mit.edu/haldane/www/icerays/sm_iceray07.jpg" alt=""></p><p>具体来说，形状语法由形状规则（shape rules）和选择、处理规则的生成引擎（generation engine）组成。形状语法执行计算的两个主要步骤是：识别特定形状，用可能的形状替代。</p><p>形状规则定义如何转换现有形状，由两个部分组成，两个部分由从左到右指向的箭头分隔：</p><ul><li>箭头左侧的部分称为左侧（LHS），描绘形状和标记的条件。</li><li>箭头右侧的部分称为右侧（RHS），描述如何转换 LHS 形状以及标记的位置，标记有助于定位和定向新形状。</li></ul><p>形状语法最少由三个形状规则组成：<strong>起始规则，至少一个转换规则和终止规则</strong>。形状语法中的生产规则可以连续应用，类似 <a href="https://www.wikiwand.com/en/L-System" target="_blank" rel="noopener">L-Systems 中的</a> productions。</p><p>形状语法通常是一个四元组，SG＝（S, L, R, I）。其中 S 是形状的有限集合，L 是符号的有限集合，R 是规则的有限集合，I 是初始形状。形状文法产生的形状，都应通过形状规则由初始形状派生出来。</p><p><img src="/Users/kidult00/Downloads/Courses/Kadenze/generative-art-and-computational-creativity-i/3-rule-based-systems-grammars-and-markov-chains/shape%20grammars%20in%20action.png" alt="shape grammars in action"></p><p><img src="https://d2w9rnfcy7mm78.cloudfront.net/2351379/display_c5bf667d63e6917a82a5163d65212a6d.jpg" alt=""></p><p>形状语法在一个小规模的、定义明确的生成问题（如住房布局和结构细化）时最有用。由于形状规则通常是在小形状上定义的，因此形状语法可以包含许多规则。</p><p>Mitchell 提出的 Palladian 别墅形状语法包含 69 个规则，这些规则适用于整个八个实施步骤。</p><p><img src="https://images.slideplayer.com/27/9112988/slides/slide_6.jpg" alt=""></p><p><img src="https://images.slideplayer.com/27/9112988/slides/slide_7.jpg" alt=""></p><p>Rules of Mughal garden：</p><p><img src="https://arch.gatech.edu/sites/default/files/03_mughal_production.jpg" alt=""></p><p>借助 CAD，形状语法可以节省人力、缩短设计周期、产生系列化方案，能很好地传承文脉，使设计内涵在新环境下得以保存和发展，受到了设计界尤其是建筑设计的高度重视。</p><p><img src="http://keyan.info/wp-content/uploads/2013/04/KeyanGrammar2.png" alt=""></p><p><img src="https://arch.gatech.edu/sites/default/files/08_98_cube_subgroups.jpg" alt=""></p><p>近几十年来，形状语法在计算机图形学中越来越重要。 </p><p>除了用于建筑物或城市的程序建模（例如电影或视频游戏），Shape Grammars 是许多开发系统的基础，它们使用生产规则来生成各种不同的 3D 模型。 使用 Shape Grammars 可以创建具有逼真外观的街道平面图，以及建筑物的外墙或内部空间。</p><p>运用形状语法生成的建筑模型和建筑设计：</p><p><img src="/Users/kidult00/Downloads/Courses/Kadenze/generative-art-and-computational-creativity-i/3-rule-based-systems-grammars-and-markov-chains/architecture%20used%20shape%20grammars.png" alt="architecture used shape grammars"></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Shape_grammar" target="_blank" rel="noopener">Shape grammar - Wikiwand</a></li><li><a href="http://www.shapegrammar.org/" target="_blank" rel="noopener">Shape Grammars</a></li><li><a href="https://www.youtube.com/watch?v=pg1NpMmPv48" target="_blank" rel="noopener">The complex geometry of Islamic design - Eric Broug - YouTube</a></li><li><a href="http://users.metu.edu.tr/baykan/arch467/Readings/Stiny-Mitchell.pdf" target="_blank" rel="noopener">Stiny-Mitchell.pdf</a></li><li><a href="https://arch.gatech.edu/design-computation-1" target="_blank" rel="noopener">Design Computation | School of Architecture | Georgia Institute of Technology | Atlanta, GA</a></li><li><a href="https://slideplayer.com/slide/9522024/" target="_blank" rel="noopener">What is computation? What is a shape grammar? How are shape grammars used in design? How is a shape grammar developed? - ppt download</a></li><li><a href="https://www.youtube.com/watch?v=t-VUpX-xVo4" target="_blank" rel="noopener">Procedural Building Generation with Grammars - YouTube</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="Shape Grammar" scheme="http://uegeek.com/tags/Shape-Grammar/"/>
    
      <category term="形状语法" scheme="http://uegeek.com/tags/%E5%BD%A2%E7%8A%B6%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>兴趣多动症的自救指南 | 00 的 TEDx 演讲全文</title>
    <link href="http://uegeek.com/181112TedxWumaStreet.html"/>
    <id>http://uegeek.com/181112TedxWumaStreet.html</id>
    <published>2018-11-12T15:54:05.000Z</published>
    <updated>2018-11-12T16:25:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/TEDxWumaStreet.jpg" alt="TEDxWumaStreet"></p><blockquote><p>11 月 3 日，一场以「变」为主题的思想大会 TEDxWumaStreet 在温州开讲。12 位来自学术界、互联网、新闻界、文化产业、地产行业、设计领域的讲者，跨越山川湖海，共赴这场知识盛宴。 </p><p>尽管行业不同、背景各异，但他们都是自身领域中的思考者和实践者，都在用思想和行动 Remake 人生，讲述精彩故事。 </p></blockquote><p><img src="http://img.viz.mobi/TEDxWumaStreetSpeakers1.jpg" alt="TEDxWumaStreetSpeakers1"></p><p><img src="http://img.viz.mobi/TEDxWumaStreetSpeakers2.jpg" alt="TEDxWumaStreetSpeakers2"></p><p>00 有幸作为本年度 TedxWumaStreet 的受邀演讲者，以自己所经历的兴趣和职业之「变」为主题，分享了个人的 Remake 故事。</p><p>以下是演讲全文，也许你也能感受到这个颇受关注的议题的共鸣，欢迎参与讨论。</p><a id="more"></a><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.002.jpeg" alt="兴趣多动症的自救指南.002"></p><p>这是一则寻人启事。</p><p>请大家回忆一下，在自己的亲朋好友、同事同学里面，有没有这样一类人：他们兴趣广泛，每隔一段时间都会开辟一些新的爱好。比如，这个月是美食博主、下个月可能就玩起了电子音乐。可是，他们挖坑远比填坑快，很难有长久的兴趣。</p><p>你可以回想一下这个朋友的名字，又或者，那个人就是你自己。</p><p>那么，欢迎加入兴趣多动症大家庭。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.005.jpeg" alt=""></p><p>这个词是我编造的，我用它来称呼这样一群人，他们经常要面对一个来自灵魂的拷问：</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.006.jpeg" alt=""></p><p>兴趣太多，容易一事无成，怎么办？</p><p>我被这个问题困扰了很久，应该是一个资深的患者。</p><p>我是学地理出身的互联网产品设计师，曾经在微信、网易等团队做了多年的产品和人机交互设计，业余运营两个公众号 HackYourself 和 ArtxCode，是一名写得了代码、焊的了电路板的菜鸟创客。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.007.jpeg" alt=""></p><p>今天想跟大家分享的是，作为一个兴趣多动症患者，这十多年来我的困惑和领悟。</p><p>兴趣多动症，其实是一种长时间注意力缺乏的表现，做事容易三分钟热度。据我观察，患有这个病症的人群正在快速扩大，因为我们身处的时代，信息越来越丰富，而注意力越来越稀缺。</p><p>具体来说呢，这个病症主要有两个症状——多和动。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.010.jpeg" alt=""></p><p>这一群人很容易被有意思的事情所吸引，这也觉得新鲜，那也觉得好玩。兴趣广泛是好事，可是兴趣泛滥就很难收拾了。然后，他们不但爱胡思乱想，还喜欢比划两下。行动力强是好事，可是经常乱动，也许就是不规则的布朗运动了。</p><p>//</p><p>俗话说，久病成医。</p><p>因为跟这个病症斗争了许多年，我也慢慢开始学着自救。自救的第一步呢，是先给自己把把脉。</p><p>之所容易兴趣广泛变成兴趣泛滥、行动变成乱动，我认为是没有处理好三对主要矛盾：</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.012.jpeg" alt=""></p><p><strong>一个是深度和广度的矛盾。一个是探索和应用的矛盾，应该多探索不同的领域，还是应该尽可能地学以致用，提高投入产出比？还有一个矛盾是愉悦和成就。是满足自己的好奇心、追求新鲜刺激呢，还是应该潜下心来好好积累，成为专家？</strong></p><p>这一群人自然是会选择广度、探索和愉悦的。</p><p>那么，有没有可能，既顺应天性，又不需要去做两难的取舍呢？</p><p>我想应该是有的，前提是要从我们给自己设下的二元对立的陷阱中挣脱出来。</p><p>//</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.014.jpeg" alt=""></p><p>第一个矛盾是追求深度还是追求广度。</p><p>我小时候是个乖学生，但是发现我的同桌们，有一个解答难题最取巧的方法。那就是——直接看别人的答案。所以，我们也可以找出那些兴趣很多，但是样样精通的人，看看他们是如何做到的。</p><p>大家可以想象这样一个人吗？他既拿过奥斯卡奖，又得过奥运会冠军。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.015.jpeg" alt=""></p><p>赫伯特·西蒙就是这样一位神奇的人物，不过他不是奥斯卡影帝和奥运金牌得主，他是至今唯一一位既得过诺贝尔奖又得过图灵奖的学术泰斗。图灵奖就好比计算机科学里的奥斯卡奖。</p><p>对多数人而言，一辈子在一个领域有所成就已经非常幸运了，而西蒙一生一共拿了 9 个博士学位，在经济学、政治学、管理学、人工智能、心理学、认知科学等领域都是大师级的人物……这简直是开了挂的人生，他是怎么做到的呢？</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.016.jpeg" alt=""></p><p>西蒙那些看似庞杂的研究领域，其实是围绕一个大问题展开的：</p><blockquote><p>人类如何决策</p></blockquote><p>他意识到这是人类行为的中心问题，无法由单一学科来解答。他分别从政治学、经济学与管理学视角研究过组织行为以后，转向了心理学，提出有限理性理论。为了深入解释人类决策的机制，又尝试用计算机去模拟人的思维过程，于是成为人工智能的先驱之一。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.017.jpeg" alt=""></p><p>西蒙的例子告诉我们，如果由一个大的主题来驱动，庞杂的兴趣不是障碍，反而是优势。但是如果反过来，先任由兴趣蔓延，再尝试将它们有机结合起来，则要困难很多。</p><p>那么，要如何找到属于自己的主题呢？这也是我探索了多年的问题。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.019.jpeg" alt=""></p><p>我在大学学的是地理信息系统和旅游规划，却做了<a href="https://www.uegeek.com/tags/%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%86/" target="_blank" rel="noopener">互联网产品</a>和<a href="https://www.uegeek.com/tags/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">交互设计</a>的工作。刚开始我觉得挺焦虑的，好像那么多年白费了，一切要从零开始。后来，当我尝试把学科和领域抽象出来，寻找它们的共性，就有了不一样的发现。</p><p>我学的专业是地理，地理学的核心问题是人地关系，对应的实践领域是 planning，规划。我的工作是人机交互设计，顾名思义就是要研究人和计算机的关系，对应的实践领域是 design，设计。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.020.jpeg" alt=""></p><p>其实规划和设计的相似远大于差异，只不过我研究的对象、还有问题的尺度发生了变化，从区域、城市、旅游景区的规划，变成了电脑和手机屏幕界面的设计。</p><p>这就是我对第一个矛盾的理解：<strong>当我们觉得自己的兴趣太多太杂的时候，不仿为它寻找一个主题。</strong></p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.021.jpeg" alt=""></p><p>//</p><p>第二个矛盾，探索和应用，我把它称为资本家的小算盘。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.022.jpeg" alt=""></p><p>试想一下，如果我们是一名淘金者，可能经常需要做这样的取舍：是继续找更大的金矿，还是先把已经找到的矿开采完？探索还是开采，是资源有限的情况下，经常会遇到的两难。当我们面对新的领域和知识，想尝试另外一种职业、另外一种身份，甚至另外一种人生的时候，这个主题就会反复出现。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.023.jpeg" alt=""></p><p>我认为，想种不同的果树、尝试不同的人生，没有问题。问题往往出在，果树还没有结出果实就把树砍了，一种人生的滋味还没有尝到就提前离席了。</p><p>兴趣太多，最容易遇上的尴尬就是从刚入门到秒放弃。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.025.jpeg" alt=""></p><p>比如我，高中开始学吉他，但是几乎每一次都是练到手指起茧刚开始有进步，就没有继续下去了。所以十多年来依然停留在高级入门水平。</p><p>任何兴趣，都需要一个生长期。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.026.jpeg" alt=""></p><p>深耕一个领域，一两年太短，十年又可能坐不住。<strong>那么不妨试着给兴趣分配一笔大额的预算，以两年或者四年为一个财政周期，就像重新读一次本科或者研究生，在开始时就选好课题，督促自己在这个周期内必需学有所成，交出像样的作品才能拿到毕业证。</strong></p><p>Tim Ferriss 也是一名兴趣多动症患者。他是企业家、畅销书作家、演员、武术和舞蹈爱好者，会 6 国语言，拿过中国散打全美冠军、保持着一项探戈舞吉尼斯世界记录。虽然涉猎广泛，但是他会在某一段时间内（比如说 3-6 个月）沉浸地学习某项新技能，直到学有所成，并且把学习经验整理出来出版。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.027.jpeg" alt=""></p><p>我觉得他的方法非常好。所以我也试着给我的兴趣至少半年的时间，并且记录自己的学习过程。</p><p>我一直对做东西感兴趣，所以参加了 <a href="https://www.uegeek.com/tags/Fab/" target="_blank" rel="noopener">MIT 麻省理工大学一个向全球开放的课程</a>，用半年的时间专门学习数字制造的各种技能，包括 3D 建模，3D 打印，电路设计，嵌入式开发等等。每周要去上课，在实验室里动手做作业。</p><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=t0312hw9hzn" allowfullscreen="true"></iframe><p>因为当时是在国内最早的一批学生，没有什么中文的资料，所以我把<a href="https://www.uegeek.com/tags/Fab/" target="_blank" rel="noopener">每一周的笔记和需要动手做出实物的作业</a>都写成了教程。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.029.jpeg" alt=""></p><p>半年里，看着自己一点一点地学着画图、操作机器、接电路板、编程，最终还通过了答辩拿到了毕业证，就会觉得从入门到没有放弃，这种感觉真是太鼓舞人心了。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.030.jpeg" alt=""></p><p>所以，<strong>面对探索和应用的矛盾，我们可以设定兴趣周期，在相对固定的时间框架内自由探索，并且形成积累，成为下一个阶段的储备。</strong></p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.031.jpeg" alt=""></p><p>//</p><p>第三个难题，是如何平衡愉悦和成就。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.032.jpeg" alt=""></p><p>多动症患者很喜欢 接触新课题时的感觉，喜欢即时满足，可能容易欺骗自己认为已经学到了，而对漫长、看似停滞的练习阶段缺乏耐心。可是如果不经过积累，哪来的成果和意义呢？</p><p>这个矛盾困扰了我很久。直到有一天，我突然反问自己，为什么愉悦和成就变成了矛盾呢？</p><blockquote><p>愉悦到底来自哪里？</p><p>什么样的愉悦是我们应该追求的？</p><p>怎样可以既愉悦又有所建树？</p></blockquote><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.034.jpeg" alt=""></p><p>村上春树在《我的职业是小说家》这本书里这样写到。在外人看来，村上的写作生活，规律到有点乏味，就像钟表一样分秒不差。每天 4 点起床，写作 5 小时，下午跑步 1 小时或游泳 1 个半小时，然后读书、听音乐，晚上 9 点睡觉。这样的作息，从他写长篇小说开始，几乎从未改变。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.035.jpeg" alt=""></p><p>愉悦和成就本来就不该是对立的，恰恰相反，在常人并没有什么感觉的事情上面，能体会到持续的愉悦，才容易做出不一般的成绩。我想，不论是写作还是跑步，村上应该都体验到了极强的心流。</p><p>心流是积极心理学的创始人之一，希斯赞特米哈伊提出的概念，它是指我们在做某些事情时，那种全神贯注、投入忘我的状态，甚至感觉不到时间的存在，而完成之后会有一种充满能量并且非常满足的感受。在做那些自己喜欢、擅长、有挑战的事情时，就容易体验到心流，比如写作、演奏乐器、玩游戏、运动等等。</p><p>所以，并不是所有的愉悦都值得追求。现在我常常会<strong>用一个标准来过滤兴趣，那就是看这件事情能否容易让我进入心流状态。</strong></p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.037.jpeg" alt=""></p><p>想要兼顾愉悦和成就，最简单有效的做法就是在心流中形成作品——不论是一篇文章，一个程序，还是一件物品。</p><p>//</p><p>以上就是我对兴趣多动症三个主要矛盾的自救策略。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.038.jpeg" alt=""></p><p><strong>深度和广度的矛盾，可以用主题来整合。探索和应用的矛盾，可以用兴趣周期来拆分。愉悦和成就的矛盾，可以用心流换作品，皆大欢喜。</strong></p><p>兴趣多动症是一种频发症状，这也是我给自己的三颗速效救心丸。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.039.jpeg" alt=""></p><p>在这些年的自救过程中，我曾经焦虑于自己的不专注，期望自己变成在兴趣上很专一的人。但是都失败了。因为那不是我。一个人最鲜明的特质，往往就是最大的缺点，也是最大的优点。<strong>找出那些自己能够以苦为乐的事情，不断地觉察、顺应、引导和锻炼天性，把它培养成优势，是我们每一个人真正的人生课题。</strong></p><p>所以我的多动症还在继续。</p><p>你看，因为想给这次演讲做一个小片头，我又新开了一个坑：学做 3D 动画。我跟着教程做了一个四处张望的多动的潜水艇。</p><p><img src="http://img.viz.mobi/HHD-TEDxWumaStreet.040.jpeg" alt=""></p><p>做完以后，我发现它更适合做片尾，因为这是我的第一个练习作品，前面有一个大坑等着我来填。</p><p>如果你跟我一样，曾经被兴趣太多而困扰，不妨试着善待自己本性，把天性塑造成独特的优势。</p><p>每个人都可以、并且应该成为自己的伯乐，为世界贡献一人份的多样性。</p><hr><p><img src="http://img.viz.mobi/TEDxWumaStreet-thanks.jpeg" alt=""></p><p>你也是兴趣多动症患者吗？欢迎在留言区吐槽和支招 ~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/TEDxWumaStreet.jpg&quot; alt=&quot;TEDxWumaStreet&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;11 月 3 日，一场以「变」为主题的思想大会 TEDxWumaStreet 在温州开讲。12 位来自学术界、互联网、新闻界、文化产业、地产行业、设计领域的讲者，跨越山川湖海，共赴这场知识盛宴。 &lt;/p&gt;
&lt;p&gt;尽管行业不同、背景各异，但他们都是自身领域中的思考者和实践者，都在用思想和行动 Remake 人生，讲述精彩故事。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/TEDxWumaStreetSpeakers1.jpg&quot; alt=&quot;TEDxWumaStreetSpeakers1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/TEDxWumaStreetSpeakers2.jpg&quot; alt=&quot;TEDxWumaStreetSpeakers2&quot;&gt;&lt;/p&gt;
&lt;p&gt;00 有幸作为本年度 TedxWumaStreet 的受邀演讲者，以自己所经历的兴趣和职业之「变」为主题，分享了个人的 Remake 故事。&lt;/p&gt;
&lt;p&gt;以下是演讲全文，也许你也能感受到这个颇受关注的议题的共鸣，欢迎参与讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="HackYourself" scheme="http://uegeek.com/categories/HackYourself/"/>
    
    
      <category term="TED" scheme="http://uegeek.com/tags/TED/"/>
    
      <category term="Speech" scheme="http://uegeek.com/tags/Speech/"/>
    
      <category term="演讲" scheme="http://uegeek.com/tags/%E6%BC%94%E8%AE%B2/"/>
    
      <category term="兴趣" scheme="http://uegeek.com/tags/%E5%85%B4%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作05-Tessellation</title>
    <link href="http://uegeek.com/181107-generative-art-creativity-05.html"/>
    <id>http://uegeek.com/181107-generative-art-creativity-05.html</id>
    <published>2018-11-07T13:13:18.000Z</published>
    <updated>2018-11-07T13:27:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></li><li><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></li><li><a href="https://www.uegeek.com/181021-generative-art-creativity-03.html" target="_blank" rel="noopener">生成式艺术和算法创作03-混沌和分形</a></li><li><a href="https://www.uegeek.com/181023-generative-art-creativity-04.html" target="_blank" rel="noopener">生成式艺术和算法创作04-规则系统</a></li></ul><p>Tessellation（密铺/镶嵌/平面填充）或称细分曲面（subdivision surface），是指用一些较小的表面填满（tiling）一个较大的表面而不留任何空隙。在数学上，Tessellation 可以推广到更高的维度，称为空间填充。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f1/Leeuwarden_-_Tegeltableau_Escher.jpg/580px-Leeuwarden_-_Tegeltableau_Escher.jpg" alt=""></p><p>A wall sculpture in <a href="https://www.wikiwand.com/en/Leeuwarden" target="_blank" rel="noopener">Leeuwarden</a> celebrating the artistic tessellations of <a href="https://www.wikiwand.com/en/M._C._Escher" target="_blank" rel="noopener">M. C. Escher</a></p><p>在几何学中，两块相邻 tiles 的边界叫做 edge，三个或更多 tiles 的交点叫做 vertex。平面密铺分为规则和不规则两种，规则镶嵌即重复组合一种或多种不同的图形，具有周期性的重复模式。由正多边形组成的可以分为正镶嵌、半正镶嵌（Demiregular Tessellation）和不均匀半正镶嵌和复合多边形镶嵌等种类。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/03/Academ_Periodic_tiling_by_hexagons_and_other_regular_polygons.svg/240px-Academ_Periodic_tiling_by_hexagons_and_other_regular_polygons.svg.png" alt=""></p><p>通过两个或多个凸规则多边形对平面进行细分，使得相同顺序的相同多边形围绕每个多边形顶点称为半规则 Tessellation，或者有时称为阿基米德曲面细分：</p><p><img src="http://mathworld.wolfram.com/images/eps-gif/SemiregularTessellations_700.gif" alt=""></p><p>有 14 个单向 Tessellation 是三个常规和八个半规则镶嵌的有序组合：</p><p><img src="http://mathworld.wolfram.com/images/eps-gif/DemiregularTessellations_600.gif" alt=""></p><p>有规律的填充形成的图案，可分为 17 组。你没有看错，是总共只有 17 组，详细的介绍请见 <a href="https://www.wikiwand.com/en/Wallpaper_group" target="_blank" rel="noopener">Wallpaper group</a>，感觉有必要单开一篇来专门研究。</p><p><img src="http://img.viz.mobi/Overview%20of%20wallpaper%20groups.png" alt=""></p><p>缺乏重复图案的密铺称为非周期平铺（Non-periodic/Aperiodic）。非周期平铺使用一些较小的表面来填满一个较大的表面而不留任何空隙，但由于每一片的形状皆不相同，以致无法形成重复图案。</p><p>另外，也存在非欧几里得空间的密铺，如正七边形镶嵌、七阶三角形镶嵌等。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/H2_tiling_237-4.png/240px-H2_tiling_237-4.png" alt=""></p><p>在三维成像中也会使用 Tessellation 快速生成 3D 成像的小三角形。可以使用 GPU 通过 Programmable Tessellator 实现细分曲面，使得渲染对象的表面和边缘更平滑，物件呈现更为精细。</p><p>（写到这里只有一个感受：需要完全重修几何学和计算机图形学……）</p><p><img src="http://tessellations.org/tgp-seth/angry-birds-tessellation.jpg" alt=""></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Tessellation" target="_blank" rel="noopener">Tessellation - Wikiwand</a></li><li><a href="http://mathworld.wolfram.com/Tessellation.html" target="_blank" rel="noopener">Tessellation – from Wolfram MathWorld</a></li><li><a href="https://www.mathsisfun.com/geometry/tessellation.html" target="_blank" rel="noopener">Tessellation</a></li><li><a href="https://www.wikiwand.com/en/Wallpaper_group" target="_blank" rel="noopener">Wallpaper group - Wikiwand</a></li></ul><p>二次搬运 Wolfram 的 Reference：</p><ul><li>Ball, W. W. R. and Coxeter, H. S. M. <em>Mathematical Recreations and Essays, 13th ed.</em> New York: Dover, pp. 105-107, 1987.</li><li>Bhushan, A.; Kay, K.; and Williams, E. “Totally Tessellated.” <a href="http://library.thinkquest.org/16661/" target="_blank" rel="noopener">http://library.thinkquest.org/16661/</a>.</li><li>Britton, J. <em>Symmetry and Tessellations: Investigating Patterns.</em> Englewood Cliffs, NJ: Prentice-Hall, 1999.</li><li>Critchlow, K. <em>Order in Space: A Design Source Book.</em> New York: Viking Press, 1970.</li><li>Cundy, H. and Rollett, A. <em>Mathematical Models, 3rd ed.</em> Stradbroke, England: Tarquin Pub., pp. 60-63, 1989.</li><li>Gardner, M. <em>Martin Gardner’s New Mathematical Diversions from Scientific American.</em> New York: Simon and Schuster, pp. 201-203, 1966.</li><li>Gardner, M. “Tilings with Convex Polygons.” Ch. 13 in <em>Time Travel and Other Mathematical Bewilderments.</em> New York: W. H. Freeman, pp. 162-176, 1988.</li><li>Ghyka, M. <em>The Geometry of Art and Life.</em> New York: Dover, 1977.</li><li>Kraitchik, M. “Mosaics.” §8.2 in <em>Mathematical Recreations.</em> New York: W. W. Norton, pp. 199-207, 1942.</li><li>Lines, L. <em>Solid Geometry, with Chapters on Space-Lattices, Sphere-Packs, and Crystals.</em> New York: Dover, pp. 199 and 204-207 1965.</li><li>Pappas, T. “Tessellations.” <em>The Joy of Mathematics.</em> San Carlos, CA: Wide World Publ./Tetra, pp. 120-122, 1989.</li><li>Peterson, I. <em>The Mathematical Tourist: Snapshots of Modern Mathematics.</em> New York: W. H. Freeman, p. 75, 1988.</li><li>Radin, C. <em>Miles of Tiles.</em> Providence, RI: Amer. Math. Soc., 1999.</li><li>Rawles, B. <em>Sacred Geometry Design Sourcebook: Universal Dimensional Patterns.</em> Nevada City, CA: Elysian Pub., 1997.</li><li>Steinhaus, H. <em>Mathematical Snapshots, 3rd ed.</em> New York: Dover, pp. 75-76 and 78-82, 1999.</li><li>Vichera, M. “Archimedean Polyhedra.” <a href="http://www.vicher.cz/puzzle/telesa/telesa.htm" target="_blank" rel="noopener">http://www.vicher.cz/puzzle/telesa/telesa.htm</a>.</li><li>Walsh, T. R. S. “Characterizing the Vertex Neighbourhoods of Semi-Regular Polyhedra.” <em>Geometriae Dedicata</em> <strong>1</strong>, 117-123, 1972.</li><li>Weisstein, E. W. “Books about Tilings.” <a href="http://www.ericweisstein.com/encyclopedias/books/Tilings.html" target="_blank" rel="noopener">http://www.ericweisstein.com/encyclopedias/books/Tilings.html</a>.</li><li>Wells, D. <em>The Penguin Dictionary of Curious and Interesting Geometry.</em> London: Penguin, pp. 121, 213, and 226-227, 1991.</li><li>Williams, R. <em>The Geometrical Foundation of Natural Structure: A Source Book of Design.</em> New York: Dover, pp. 35-43, 1979.</li><li>Woo, M.; Neider, J.; Davis, T.; and Shreiner, D. Ch. 11 in <em>OpenGL 1.2 Programming Guide, 3rd ed.: The Official Guide to Learning OpenGL, Version 1.2.</em> Reading, MA: Addison-Wesley, 1999.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="Tessellation" scheme="http://uegeek.com/tags/Tessellation/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作04-规则系统</title>
    <link href="http://uegeek.com/181023-generative-art-creativity-04.html"/>
    <id>http://uegeek.com/181023-generative-art-creativity-04.html</id>
    <published>2018-10-23T11:32:35.000Z</published>
    <updated>2018-10-23T11:36:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></li><li><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></li><li><a href="https://www.uegeek.com/181021-generative-art-creativity-03.html" target="_blank" rel="noopener">生成式艺术和算法创作03-混沌和分形</a></li></ul><h2 id="规则系统"><a href="#规则系统" class="headerlink" title="规则系统"></a>规则系统</h2><blockquote><p>In computer science, rule-based systems are used as a way to store and manipulate knowledge to interpret information in a useful way. –Wiki</p></blockquote><p>规则系统（rule-based systems）的类型：</p><ul><li>生成语法和乔姆斯基等级（乔姆斯基在20世纪50年代提出）</li><li>形式逻辑系统和逻辑程序：推理规则，定理求解程序，论证系统，案例推理系统</li><li>专家系统：将特定领域的专业知识，编码在可以执行演绎和归纳的框架中</li><li>跃迁过程网络（Transition-based networks）：有限状态自动机（finite state automata）和扩展随机系统（extension stochastic systems）如马尔可夫模型，马尔可夫链，以及隐马尔可夫模型</li></ul><p><img src="https://cdn-ed.haymarketbooks.org/images/000001/149/Noam_Chomsky_(c" alt="">_Don_Usner-f_large-863c2ffef0e17c5b6fa999586cc0419d.jpg)</p><p>乔姆斯基（C.Chomsky）最初从产生语言的角度研究语言；他将语言 L 形式地定义为由一个字母表中的字母 ∑ 组成的一些串的集合 <img src="https://www.zhihu.com/equation?tex=%5Cforall+L%2C+%5Cexists+%5CSigma%2C+L%5Csubseteq+%5CSigma%5E%2A" alt="\forall L, \exists \Sigma, L\subseteq \Sigma^*"> ，可以在字母表上按照一定的规则定义一个方法，该文法产生的所有句子组成的集合，就是该文法产生的语言。形式语言是模拟这些语言的一类数学语言，它采用数学符号，按照严格的语法规则构成。</p><p>那么，到底什么是规则呢？</p><blockquote><p>α→β</p></blockquote><p>α 和 β 是由终结符（terminal symbol 如名词、动词等）或非终结符（如句子、动词短语、名词短语等）组成的表达式。</p><h2 id="生成文法"><a href="#生成文法" class="headerlink" title="生成文法"></a>生成文法</h2><p>生成文法（generative grammar）尝试给出一套规则，能正确的预测在一种语言中怎样的词汇组合能成为正确的句子，这些规则通常也能预测句子中的构词法。生成文法可以借助<a href="https://www.wikiwand.com/en/Chomsky_hierarchy" target="_blank" rel="noopener">乔姆斯基等级</a>来描述和比较。</p><p>文法 G 是一个四元组：G =（V, T, P, S）</p><ul><li>V：变量/非终结符号的非空有穷集；</li><li>T：终结符的非空有穷集，V∩T=Ø；</li><li>P：生成式的非空有穷集合；</li><li>S：开始符号，S 是 V 中的元素。</li></ul><p>P 生成式的基本形式是 α→β，这里 α 和 β 都是（V∪T）中的元素，即它们都是由变元和终结符组成的符号串，但要求 α 至少含有一个非终结符；在形式文法定义中 P 至关重要，它决定了语言是如何构造出来的。</p><p>根据 P 中生成式 α→β 的特点，可以将形式文法及其产生的形式语言分类，构成形式语言谱系，对应四种自动机：</p><ul><li><p>0 型文法，又称为短语文法：对生成式 α→β 不作特殊限制，α 和 β 可以是任意的文法符号串，当然 α 不能是空字符串；0 型文法是形式语言谱系中最大的文法类，是图灵机所识别的语言类，即递归可枚举语言。</p></li><li><p>1 型文法，又称为上下文有关文法：要求生成式 α→β 满足 |α|≤|β|，即 β 要至少和 α 一样长；由 1 型文法产生的语言称为 1 型语言或上下文有关语言，是非确定型线性有界自动机所识别的语言类。</p></li><li><p>2 型文法，又称为上下文无关文法（context-free grammars ）：要求生成式 α→β 中的 α 必须是变元；由 2 型文法产生的语言称为 2 型语言或上下文无关语言，是由下推自动机所识别的语言类。</p></li><li><p>3 型文法，又称为正则文法，这种文法分为两种类型：生成式的形式必须是 A→ωB 或 A→ω，其中 A，B 都是变元，ω 是终结符串（可以是空串），这种特殊的正则文法称为右线性文法；第二类正则文法称为左线性文法，它要求生成式必须是 A→Bω，或 A→ω 的形式。由正则文法生成的语言称为正则语言，它是有穷自动机所识别的语言类。</p></li></ul><p>上述定义的 4 种语言类具有依次包含关系，即对于 i＝0，1，2，在不考虑空字符串时，i 型语言都真包含 i＋1 型语言。</p><p>通过这种语法推导出的句子可以用派生树描述。相邻的单词被组合成成分，可以进一步与其他单词或成分组合以创建分层树结构。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Basic_english_syntax_tree.svg/300px-Basic_english_syntax_tree.svg.png" alt=""></p><p>看着很晕吧？…… 我们还是来看一些艺术创作领域的例子吧！</p><p>法国诗人雷蒙·格诺 (Raymond Queneau) 是国际文学团体乌力波（Oulipo, Ouvroir de littérature potentielle, 潜在文学工场）的创始人，其会员中名气较大的有意大利作家卡尔维诺（Italo Calvino），法国作家乔治·佩雷克（Georges Perec），此外还有一些成员是和文学不搭边的数学家。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Ambigramme_Oulipo_%28bold_pencil%29.png/300px-Ambigramme_Oulipo_%28bold_pencil%29.png" alt=""></p><p>Raymond Queneau 的诗集「百万亿首诗」(Cent mille milliards de poèmes) 是一本不寻常的诗集：表面上看这本书是由 10 首十四行诗构成，10 首诗的同一行都押同一个韵，实际上它能排列组合成一百万亿首诗。首行诗句有 10 种选择，第二行诗句也有 10 种选择，十四行诗组合在一起也就得到了 10 的 14 次方首各不相同的诗了。</p><p>诗集的设计也很特别，每一行都被剪成纸条，读完第一首诗的第一行，然后把第二行的纸条折过去读第二首诗的第二行，以此类推……这便是一个语法生成系统了。</p><p><img src="http://www.greenchairpress.com/blog/wp-content/uploads/2014/08/queneau.png" alt=""></p><h2 id="自动机"><a href="#自动机" class="headerlink" title="自动机"></a>自动机</h2><p>最简单的来说，自动机（Automaton）就是具有离散输入输出的数学模型，接受一定的输入，执行一定的动作，产生一定的结果。</p><p>状态是一个标识，能区分自动机在不同时刻的状况。可以使用状态迁移描述整个工作过程。有限状态系统具有任意有限数目的内部状态。自动机的本质是，<strong>根据状态、输入和规则决定下一个状态，即</strong></p><blockquote><p>状态 ＋ 输入（激励）＋ 规则 → 状态迁移</p></blockquote><p>可能的状态、运行的规则都是事先确定的。一旦开始运行，就按照事先确定的规则工作，因此叫自动机。</p><p>根据结构不同，自动机又可分为：</p><ul><li>有限自动机，可以认为是由一个带有读头的有限控制器和一条写有字符的输入带组成；</li><li>下推自动机，可以看作是由一条输入带、一个有限控制器和一个下推栈组成；</li><li>基本图灵机，由一个具有读写头的有限控制器和一条无限带组成</li></ul><p>在这个系列的后续文章中，还会单独来讲讲元胞自动机。</p><h2 id="Transition-network"><a href="#Transition-network" class="headerlink" title="Transition network"></a>Transition network</h2><p>Transition Networks 是一系列有限状态自动机。</p><p>如果用有向图表示，节点表示状态，边缘表示转换过程。每一个自动机表示一个非终结符；每一个转换过程产生一个非终结符或终结符。</p><p><img src="http://img.viz.mobi/eg-transition-network.png" style="zoom:50%"></p><p>Augmented transition networks (ATN) 是一种形式语言操作化定义的图论结构。ATN 建立在使用有限状态机来解析句子的基础上，它理论上可以分析任何句子的结构，无论多么复杂。ATN 的一个优点是延迟决策——当模糊性出现时，许多语法会在对句子的了解还不够时进行猜测。而 ATN 使用递归来推迟决定，直到对句子了解得更多。</p><p>算法作曲的先驱 David Cope 创作的 EMI 是著名的和开创新的系统。EMI 使用了 ATN，由系统分析和分割给定的语料库，然后重新组合元素。<br><img src="/Users/kidult00/Downloads/Courses/Kadenze/generative-art-and-computational-creativity-i/3-rule-based-systems-grammars-and-markov-chains/David%20Cope%20EMI%20ATN.png" alt="David Cope EMI ATN"></p><p>在这里，终结符是各种音乐片段，非终结符元素则捕捉各种层级的片段结构。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Rule-based_system" target="_blank" rel="noopener">Rule-based system - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Generative_grammar" target="_blank" rel="noopener">Generative grammar - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Context-free_grammar" target="_blank" rel="noopener">Context-free grammar - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Oulipo" target="_blank" rel="noopener">Oulipo - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Automaton" target="_blank" rel="noopener">Automaton - Wikiwand</a></li><li><a href="https://book.douban.com/subject/24089566/" target="_blank" rel="noopener">乌力波（2） (豆瓣)</a></li><li><a href="https://zhuanlan.zhihu.com/p/28624160" target="_blank" rel="noopener">形式语言与自动机</a></li><li><a href="http://artsites.ucsc.edu/faculty/cope/experiments.htm" target="_blank" rel="noopener">EMI</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="规则系统" scheme="http://uegeek.com/tags/%E8%A7%84%E5%88%99%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作03-混沌和分形</title>
    <link href="http://uegeek.com/181021-generative-art-creativity-03.html"/>
    <id>http://uegeek.com/181021-generative-art-creativity-03.html</id>
    <published>2018-10-21T12:11:30.000Z</published>
    <updated>2018-10-21T12:20:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><p><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></p><p><a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">生成式艺术和算法创作02-随机和噪声</a></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Lorenz_attractor_yb.svg/800px-Lorenz_attractor_yb.svg.png?1538707261695" style="zoom:50%"></p><h2 id="动态系统"><a href="#动态系统" class="headerlink" title="动态系统"></a>动态系统</h2><p>动态系统（dynamical system）是数学上的一个概念，是一种固定的规则，它描述一个给定空间中所有点随着时间变化的情况，例如运动的钟摆、弹跳的球、管道中水的流动等。</p><p>动态系统的行为可以分为四类：</p><ul><li>Fixed point behavior (equilibrium)：固定（平衡）行为</li><li>Limit cycle or periodic behavior：循环或周期行为</li><li>Quasi-periodic behavior：准周期行为</li><li>Chaotic behavior：混沌行为</li></ul><p><strong>虽然动态系统是可以确定的，但是一旦输入发生微小改变，结果都会变得难以预测。混沌系统短期、局部可预测，长期、全局不可预测的特点，让它成为算法创作中常用的手段。</strong></p><p><img src="http://sprott.physics.wisc.edu/pubs/354fig01.gif" alt=""></p><p>via Generalization of the simplest autonomous chaotic system</p><p>单峰映象（logistic map）是一个二次的多项式映射，是由简单非线性方程式产生<a href="https://www.wikiwand.com/zh/%E6%B7%B7%E6%B2%8C%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">混沌</a>现象的经典范例。</p><p>这种映射因生物学家 Robert May 在 1976 年发表的一篇论文而著名。公式为 $$x_{n+1}=rx_n(1-x_n)$$。对于任一个 r 值，最多只有一个稳定的极限环，若稳定极限环存在，几乎所有的点最后都会趋近极限。这些情况可用分枝图表示，分枝图中的横轴是 r 的数值，纵轴中显示大部份初值下稳态可能的 x 值，若数值在 2 个值中震荡，分枝图上对应的数值就会有 2 个点。若某 r 值已无法明确有几个对应的点，系统可能已经处于混沌状态。</p><p>分枝图有自相似的特性。若将分枝图中 r=3.82 的部份展开，只取三个分支中的一个，图形会好像是原分枝图缩放及扭曲后的结果。所有非混沌的参数 r 都有此一特性。可以看出混沌和分形的关系。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/7/7d/LogisticMap_BifurcationDiagram.png" alt=""></p><p>吸引子（attractor）是微积分和系统科学论中的一个概念。一个系统有朝某个稳态发展的趋势，这个稳态就叫做吸引子。</p><p>吸引子分为平庸吸引子和奇异吸引子。例如一个钟摆系统有一个平庸吸引子，这个吸引子使钟摆系统向停止晃动的稳态发展。平庸吸引子有不动点（平衡）、极限环（周期运动）和整数维环面（概周期运动）三种模式。不属于平庸的吸引子的都称为奇异吸引子，它表现了混沌系统中非周期性，无序的系统状态，例如天气系统。目前吸引子在学术上还没有完善的定义，奇异吸引子对于<a href="https://www.wikiwand.com/zh/%E6%B7%B7%E6%B2%8C%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">混沌系统</a>的研究意义重大。</p><p>混沌理论的思想也从上世纪后半叶开始，逐渐渗入到音乐和作曲领域。</p><p>1960 年 George Brecht 在滴水事件（drip event）中，使不同来源的水，滴进所有空的容器。这个作品可以被视为音乐、剧场、或者是动态雕塑。</p><p><img src="https://www.moma.org/media/W1siZiIsIjMwNDk2NSJdLFsicCIsImNvbnZlcnQiLCItcmVzaXplIDIwMDB4MjAwMFx1MDAzZSJdXQ.jpg?sha=74b38f4f98552501" alt=""></p><p>Brecht 的极简主义艺术活动是神秘费解、令人困惑的，这些作品及其配乐为观众设计成仅在想象的范围内可被解读与激活。滴水音乐（drip music）由此形成，指可由单个或多个表演者演出单一滴水水源与一个空的容器，通过设置使水滴入容器中。Drip music 很快就成为激浪派（fluxus）的标志，flux 一词本身不仅指持续的运动与改变，也指流体与流动，或更精确的是一个流体的流动速度。</p><p>80 年代，混沌理论开始被应用在作曲中。它适用于音高、持续时间、动态范围和编排。它们很容易产生重复，以及周期性/准周期性模型变化，或者在混沌模式下产生更多不可预测的行为，而重复、变化、convergence 和 divergence 是音乐作曲里的关键要素。</p><h2 id="分形"><a href="#分形" class="headerlink" title="分形"></a>分形</h2><p>分形是一个可以分成数个部分的几何形状，且每一部分都（至少近似地）是整体缩小后的形狀，即具有<a href="https://www.wikiwand.com/zh/%E8%87%AA%E7%9B%B8%E4%BC%BC" target="_blank" rel="noopener">自相似</a>的性质。分形也被称为扩展对称或展开对称。如果在每次放大后，形状的重复是完全相同的，被称为自相似。作为一个数学函数，分形通常是处处不可微的。无穷分形曲线可以理解为一条一维的曲线在空间中绕行。</p><blockquote><p>Fractals are mathematical dynamic systems represented by iterative equations that develop curves and geometrical shapes that have property of self-similarity. </p></blockquote><p>Sierpinski 三角是典型的自相似分形图形。1915 年由波兰数学家 Wacław Franciszek Sierpiński 提出。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a8/Sierpinski_triangle_%28blue%29.jpg" alt=""></p><p>算法：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/05/Sierpinski_triangle_evolution.svg/1024px-Sierpinski_triangle_evolution.svg.png" alt=""></p><ol><li>取一个实心的三角形（多数使用等边三角形）</li><li>沿三边中点的连线，将它分成四个小三角形</li><li>去掉中间的那一个小三角形</li><li>对其余三个小三角形重复第 1 步</li></ol><p>Sierpinski 三角可由分型树产生：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a9/Fractal_tree.gif" alt=""></p><p>分形算法已经被广泛用于生成式艺术创作中。</p><p>Bogdan Soban 是斯洛文尼亚的信息学专家和软件开发者，退休后作为自由艺术家从事创作。他从 1999 年开始接触生成式艺术，开始编写基于算法的生成式艺术软件用于创作。</p><p><img src="http://www.soban-art.com/images/naslovnica.jpg" alt=""></p><p>Paul DeCelle 用 Frederik Slijkerman 开发的 <a href="http://www.ultrafractal.com/" target="_blank" rel="noopener">Ultra Fractal</a> 创作了一些列作品：</p><p><img src="http://www.submit.manscostyle.com/submit/130_Image9.jpg" alt=""></p><p><img src="https://www.fractalus.com/paul/20071022-kesius.jpg" alt=""></p><p>Etienne Saint Amant 是来自加拿大魁北克省舍布鲁克的艺术家。他专注于用数学语言设计和描述的大幅艺术品，致力于概念研究和当代艺术创作。</p><p><img src="https://t00.deviantart.net/AIQ7rP3wX0CLZ0sC29rhgA1QBZE=/fit-in/700x350/filters:fixed_height(100,100" alt="">:origin()/pre00/ae50/th/pre/i/2005/136/1/4/rakis_by_etiennesaintamant.jpg)</p><p><img src="https://chaoscopia.com/artworks/m20180926-13.jpg" alt=""></p><p>一些分形艺术的软件：</p><ul><li><a href="https://www.ultrafractal.com/" target="_blank" rel="noopener">Ultra Fractal: Advanced Fractal Software for Windows and macOS</a></li><li><a href="http://fract.al/" target="_blank" rel="noopener">Frax - Immerse, Create, Inspire</a> </li><li><a href="https://mandelbulber.com/" target="_blank" rel="noopener">Laravel</a></li><li><a href="http://www.fractal-explorer.com/" target="_blank" rel="noopener">Fractal Explorer</a></li><li><a href="http://www.apophysis.org/" target="_blank" rel="noopener">Apophysis.org</a></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://www.wikiwand.com/en/Dynamical_system" target="_blank" rel="noopener">Dynamical system - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Attractor" target="_blank" rel="noopener">Attractor - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Logistic_map" target="_blank" rel="noopener">Logistic map - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh/%E5%88%86%E5%BD%A2" target="_blank" rel="noopener">分形 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Sierpinski_triangle" target="_blank" rel="noopener">Sierpinski triangle - Wikiwand</a></li><li><a href="http://sprott.physics.wisc.edu/pubs/paper354.htm" target="_blank" rel="noopener">Generalization of the Simplest Autonomous Chaotic System</a></li><li><a href="https://www.moma.org/collection/works/127310?artist_id=756&amp;locale=zh&amp;page=1&amp;sov_referrer=artist" target="_blank" rel="noopener">Poul Hansen, George Brecht, Dick Higgins. George Brecht’s Drip Music, performed by Dick Higgins during Fluxus/Musik og Anti-Musik/det Instrumentale Teater, Nikolai Kirke, Copenhagen, November 23, 1962. 1962 | MoMA</a></li><li><a href="http://www.soban-art.com/index-ang.asp" target="_blank" rel="noopener">Generative Art - generated, artificial, random, software</a></li><li><a href="https://www.fractalus.com/paul/" target="_blank" rel="noopener">Fractal Art by Paul DeCelle</a></li><li><a href="https://chaoscopia.com/nouveautes_en.html" target="_blank" rel="noopener">chaoscopia - news</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="混沌" scheme="http://uegeek.com/tags/%E6%B7%B7%E6%B2%8C/"/>
    
      <category term="分形" scheme="http://uegeek.com/tags/%E5%88%86%E5%BD%A2/"/>
    
      <category term="Chaotic" scheme="http://uegeek.com/tags/Chaotic/"/>
    
      <category term="Fractal" scheme="http://uegeek.com/tags/Fractal/"/>
    
  </entry>
  
  <entry>
    <title>算法创作实战02 - 用 MaxMSP 生成随机颜色</title>
    <link href="http://uegeek.com/181021-computational-creativity-in-maxmsp-02.html"/>
    <id>http://uegeek.com/181021-computational-creativity-in-maxmsp-02.html</id>
    <published>2018-10-21T11:13:58.000Z</published>
    <updated>2018-10-21T11:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-title1.jpg" alt=""></p><a id="more"></a><p>在「生成式艺术和算法创作」系列第二篇中，00 <a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">介绍了随机和噪声在算法创作中的应用</a>。上一篇我们<a href="https://www.uegeek.com/181017-computational-creativity-in-maxmsp-01.html" target="_blank" rel="noopener">用 Max/MSP 做了一个随机生成星座描述的小应用</a>，切身实践和感受了巴纳姆效应。</p><p>今天我们一起来用 Max/MSP 实现简单的随机颜色生成器，加深对 Max/MSP 中 <code>random</code> 对象的了解。</p><blockquote><p>名称：Random Color</p><p>主要使用的对象：random, send, receive, uzi, pack, jit.matrix, jit.pwindow</p><p>难度系数：★☆☆☆☆</p></blockquote><p>这个程序叫 Random Color，可以指定行（y）和列（x）的数量，然后用随机颜色填充，可以手动生成新的图像，也可以自动连续生成。生成的图像可以导出成图片。最后的成果是这样：</p><p><img src="http://img.viz.mobi/RandomColor.png" alt=""></p><p>首先来拆解需要实现的功能：</p><ul><li>手动生成或者自动连续生成</li><li>指定图像的尺寸(dim)</li><li>生成随机颜色</li><li>自动填充每一个单元格</li><li>显示图像</li><li>导出图片</li></ul><p>开始动手前，请复习 Max/MSP 文档中 random, send, receive, uzi, pack, jit.matrix, jit.pwindow 等对象的说明。</p><p>准备就绪后，我们先来看前两步如何实现：</p><p><img src="http://img.viz.mobi/RandomColorPatch-1.png" alt=""></p><p><strong>1.手动生成或者自动连续生成</strong></p><p>用 <code>button</code> 触发生成事件，前面加上 <code>metro</code> 对象并指定时间间隔就可以自动连续触发生成事件。</p><p><strong>2.指定图像的尺寸(dim)</strong></p><p>设置两个整数数字框，可以输入水平和垂直维度的数量，来指定图像的尺寸。</p><p>生成事件的 bang、x 和 y 的数值，都通过 <code>send</code>(简写为 s) 对象传递到后面的步骤。</p><p>接下来是关键的部分，用随机颜色自动填充每一个单元格：</p><p><img src="http://img.viz.mobi/RandomColorPatch-2.png" alt=""></p><p><strong>3.生成随机颜色</strong></p><p>用 3 个<code>random</code> 对象分别生成 R G B 三个颜色值，然后用 <code>pack</code> 对象打包起来。因为最后需要用 <code>jit.pwindow</code> 显示图像，它需要接收 ARGB 颜色，所以我们还需要用 <code>setcell</code> 消息指定需要填充的单元格，并且传递 255 作为 ARGB 的 Alpha 值。于是，pack 对象的参数需要写成：<code>pack setcell 0 0 val 255 0 0 0</code>。其中，前面两个 0  会传入之前通过数字框输入的 x 和 y 的垂直和水平 dim 值，后面 3 个 0 会传入由 <code>random</code> 对象生成的 GRB 值。</p><p><strong>4.自动填充每一个单元格</strong></p><p>编程中经常使用 for 循环来实现矩阵的填充，在 MaxMSP 里常用 <code>uzi</code> 对象来实现简单的循环效果。（当然，如果是 modern 的矩阵处理和运算，会用 jit 提供的丰富的矩阵功能；这里我们怀旧一下用 uzi）<code>uzi</code> 的作用是连续发出 bang，左入口接收触发命令，右入口接收连续 bang 的数量；左出口输出 bang，中出口输出完成所有 bang 后的消息，右出口输出当前是第几个 bang。</p><p>首先接收 y 维度的值，用 1 个 <code>uzi</code> 作为外层循环。因为 <code>uzi</code> 对象从 1 开始计数，所以需要减去 1 再传给 <code>setcell</code>，因为矩阵单元格从 0  开始计数。然后接收 x 维度的值，作为内层循环（同样要减去 1）。</p><p><code>uzi</code> 和 <code>random</code> 生成的矩阵单元格位置和颜色都传给 <code>pack</code> 对象打包。</p><p>最后是显示和导出图像：</p><p><img src="http://img.viz.mobi/RandomColorPatch-3.png" alt=""></p><p><strong>5.显示图像</strong></p><p>使用 <code>jit.matrix</code> 存储并显示矩阵，更多 <code>jit.matrix</code> 的用法请参考 <a href="https://www.uegeek.com/tags/Max-MSP/" target="_blank" rel="noopener">00  翻译的 Max/MSP/Jitter 官方教程系列</a>。</p><p>指定矩阵为 4 个平面（plane），用 <code>receive</code> 对象（简写为 r）接受 x 和 y 维度的值。为了实时响应维度修改的操作，这里用 <code>pak</code> 对象而不是 <code>pack</code> 对象。<code>pak</code> 对象响应任一一个输入的变化，而 <code>pack</code> 对象需要由 bang 触发何时响应。</p><p>另外，使用一直开启的 <code>qmetro</code> 对象（@active 属性为 1）来监控矩阵的变化，以便随时更新，将矩阵值通过 <code>send</code> 对象发送给 <code>jit.pwindow</code> 中显示。</p><p><strong>6.导出图片</strong></p><p>用 <code>exportimage</code> 消息可以触发 <code>jit.matrix</code> 导出图像保存。因为矩阵的初始尺寸是 10x10，所以最后用了一个 <code>jit.matrix 4 char 400 400</code> 将矩阵扩大为 400x400 的尺寸，这样导出的图像大小就是 400x400 像素。</p><p><img src="http://img.viz.mobi/randomColorExport.png" alt=""></p><p>完整的 patch 如下：</p><p><img src="http://img.viz.mobi/RandomColorPatch.png" alt=""></p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-title1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="随机" scheme="http://uegeek.com/tags/%E9%9A%8F%E6%9C%BA/"/>
    
      <category term="MaxMSP" scheme="http://uegeek.com/tags/MaxMSP/"/>
    
  </entry>
  
  <entry>
    <title>算法创作实战01 - 巴纳姆效应之随机星座实验</title>
    <link href="http://uegeek.com/181017-computational-creativity-in-maxmsp-01.html"/>
    <id>http://uegeek.com/181017-computational-creativity-in-maxmsp-01.html</id>
    <published>2018-10-17T10:22:16.000Z</published>
    <updated>2018-10-17T11:37:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-title1.jpg" alt=""></p><a id="more"></a><p>在「生成式艺术和算法创作」系列第二篇中，00 <a href="https://www.uegeek.com/181014-generative-art-creativity-02.html" target="_blank" rel="noopener">介绍了随机和噪声在算法创作中的应用</a>。</p><p>今天我们一起来用 Max/MSP 实现一个半（hu）仙（shuo）算（ba）命（dao）小应用，加深对 Max/MSP 中 <code>random</code> 对象的了解，并且学习如何使用 <code>coll</code> 对象。</p><blockquote><p>名称：麦克斯半仙儿（又名 Random Bullshit）</p><p>主要使用的对象：random, coll, route, jit.cellblock, fpic</p><p>难度系数：★☆☆☆☆</p></blockquote><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><a href="https://www.wikiwand.com/zh-hans/%E5%B7%B4%E7%B4%8D%E5%A7%86%E6%95%88%E6%87%89" target="_blank" rel="noopener">巴纳姆效应（Barnum effect）</a>是 1948 年由心理学家伯特伦·福勒通过试验提出的一种心理学现象，以杂技师巴纳姆的名字命名。巴纳姆效应是一种心理现象，人们会对他们认为是为自己量身订做的一些人格描述，给予高度准确的评价，而这些描述往往十分模糊及普遍，以致能够放诸四海皆准适用于很多人身上。</p><p>据说巴纳姆的成功秘诀是：「永远要让每一个观众都感到自己若有所获」。意思如果要让每一个人都能感到对自己个性的描述是准确的，就要去提供一些放之四海而皆准的描述。看手相、算命、占星术及其他伪心理学经常利用这种效应，怎么说都能让你听着有点儿道理。于是有人将十二星座的描述随机排列，发现不同星座的描述基本上可以适用于其他星座。</p><p>所以今天我们来实践一下这个想法，看看程序随机给出的星座描述，有没有戳中你 🌝。</p><h2 id="任务拆解"><a href="#任务拆解" class="headerlink" title="任务拆解"></a>任务拆解</h2><p>这个程序叫麦克斯半仙儿，用户选择自己的星座后，程序给出描述。最后的成果是这样：</p><p><img src="http://img.viz.mobi/BarnumEffectDemo.gif" alt=""></p><p>首先来拆解需要干的事儿：</p><ul><li>收集十二星座的简短描述和图标</li><li>存储文本，方便随机调用</li><li>12 星座的选择控件</li><li>显示结果（包括加载默认值）</li></ul><p>开始动手前，请复习 Max/MSP 文档中 random, coll, route, jit.cellblock, fpic 等对象的说明。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>这个小程序的核心是用 <code>random</code> 对象随机显示 <code>coll</code> 对象中存储的内容。<code>coll</code> 即 collection，用来存储一个列表，列表中每一项都包含 key 和 value（中间用 ， 隔开），可以通过 key 获取对应的 value。value 可以是单个值，也可以是以空格分隔的多个值。</p><p>在 Max 中新建名字为 blah 的 <code>coll</code> 对象，双击（或者 cmd+点击）打开，填入我们在网上找到的十二星座描述内容，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0, 你大方、明朗，全身充滿活力……;</span><br><span class="line">1, 你不但好學、知識豐富，還很……;</span><br><span class="line">2, 嗯，你善於說服別人，還是個……;</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>十二个星座描述的索引是从 0~11，所以在 <code>coll</code> 前用一个 <code>random</code> 对象随机选取其中一个星座的描述，然后从 <code>coll</code> 的左出口输出。因为我们存储的是文本内容（symbol），所以需要用一个 <code>route</code> 对象读取 symbol 内容，并发送到显示区域。</p><p><img src="http://img.viz.mobi/BarnumEffect-coll.png" alt=""></p><p>如果不想每次双击打开 <code>coll</code> 查看，可以用 <code>refer 名字</code> 消息连接一个 <code>jit.cellblock</code> 查看 <code>coll</code> 里面的内容。</p><p>随机调用的内容准备就绪后，接下来是选择星座的界面：</p><p><img src="http://img.viz.mobi/BarnumEffect-ui.png" alt=""></p><p>用 <code>fpic</code> 显示星座图标，在上面覆盖一个 <code>button</code> 对象，将按钮背景设置为透明。然后将按钮连接到 <code>random</code> 对象，读取 <code>coll</code> 的内容。</p><p>因为想显示每次选择的星座名称，所以每个按钮连接了一个包含对应星座名称的 <code>message</code> ，点击按钮时可以触发显示在内容区域。其实用 <code>radio group</code> 对象能更好实现，但是它的 UI 不好自定义，就放弃了。</p><p>完整的 patch 如下：</p><p><img src="http://img.viz.mobi/BarnumEffectPatch.png" alt=""></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>程序做好以后，随机生成了几个描述，发到朋友圈，让大家猜这些描述原本对应的是什么星座。</p><p>结果是——没有全部猜对的，哈哈哈！应该给撰写星座描述的小编加🍗~</p><p>下一期实战见~</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-title1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="随机" scheme="http://uegeek.com/tags/%E9%9A%8F%E6%9C%BA/"/>
    
      <category term="巴纳姆效应" scheme="http://uegeek.com/tags/%E5%B7%B4%E7%BA%B3%E5%A7%86%E6%95%88%E5%BA%94/"/>
    
      <category term="星座" scheme="http://uegeek.com/tags/%E6%98%9F%E5%BA%A7/"/>
    
      <category term="MaxMSP" scheme="http://uegeek.com/tags/MaxMSP/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作02-随机和噪声</title>
    <link href="http://uegeek.com/181014-generative-art-creativity-02.html"/>
    <id>http://uegeek.com/181014-generative-art-creativity-02.html</id>
    <published>2018-10-14T15:02:20.000Z</published>
    <updated>2018-10-14T15:06:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><p><a href="https://www.uegeek.com/181009-generative-art-creativity-01.html" target="_blank" rel="noopener">生成式艺术和算法创作01-概述</a></p><p>利用随机性（Randomness）和噪声（Noise），可能是最古老、最简单、最常见的生成式艺术的方法。</p><p>艺术家用各种参数来定义一个变化空间，可以在一定范围内取值，随机选中的值影响被操控的元素，形成最终的作品。</p><p>随机性表示一定程度上的目的、动机、规则等可预测性的缺失。引入随机性可以带来多样、不可预测的结果，从而让作品更丰富而有活力。</p><h2 id="产生各种概率分布的随机数"><a href="#产生各种概率分布的随机数" class="headerlink" title="产生各种概率分布的随机数"></a>产生各种概率分布的随机数</h2><p>概率分布是随机变量的概率性质。比如，符合均匀分布的随机数，表示所有可能选项的出现概率是一样的。选择不同的概率分布，可以让随机数产生不同的结果。</p><p>常见的概率分布：</p><p><img src="http://blog.cloudera.com/wp-content/uploads/2015/12/distribution.png" alt=""></p><p><a href="http://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/" target="_blank" rel="noopener">http://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/</a></p><ul><li>Uniform distribution：均匀分布</li><li>Bernoulli distribution：伯努利分布，就是常见的 0-1 分布，即随机变量只取 0 或者 1，频率分别为 1−p 和 p</li><li>Binomial distribution：二项分布，例如在一连串 N/yes/no 中八次成功的概率。二项分布公式基于伯努利分布得到，因为每次实验都是独立的，因此每次实验都是一次伯努利实验</li><li>Hypergeometric distribution：超几何分布，常用来表示在 N 个物品中有指定商品 M 个，不放回抽取 n 个，抽中指定商品的个数</li><li>Poisson distribution：泊松分布，主要用来研究单位时间或单位空间内某事件的发生次数，事件的发生必须是相互独立的，比如单位时间内通过某一交通灯的车辆数</li></ul><p>具有相同分布函数的随机变量一定是同分布的，因此可以用分布函数来描述一个分布，但更常用的描述手段是<a href="https://www.wikiwand.com/zh-hans/%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">概率密度函数</a>（Probability Density Functions）。利用概率分布和密度函数，可以引导和交叉训练随机性，让某些部分发生概率更高，而另一些概率更低。</p><h2 id="噪声"><a href="#噪声" class="headerlink" title="噪声"></a>噪声</h2><blockquote><p>In <a href="https://www.wikiwand.com/en/Signal_processing" target="_blank" rel="noopener">signal processing</a>, <strong>white noise</strong> is a random <a href="https://www.wikiwand.com/en/Signal_(information_theory" target="_blank" rel="noopener">signal</a>) having equal intensity at different <a href="https://www.wikiwand.com/en/Frequencies" target="_blank" rel="noopener">frequencies</a>, giving it a constant <a href="https://www.wikiwand.com/en/Power_spectral_density" target="_blank" rel="noopener">power spectral density</a>. – Wiki</p></blockquote><p>我们经常会听到一个名词：白噪声。</p><p>它是什么意思呢？为什么噪声还有颜色呢？</p><p>白噪声是一种功率谱密度为常数的随机信号或随机过程。即信号在各个频段上的功率是一样的。</p><p>由于白光是由各种频率（颜色）的单色光混合而成，因而此信号的这种具有平坦功率谱的性质被称作是「白色的」，此信号也因此被称作白噪声。相对的，其他不具有这一性质的噪声信号被称为有色噪声。</p><p>需要注意，<strong>相关性和概率分布是不同的概念</strong>。白色仅意味着信号是不相关的，白噪声的定义除了要求均值为零，并没有对信号应当服从哪种概率分布作出任何假设。因此，如果某白噪声过程服从<a href="https://www.wikiwand.com/zh/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83" target="_blank" rel="noopener">高斯分布</a>，它就是「高斯白噪声」。类似的，还有泊松白噪声、柯西白噪声等。</p><p>噪声的颜色分类，来自于将频谱中的噪声谱密度函数，和频谱中的<a href="https://www.wikiwand.com/zh/%E5%85%89%E6%B3%A2" target="_blank" rel="noopener">光波</a>信号做形式上的类比，也就是说，如果一束光波在频域内具有和蓝噪声相同的谱密度图样，则这束光波看上去将呈现蓝色。</p><ul><li>White noise: 频率密度均匀分布</li><li>Brown noise (Red noise): 由布朗运动造成，又称为随机移动噪音（random walk noise）</li><li>Pink noise (F noise): <a href="https://www.wikiwand.com/zh/%E5%8A%9F%E7%8E%87%E8%B0%B1%E5%AF%86%E5%BA%A6" target="_blank" rel="noopener">功率谱密度</a>与频率成反比的频谱信号或过程。在粉红噪声中，每个倍频程中都有一个等量的噪声功率。在生成式艺术中很常用，因为它可以模拟自然现象中的随机性</li></ul><p><img src="http://img.viz.mobi/various%20colors%20of%20noise.png" alt=""></p><h3 id="Aleatoric-Music-机遇音乐"><a href="#Aleatoric-Music-机遇音乐" class="headerlink" title="Aleatoric Music 机遇音乐"></a>Aleatoric Music 机遇音乐</h3><blockquote><p>A process is said to be aleatoric … if its course is determined in general but depends on chance in detail. </p><p>—— Werner Meyer- Eppler, 1957</p></blockquote><p>机遇音乐是一种包含随机性元素的音乐创作。</p><p>在一首音乐作品中，作曲家在某些地方会让演奏者按自己的意愿，或使用一些系統来决定音乐的演奏，由于随机性不可能每次都得出相同的结果，所以乐曲每次的演奏版本都不完全相同。</p><p>Iannis Xenakis 开创了机遇音乐的一个子类：随机音乐（Stochastic music），即在音乐创作中或者在演奏中使用随机过程生成乐曲片段。</p><p>Xenakis 经常使用计算机来制作乐谱，例如包括 Morsima-Amorsima 和 Atrées 在内的 ST 系列。</p><p><img src="https://discourse-cdn-sjc2.com/standard17/uploads/critterandguitari/original/2X/a/aede09d8452c1b3d4273a4515dfa6c941c62e21e.jpg" alt=""></p><h3 id="Noise-music-噪声音乐"><a href="#Noise-music-噪声音乐" class="headerlink" title="Noise music 噪声音乐"></a>Noise music 噪声音乐</h3><p>Noise music 是音乐的一个子流派，研究声学噪声的概念并将其作为重要的声学材料。</p><blockquote><p>I believe that the use of noise to make music will continue and increase until we reach a music produced through the aid of electrical instruments which will make available for musical purposes any and all sounds that can be heard.</p><p>— John Cage, The Future of Music: Credo (1937)</p></blockquote><p>让我们来听听日本著名的噪音音乐人 Merzbow 的一首作品，感受一下什么是噪声音乐：</p><iframe width="100%" height="166" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/450625851&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true"></iframe><p><a href="https://soundcloud.com/merzbow/v2-1" target="_blank" rel="noopener">https://soundcloud.com/merzbow/v2-1</a></p><blockquote><p>噪音和音乐的定义因人而异，如果噪音是指让人不舒服的声音的话，流行音乐对我而言就是噪音。</p><p>——Merzbow</p></blockquote><p>在工业噪音、噪音摇滚、No wave 和 Harsh noise 之后，出现了大量的噪音音乐家，风格包括 Ambient、Microsound、Glitch 等，更强调微妙的脉冲式声响和敏感的听觉。</p><h2 id="Random-walk"><a href="#Random-walk" class="headerlink" title="Random walk"></a>Random walk</h2><p>Random walk 1905 年由皮尔逊首次提出，它是一种数学统计模型，由一连串轨迹组成，每一步根据概率随机选择。步长可以是固定也可以是动态的。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Random_Walk_example.svg/840px-Random_Walk_example.svg.png" style="zoom:50%"></p><p>一维 Random Walk</p><p>Brownian movement 是 Random walk 的特例（step 为 0）。所以上文提到的 Brown noise 也称为 Random walk noise。</p><p>随机漫步的算法虽然简单，但是经过多次迭代，可以产生丰富的随机效果，所以在生成式艺术中被广泛使用。</p><p>Chance and Order 是 Kenneth Martin 1971 使用随机漫步规则创作的一个系列。</p><blockquote><p>the points of intersection on a grid of squares are numbered and the numbers are written on small cards and picked at random… A line is made between each successive pair of numbers as they are picked out. </p><p>——Kenneth Martin</p></blockquote><p><img src="https://www.tate.org.uk/art/images/work/T/T01/T01847_10.jpg" style="zoom:50%"></p><p>Quantum cloud 是艺术家 Antony Gormley 1999 年完成的当代雕塑作品。它由一系列四面体单元构成，由 1.5 米长的钢制成。钢架部分用 Random walk 算法生成。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/1/1b/Quantum_Cloud_by_Antony_Gormley_in_March_2011_01.jpg" style="zoom:20%"></p><h2 id="Perlin-noise"><a href="#Perlin-noise" class="headerlink" title="Perlin noise"></a>Perlin noise</h2><p>Perlin noise 是由 Ken Perlin 发明的自然噪声生成算法，经常用来模拟自然界中的噪声现象、人体的随机运动、蚂蚁行进的线路等。还可以通过计算分形来模拟云朵，火焰等非常复杂的纹理。</p><p><img src="https://media.moddb.com/images/games/1/39/38759/3x-ANITblB0.1.jpg" alt=""></p><p>在很多生成式系统中，比如游戏制作场景里的贴图材质、波澜起伏的地面和海洋，很多都是用 perlin noise 生成的。它旨在描述自然中的随机效果，创建的纹理可以直接运用于顶点着色器，而不是像纹理映射技术，先生成一张纹理图，然后把贴图附加到一个三维物体上。也就是说，只需要提供每个顶点的 (x,y,z) 的坐标，传入 perlin noise 函数，计算得到一个随机数，然后与原颜色运算，得到新的颜色，如同直接在物体表面绘制纹理一样。</p><p>Perlin 认为，理想的噪声函数应当具有以下性质：</p><ol><li>旋转统计不变性（不管怎么旋转它的域都有同样的统计特性）  </li><li>能量在频谱上集中于一个窄带（图像是连续的，高频分量受限）</li><li>变换统计不变性（不管如何平移它的域都有同样的统计特性）</li></ol><p>产生 2D Perlin Noise 的方法：</p><ol><li>为所有坐标为（x,y）且 x, y 都是整数的点指定一个值，同时指定一个<a href="https://www.wikiwand.com/zh/%E6%A2%AF%E5%BA%A6" target="_blank" rel="noopener">梯度</a>，这些点将空间分成方格；</li><li>对于坐标轴为整数的点，即上述方格的顶点的值作为该点的值；对于某个方格内部的点（x,y），用所在方格四个顶点的值和<a href="https://www.wikiwand.com/zh/%E6%A2%AF%E5%BA%A6" target="_blank" rel="noopener">梯度</a>进行插值。</li></ol><p>为了简化计算，方便硬件实现，Ken Perlin 在 2002 年改进了方法，称为 Simplex 噪声。Simplex 噪声使用 <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ed5b799e7d9cd423db6f533050ddfda181b4850b" alt="{\displaystyle 6t^{5}-15t^{4}+10t^{3))">作为插值函数，避免了导数中的线性部分。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/54/SimplexNoise2D.png/240px-SimplexNoise2D.png" alt=""></p><p>使用 Simplex 方法产生噪声</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ul><li><a href="https://www.wikiwand.com/zh-hans/%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83" target="_blank" rel="noopener">概率分布 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Probability_density_function" target="_blank" rel="noopener">Probability density function - Wikiwand</a></li><li><a href="http://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/" target="_blank" rel="noopener">Common Probability Distributions: The Data Scientist’s Crib Sheet - Cloudera Engineering Blog</a></li><li><a href="https://www.wikiwand.com/zh/%E7%99%BD%E9%9B%9C%E8%A8%8A" target="_blank" rel="noopener">白噪声 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh/%E5%99%AA%E5%A3%B0%E7%9A%84%E9%A2%9C%E8%89%B2" target="_blank" rel="noopener">噪声的颜色 - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Pink_noise" target="_blank" rel="noopener">Pink noise - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Aleatoric_music" target="_blank" rel="noopener">Aleatoric music - Wikiwand</a></li><li><a href="https://www.wikiwand.com/en/Noise_music" target="_blank" rel="noopener">Noise music - Wikiwand</a></li><li><a href="https://www.wikiwand.com/zh/Perlin%E5%99%AA%E5%A3%B0" target="_blank" rel="noopener">Perlin噪声 - Wikiwand</a></li><li><a href="http://flafla2.github.io/2014/08/09/perlinnoise.html" target="_blank" rel="noopener">Understanding Perlin Noise</a></li><li><a href="https://blog.csdn.net/ZJU_fish1996/article/details/71136348" target="_blank" rel="noopener">[图形学] 柏林噪声 （perlin noise）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
      <category term="随机" scheme="http://uegeek.com/tags/%E9%9A%8F%E6%9C%BA/"/>
    
      <category term="噪声" scheme="http://uegeek.com/tags/%E5%99%AA%E5%A3%B0/"/>
    
      <category term="Noise" scheme="http://uegeek.com/tags/Noise/"/>
    
  </entry>
  
  <entry>
    <title>生成式艺术和算法创作01-概述</title>
    <link href="http://uegeek.com/181009-generative-art-creativity-01.html"/>
    <id>http://uegeek.com/181009-generative-art-creativity-01.html</id>
    <published>2018-10-09T11:18:35.000Z</published>
    <updated>2018-10-15T04:11:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/CC-blogtitle.png" alt=""></p><a id="more"></a><p>自从今年把兴趣领域<a href="https://www.uegeek.com/180717-human-computer-symbiosis.html" target="_blank" rel="noopener">从人机交互扩展到人机协同创作</a>之后，接触到越来越多「艺术x技术」的新鲜知识、有趣项目和精彩作品。一个星期有那么 7 天心情如下图：</p><p><img src="http://img.viz.mobi/justMyMind.jpg" alt=""></p><p>这个系列，<a href="https://uegeek.com/">00</a> 将会（希望是深入地）整理和介绍 Generative Art 和 Computational Creativity 的一些研究领域、概念和作品。当然，我们不满足于做手残党。为了避免出现只是看看图惊叹两句就没有然后的纯消费行为，这个系列也会探讨相关的技术、算法，以及实现的思路。</p><h2 id="需求井喷下的工具进化"><a href="#需求井喷下的工具进化" class="headerlink" title="需求井喷下的工具进化"></a>需求井喷下的工具进化</h2><p>为什么关注生成式艺术和算法创作？</p><p>除了个人的职业背景和癖好，还有对声色犬马的生活，哦不，做一个声色全码的手艺人的向往。</p><p>创意和娱乐产业发展到今天，已经是一个巨大的造梦引擎。但消费市场对极致体验和制造梦境能力的追求并不会停歇，这迫使技术和计算能力以前所未有的速度变化和发展。不但场景越来越宏大、梦幻、沉浸，对实时性、多角色协同、虚实融合的诉求也愈发强烈。这其中有大量的创作工作要做。</p><p><img src="https://images.unsplash.com/photo-1514525253161-7a46d19cd819?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=be465b88fdf21a6e05ab522458452344&amp;auto=format&amp;fit=crop&amp;w=800&amp;q=60" alt=""></p><p>比如，在 Minecraft 中，每周有超过 1000 万玩家，会在游戏里待上 20 小时。这样算下来，需要多少作曲家才能为每一位玩家提供个性化的音乐呢？</p><p><img src="https://images.g2a.com/newlayout/470x470/1x1x0/a476e4dbb6b0/591ef89dae653af3c942eff4" alt=""></p><p>Non-linear （非线性叙事）媒体日渐流行，自动生成丰富而个性化的内容流成为强需求，或者至少需要有方法能够帮助创意工作者更有效地完成创意任务。但是传统的工具例如视频剪辑、音频效果制作、图像合成等等，工具本身并不能提供更多的帮助。不论创意有多明确，一切都需要从头开始。</p><p>为什么机器不能以更动态、灵活、人性的方式与我们交互呢？比如说，我已经设计过 100 张海报，这次的设计跟其中的 3 张风格相似，但是内容会有变化。创作工具能不能自动生成几个草稿或模板，让我不必重零开始呢？</p><p>打造这样的工具或者工作流程，需要研究人类的创造过程，让机器在一定程度上自主完成创造过程，才能更好地辅助我们创造。</p><p>应用了计算机算法的生成式艺术处于艺术和创造的前沿，已经涌现出许多艺术和文化作品。</p><h2 id="生成式艺术"><a href="#生成式艺术" class="headerlink" title="生成式艺术"></a>生成式艺术</h2><p><strong>生成式艺术（Generative art）是指部分或全部使用自动创作系统（autonomous system）创造的艺术。</strong></p><blockquote><p>Generative art refers to any art practice where the artist <strong>uses a system</strong>, such as a set of natural language rules, a computer program, a machine, or other procedural invention, which is set into motion <strong>with some degree of autonomy</strong> contributing to or resulting in a completed work of art. </p><p>—— Philip Galanter </p></blockquote><p>可以用来辅助生成艺术作品的系统有很多，通常是一个非人类的独立系统（不一定是计算机），只要它可以独立确定一件艺术品的特征。生成式艺术几乎跟艺术本身一样古老，使用几何对称、样式、重复来生成图案的做法，已经存在几千年了。</p><p><img src="http://www.sfu.ca/~mdevos/notes/geom-sym/wallpaper/2222/egypt8b.jpg" alt=""></p><p>艺术家需要设计一个自主运作的机制来创作作品，这个机制通常包含一组规则，例如自然/音乐/编程语言、二进制代码、数据映射、生物指令等，由它们生成自动化处理过程，最终产生艺术作品。</p><p>生成式艺术可以为艺术家提供减少主观创造意向的手段。在不同的条件、参数、设置下，运行过程不同，结果会呈现出一定特征，但常常是不可预测的。</p><p>随着互动需求的增加、计算机计算能力提高，越来越多的生成式艺术作品是实时生成的，而且系统会收集反馈或产生即时的新输入，让结果持续更新和变化。</p><p>需要注意的是，<strong>生成式艺术并不是艺术流派、艺术运动或某种意识形态，它只是一种创造性的方法</strong>，与作品的意图和价值取向无关。</p><h2 id="算法创作"><a href="#算法创作" class="headerlink" title="算法创作"></a>算法创作</h2><p>Computational Creativity（我翻译为算法创作），是一个学术研究领域，<strong>研究的对象主要是创意活动的计算化/自动化过程。</strong>它并不局限于艺术，还包含各种创造性活动，如绘画、音乐、文学、表演等等。</p><p>算法创作听起来跟人工智能似乎很像，都强调算法、计算、自动的处理过程。它们是一样的吗？</p><p>让我们先来看看 Sternberg 在 Handbook of Creativity 里提出的创造性最重要的 3 类智能：</p><ul><li>分析智能 Analytical Intelligence：分析、评论、判断、比较、评估</li><li>实用智能 Practical Intelligence：使用、实施</li><li>创作智能 Synthetic/creative Intelligence：想象、创造、发明、发现、预测 </li></ul><p>再来回顾一下人工智能先驱司马贺给出的人工智能的定义：</p><blockquote><p>Artificial intelligence is the science of having machines solve problems that do require intelligence when solved by human. </p><p>—— Herbert Simon (1960)</p></blockquote><p>此处的重点是：solve problems。</p><p>AI 擅长 rational problem solving，也就是说，擅长处理那些解决方案可能很复杂，但是容易理解、目标明确或定义良好（well defined）的问题。</p><p>但是，机器可以擅长创作吗？</p><p>跟理性问题相比，创造性活动一般没有「最佳」结果或答案。不存在最好的音乐、绘画、诗歌、故事、笑话、菜谱、游戏……这一类活动更加需要 Sternberg 所说的第三类 synthetic 智能。于是算法创作渐渐从 AI 研究领域中分离出来，因为「最优」（optimality）的概念对创作行为来说是定义不良的（ill-defined）。</p><h2 id="Creative-System-的分类"><a href="#Creative-System-的分类" class="headerlink" title="Creative System 的分类"></a>Creative System 的分类</h2><p>从通用性来分，创意系统可分为特定的 (基于领域/任务/审美的) 和通用的。</p><p>从自动化程度来分，可分为响应式的和全自动的。</p><p>从互动性来分，可分为低互动性的（只响应输入，比如一般的人机交互界面）和高互动性的（可以相互影响的智能体行为）。</p><p>从系统的知识来源分，可分为硬编码的、输入的和学习式的（比如从语料学习）。</p><p>从系统的行为模式来分，可分为：fixed - periodic - complex - chaotic。</p><p>从有效复杂性（effective complexity）来分，可以分为：</p><p><img src="https://www.researchgate.net/profile/Philip_Galanter/publication/220947690/figure/fig2/AS:651931043233793@1532443881222/Effective-complexity-used-to-organize-various-generative-art-systems.png" alt=""></p><p>从架构和算法来分，可以分为：</p><ul><li><p>generative</p></li><li><p>generate and evaluate</p></li><li><p>generative with reflexive feedback</p><p><img src="http://img.viz.mobi/reflective%20system.png" alt=""></p></li><li><p>interactive and adaptive</p><p><img src="http://img.viz.mobi/interactive%20system.png" alt=""></p></li></ul><h2 id="算法创作的领域实践"><a href="#算法创作的领域实践" class="headerlink" title="算法创作的领域实践"></a>算法创作的领域实践</h2><h3 id="生成绘画"><a href="#生成绘画" class="headerlink" title="生成绘画"></a>生成绘画</h3><p>哈罗德·科恩（Harold Cohen）的 AARON 系统是一个从 1973 年开始的长期项目，他将软件人工智能与机器人绘画设备相结合，让机器自动作画，可以算得上是 AI 画家的鼻祖了。</p><p><img src="https://static1.squarespace.com/static/5800c6211b631b49b4d63657/t/5807227bebbd1a790b76fdb6/1476862594263/" style="zoom:50%"></p><p>自动作画的机器人被明名为 AARON。AARON 是一台很原始的绘画机器，但它可以在没有照片或其他人类输入参考的情况下绘制人物形象的静物和肖像。</p><p>在专注水彩作画的 40 多年里，AARON 的绘画能力逐年提高。80 年代学会了将物体或人物放置在三维空间中，从 1990 年起可以用彩色绘画。它的部分作品已被泰特等知名美术馆和一些私人收藏家收藏。</p><p><img src="https://images2.corriereobjects.it/methode_image/2015/09/09/Cultura/Foto%20Gallery%20-%20Trattate/sfpeople_ori_crop_MASTER__0x0_MGZOOM.jpg" style="zoom:50%"></p><p>Final Approach 是 2013 年 AARON 最新的绘画作品之一：</p><p><img src="https://windowsunited.de/wp-content/uploads/sites/3/2018/06/AARON-neu-4-1024x553.jpg" alt=""></p><p>时间快进到 2018 年，已经连续举办 3 年的 Robot Art Prize 已落下帷幕（ARRON 也参加了比赛🙂），第一名由名叫 cloudpainter 的机器人画家获得，下面是它的画作：</p><p><img src="https://static1.squarespace.com/static/5800c6211b631b49b4d63657/t/5b0f2e52aa4a99692dc998a2/1527721560441/robotart_announcement.jpg?format=2500w" alt=""></p><blockquote><p>我认为，在短期内，机器人将越来越多地用于数字艺术的最终生产，特别是那些有很多细节或重复元素的机器人。</p></blockquote><p>创立 RobotArt 的艺术家和工程师 Andrew Conru 表示。</p><p>但他不认为机器人或算法艺术家会取代更有创造性的人类。他把机器创造的艺术品比作照相机的创造<strong>。</strong>摄影成为一种全新的艺术分支，捕捉不同类型的图像和作品。</p><p>Conru 认为机器人和人类艺术品将继续存在。每个人都会为艺术领域带来不同的技能和方法。正如他的网站所说：</p><blockquote><p>We all win when we see something beautiful.</p></blockquote><h3 id="生成音乐"><a href="#生成音乐" class="headerlink" title="生成音乐"></a>生成音乐</h3><p>人们希望借助自然的力量更自动地创作音乐，这种想法实际上早已出现。从某种程度上说，第一首自动生成音乐来自于大自然：中国的风铃、古希腊的风弦琴、日本的水琴窟等。</p><p>莫扎特的 Musikalisches Würfelspiel（Musical Dice Game，1757）被认为是早期的基于随机性的生成系统。</p><p><img src="http://abjad.mbrsi.org/_images/mozart-tables.png" style="zoom:40%"></p><p>在这部作品中，他创作了 176 小节音乐，然后将小节号排列为两个特殊的矩阵图，通过演奏家掷般子的方式来决定音乐序列的选择。这个机制提供了有序和无序的平衡。可以说，将算法应用于音乐创作可能和音乐本身一样古老。</p><p>Iannis Xenakis 在他 1958 年的专辑 Analogique 中，使用了马尔可夫链来作曲。他在著作 Formalized Music: Thought and Mathematics in Composition 里详细描述了使用马尔可夫模型的算法。</p><p><img src="https://discourse-cdn-sjc2.com/standard17/uploads/critterandguitari/original/2X/a/aede09d8452c1b3d4273a4515dfa6c941c62e21e.jpg" alt=""></p><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=e1343co9tml" allowfullscreen="true"></iframe><p>第三章“马尔可夫的随机音乐：应用”（节选）<a href="https://v.qq.com/x/page/e1343co9tml.html" target="_blank" rel="noopener">音乐生成3_腾讯视频</a></p><p>John Cage，Farmers Manual 和 Brian Eno 等现代（电子）音乐先驱都在早期作品中开始使用生成系统。</p><p>Continuator 是 Francois Pache 在索尼计算机科学实验室 (Sony Computer Science Laoratories) 时主导的项目。</p><blockquote><p>The Continuator is a usable musical instrument combining techniques from interactive and automatic learning systems. </p></blockquote><p><img src="https://www.sonycsl.co.jp/wp-content/uploads/2015/08/Continuator.jpg" alt=""></p><p>他最近几年则投入到 <a href="http://www.flow-machines.com/" target="_blank" rel="noopener">Flow Machines</a> 项目中。</p><p><img src="https://pic.36krcnd.com/201801/30024716/k5qmdhmi5h5yyl6u!1200" alt=""></p><p>2016 年，格莱美获奖制作人 Alex Da Kid 与 IBM Watson 搭档合作一起创作歌曲。Watson 将大量的非结构化数据转化为情感洞察，创造出有史以来一种全新的音乐——可以“聆听”受众的音乐。</p><iframe frameborder="0" src="https://v.qq.com/txp/iframe/player.html?vid=b0388czlxm5" allowfullscreen="true"></iframe><p><a href="https://v.qq.com/x/page/b0388czlxm5.html" target="_blank" rel="noopener">Alex Da Kid 携手IBM Watson创作故事揭秘_腾讯视频</a></p><p><a href="https://www.ibm.com/ibm/cn/cognitive/outthink/watson/index.html" target="_blank" rel="noopener">Watson</a> 分析了近五年的文化和音乐数据，探索全新的情感洞察。</p><p>为了解最普遍最主流的话题及主题，自然语言分析 API <a href="http://www.ibm.com/watson/developercloud/alchemy-language.html" target="_blank" rel="noopener">Watson Alchemy Language</a> 分析了过去 5 年的各类文本，包括诺贝尔和平奖演讲内容，《纽约时报》头版，美国最高法院的裁定，洛杉矶 Getty 博物馆的报告，维基百科文章，热门电影梗概等等。</p><p>掌握这些文化主题后，情绪分析 API <a href="https://www.ibm.com/watson/services/tone-analyzer/" target="_blank" rel="noopener">Watson Tone Analyzer</a> 分析相关的社交媒体内容了解受众对主题的想法和感受。它还分析了过去 5 年 Billboard Hot 100 歌曲中超过 26000 首歌的歌词。Watson Beat 检测出来热门歌曲的作曲过程中，从逐年来不同的节奏、音高、乐器、流派中找出关系模型，帮助 Alex 发现不同声音所反映出的不同情感。</p><p>同时, 颜色分析 API <a href="http://www.research.ibm.com/" target="_blank" rel="noopener">Cognitive Color Design Tool</a> 对专辑封面、图像、色彩的分析也启发了 Alex 专辑封面的制作。</p><p><img src="http://www-31.ibm.com/ibm/cn/cognitive/outthink/watson/music/images/bg-03.jpg" alt=""></p><hr><p>新的创作时代已经到来。</p><p>新技术激发了前所未有的创造力，新的创作方式将赋予创作者们更大的能量。</p><p>00 的生成式艺术和算法创作系列，将带你一起探索（看起来很 Geek 很头疼的）知识和项目，其中很多都是艺术创作领域中前沿和硬核的话题，例如混沌和分型理论（Chaotic &amp; Fractal）、形状语法（Shape grammar）、规则系统（Rule-based system）、马尔可夫模型（Markov Model）、智能主体（Intelligent Agents）、多智能体系统（Multi-agent system）、元胞自动机（Cellular Automaton）等。</p><p>道阻且长，行则将至。</p><p>感谢你的陪伴。</p><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ul><li>Sternberg, R. J., &amp; O’HARA, L. A. (1999). 13 Creativity and Intelligence. <em>Handbook of creativity</em>, 251.</li><li>Philip Galanter. What is Generative Art? Complexity theory as a context for art theory, 2003 International Conference on Generative Art</li><li><a href="https://www.wikiwand.com/en/Triarchic_theory_of_intelligence" target="_blank" rel="noopener">Triarchic theory of intelligence - Wikiwand</a></li><li><a href="http://www.aaronshome.com/aaron/index.html" target="_blank" rel="noopener">Harold Cohen Home Page</a></li><li><a href="http://www.cloudpainter.com/" target="_blank" rel="noopener">cloudpainter - an artificially intelligent painting robot</a></li><li><a href="http://freedomandsafety.com/ru/node/1380" target="_blank" rel="noopener">Qbits for Cubists: Robots Made These Incredible Works of Fine Art | Freedom and Safety</a></li><li><a href="https://www.wikiwand.com/en/Musikalisches_W%C3%BCrfelspiel" target="_blank" rel="noopener">Musikalisches Würfelspiel - Wikiwand</a></li><li><a href="https://www.francoispachet.fr/" target="_blank" rel="noopener">François Pachet - Director of Spotify Creator Technology Research Lab</a></li><li><a href="http://www.flow-machines.com/" target="_blank" rel="noopener">Flow Machines: AI music-making</a></li><li><a href="https://medium.com/artists-and-machine-intelligence/neural-nets-for-generating-music-f46dffac21c0" target="_blank" rel="noopener">Neural Nets for Generating Music – Artists and Machine Intelligence – Medium</a></li><li><a href="http://www-31.ibm.com/ibm/cn/cognitive/outthink/watson/music/" target="_blank" rel="noopener">IBM Watson Music - 中国</a></li><li><a href="https://xw.qq.com/cmsid/20180409A1295K00" target="_blank" rel="noopener">机器人都能画出《蒙娜丽莎的微笑》了，那还要画家干什么？</a></li><li><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1538363661&amp;ver=1155&amp;signature=YiP2N6ONasXfYcTqidl7jz2x1KrfHO30I3hUGwHi9O2uqAL9tp8Z0xfeS7fVVljj7QMjazIetslJJ8r8whpe*brPZcbR3c1vRHin6Ovul4nxwE-ujd8z0qRXCeH1JIYg&amp;new=1" target="_blank" rel="noopener">人工智能是怎么创作音乐的？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/CC-blogtitle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="艺术" scheme="http://uegeek.com/tags/%E8%89%BA%E6%9C%AF/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="Generative Art" scheme="http://uegeek.com/tags/Generative-Art/"/>
    
      <category term="Computational Creativity" scheme="http://uegeek.com/tags/Computational-Creativity/"/>
    
      <category term="创意" scheme="http://uegeek.com/tags/%E5%88%9B%E6%84%8F/"/>
    
      <category term="创造力" scheme="http://uegeek.com/tags/%E5%88%9B%E9%80%A0%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/ Jitter 官方教程翻译20 - 迭代和矩阵重采样</title>
    <link href="http://uegeek.com/180930-jitter-20.html"/>
    <id>http://uegeek.com/180930-jitter-20.html</id>
    <published>2018-09-30T10:19:02.000Z</published>
    <updated>2018-09-30T10:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-2.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li><li><a href="https://www.uegeek.com/180915-jitter-17.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 17 - 图像旋转</a></li><li><a href="https://www.uegeek.com/180917-jitter-18.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程18 - 使用已命名的矩阵</a></li><li><a href="https://www.uegeek.com/180924-jitter-19.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程19 - 使用已命名矩阵的反馈</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter18" target="_blank" rel="noopener">Tutorial 18: Iterative Processes and Matrix Re-Sampling</a></p></blockquote><p>本教程演示何时应该使用已命名 <code>jit.matrix</code> 对象的更复杂示例，以及如何使用 <code>jit.matrix</code> 对图像增采样（upsampling）和减采样（downsampling）。</p><p>patch 左上角包含一个 <code>jit.movi​e</code>，patch 打开时会加载一个静止图像 fuzz_circle.jpg。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18a.png" alt="">            </p><p>单击开关启动 <code>metro</code>。图像出现在 patch 右下角的 <code>jit.pwindow</code> 中：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18b.png" alt=""></p><p>fuzz_circle.jpg 包含一个白色圆圈与黑色背景，在最终矩阵里尺寸被缩放为小的圆形。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18c.png" alt=""></p><h2 id="Getting-Drunk"><a href="#Getting-Drunk" class="headerlink" title="Getting Drunk"></a>Getting Drunk</h2><p> patch 顶部将 <code>jit.movi​​e</code> 中的图像写入链条中的第一个 <code>jit.matrix</code>。<code>bangbang</code> 对象发出的 bang 用 <code>drunk</code> 对象随机变化坐标，来改变 <code>jit.matrix</code> 每一帧的 dstdimstart 和 dstdimend 属性。请注意第一个 <code>jit.matrix</code> 的 usedstdim 属性为 1，它将缩放输入矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18d.png" alt=""></p><p>第一个 <code>jit.matrix</code> 只是用来缩放圆形图像以适应输出矩阵的 80 x 60 区域。请注意，格式化缩放图像坐标的消息框，也会逐帧清除矩阵（用 <code>clear</code> 消息），这样就不会残留之前的图像。<code>drunk</code> 改变了圆圈的位置，让它四处抖动。</p><p>单击 patch 右下角 <code>jit.pwindow</code> 中的某个位置。圆圈将跳到单击的位置，并从那里开始移动。</p><p>在 <code>jit.pwindow</code> 中单击鼠标的结果将发送到 <code>r winclick</code> 对象。<code>route</code> 对象将 <code>mouse</code> 相关的信息抽出来，用 <code>unpack</code> 对象提取前两个元素（鼠标单击的 x 和 y 位置）。然后使用来设置 <code>drunk</code> 对象的新原点。</p><h2 id="反馈网络"><a href="#反馈网络" class="headerlink" title="反馈网络"></a>反馈网络</h2><p>一旦圆圈图像已被缩放并由 <code>jit.matrix</code> 放置好，patch 流程就进入一对名为 blurry 的 <code>jit.matrix</code> 反馈链：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18e.png" alt=""><br>反馈循环</p><p>这一部分包含四个 <code>jit.matrix</code>（不包括顶部的一个缩小圆形图像的对象）。其中两个对象同名（blurry），仅用于存储和检索由 patch 的其余部分之前生成的矩阵。最上面的 <code>jit.matrix</code> 将矩阵发送到第一个 <code>jit.op</code> 的右入口。此外，它用 <code>bangbang</code> 发送 bang 到第一个 <code>jit.matrix blurry</code> 让它输出矩阵。该矩阵最终到达 <code>jit.op</code> 的左入口，然后显示（通过 <code>jit.pwindow</code>）并乘以标量（第二个 <code>jit.op</code> 对象）。它最终会覆盖先前的矩阵（进入下面的 <code>jit.matrix blurry</code>）。先不管中间一些对象，可以看到 blurry 矩阵将保留圆形图像前一“帧”的某个版本：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18f.png" alt="">            </p><p>第一个 <code>jit.op @op max</code> 组合新旧图像。@op max 比较两个矩阵中每个单元并保留值较高的那个单元。第二个 <code>jit.op @op *</code> 对象乘以标量（由 patch 右侧的数字框发送到 <code>s fb</code>）使图像变暗：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18g.png" alt=""><br>反馈量指定图像在存储之前变暗的程度</p><p>在 patch 的蓝色区域中用标记为 <code>Feedback</code> 的数字框来更改反馈量。单击 <code>jit.pwindow</code> 移动圆圈时，注意圆圈后的轨迹如何增加或减少，这取决于所设置的反馈量。</p><h2 id="增采样和减采样"><a href="#增采样和减采样" class="headerlink" title="增采样和减采样"></a>增采样和减采样</h2><p>图像处理算法的最后一步，涉及这两个对象之间的区域：发送前一帧中保留的矩阵的第一个 <code>jit.matrix blurry</code>，以及合成前后两个矩阵的 <code>jit.op</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18h.png" alt=""><br>用 <code>jit.matrix</code> 重新采样图像</p><p>教程 patch 中两个绿色 <code>jit.matrix</code> 重新采样上方的 <code>jit.matrix</code> 的模糊图像矩阵。两个 <code>jit.matrix</code> 中的第一个将 dim 的属性设置为 4 x 4。可以用蓝色区域中标记为 Pixelation 的数字框来更改。这个数字被发送到 <code>jit.matrix</code> 上方的 <code>s dim</code>   对象。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18i.png" alt="">            </p><p>在教程 patch 的蓝色区域中，更改标记为 Pixelation 的数字框。注意圆形轨迹如何变化。</p><p>对图像矩阵减采样，<code>jit.matrix</code> 将 320 x 240 矩阵从其输入复制到一个小得多的矩阵中，舍弃多余的数据。得到像素化的图像，可以用矩阵的 dim 控制。</p><p>第二个 <code>jit.matrix</code> 将矩阵增采样回到 320 x 240 大小。当后续的对象处理矩阵时，它们有全分辨率图像并将输出全分辨率矩阵。</p><p><code>jit.streak</code> 对象通过随机复制到相邻单元得到好看的像素化轨迹效果。<code>jit.streak</code> 的 prob 属性控制矩阵中任何给定单元格被复制到相邻单元格的可能性。这里的 prob 为 0.5，任何给定单元格都有 50％ 的可能性。</p><blockquote><p>技术细节：默认情况下 <code>jit.streak</code> 将单元格复制到左侧。更改  direction 属性将改变此行为。还有一个 scale 属性可以指定被复制的单元格与其原始值的亮度比值。<code>jit.streak</code> 的帮助文档有更具体的信息。</p></blockquote><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter18j.png" alt="">            </p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>成对命名 <code>jit.matrix</code> 可以有效地存储先前迭代。这些技术可以用合成对象（例如 <code>jit.op</code>）组合先前矩阵与当前矩阵来生成视频延迟效果。还可以使用 <code>jit.matrix</code> 重新采样图像（使用 dim 属性）以更有效地执行算法（矩阵越小，图像处理得越快）并创建像素化效果。<code>jit.streak</code> 对象根据概率因子（prob 属性）随机复制单元格到相邻单元格。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译19 - 使用已命名矩阵的反馈</title>
    <link href="http://uegeek.com/180924-jitter-19.html"/>
    <id>http://uegeek.com/180924-jitter-19.html</id>
    <published>2018-09-24T03:58:55.000Z</published>
    <updated>2018-09-25T07:36:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-1.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li><li><a href="https://www.uegeek.com/180915-jitter-17.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 17 - 图像旋转</a></li><li><a href="https://www.uegeek.com/180917-jitter-18.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 18 - 使用已命名的矩阵</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter17" target="_blank" rel="noopener">Max 7 - Tutorial 16: Using Named Jitter Matrices</a></p></blockquote><p>本教程讲解在反馈循环（feedback loop）中使用命名的 <code>jit.matrix</code> 。我们将使用随机值矩阵来构建迭代过程（Conway’s Game of Life）。</p><p>教程 patch 用 <code>jit.noise</code> 生成随机值的初始矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17a.png" alt=""><br><code>jit.noise</code> 对象</p><p><code>jit.noise</code> 生成由随机值填充的矩阵。dim，planecount 和 type 属性确定输出矩阵（需要一个 80 x 60 单平面 char 数据矩阵）。<code>jit.op</code> 将随机单元格的值（初始为 0~255）设置为 false（0）或 true（255）。<code>jit.op</code> 的 &gt; 运算符从右入口数字框中获取值并用于比较运算。如果单元格值小于该值，单元格的值将设置为 0，否则设置为 255。发送到 <code>jit.noise</code> 的 bang 将生成新的随机矩阵。</p><p>更改附加到 <code>jit.op</code> 的数字框。单击连接到 <code>jit.noise</code> 的按钮，每次都生成一个新矩阵。注意更大的比较值产生更少的白色（255）单元格。<code>jit.op</code> 下面的小 <code>jit.pwindow</code> 显示随机矩阵。单平面矩阵数据由 <code>jit.pwindow</code> 解析为灰度视频。</p><h2 id="矩阵反馈"><a href="#矩阵反馈" class="headerlink" title="矩阵反馈"></a>矩阵反馈</h2><p>patch 顶部的量化（quantized）噪声从 <code>jit.op</code> 传到名为 cellular 的 <code>jit.matrix</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17b.png" alt=""><br>在反馈循环中有两个已命名的 <code>jit.matrix</code></p><p><code>jit.matrix</code> 接收来自 patch 顶部的 <code>metro</code> 的 bang，它连接到一个名为 <code>jit.conway</code> 的对象，其输出连接到另一个同名的 <code>jit.matrix</code>。结果是 <code>jit.conway</code> 的输出（无论它做什么）被写入跟其输入相同的矩阵中，从而创建反馈循环。</p><p>点击开关启动 <code>metro</code>。 patch 底部的 <code>jit.pwindow</code> 将显示 <code>jit.conway</code> 的输出。</p><p>如果想从一个新的随机矩阵开始，单击连到 <code>jit.noise</code> 的按钮，将新矩阵复制到反馈循环中。来自 <code>jit.op</code> 的矩阵会进入反馈循环中相同的 cellular 矩阵。</p><h2 id="生命的游戏"><a href="#生命的游戏" class="headerlink" title="生命的游戏"></a>生命的游戏</h2><p><code>jit.conway</code> 对输入矩阵执行名叫 “Game of Life” 的简单元胞自动机算法。该算法由普林斯顿大学的 John Conway 发明，模拟食物供应有限环境中的有机生存周期。矩阵中的单元格被看做是活的（非 0）或死的（0）。比较每个单元与周围的单元。如果一个活细胞有两个或三个活的邻居，它就活着。如果多于或少于该数字，它将死亡（0）。如果死去的细胞恰好有三个活的邻居，它就会变为活的（255）。就这么简单。</p><p>每当 <code>jit.conway</code> 接收到输入矩阵时，会开始一轮生命游戏。因此，在反馈循环内使用对象是有意义的，可以看到在同一初始数据集上执行多代算法。</p><p>例如，初始随机矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17c.png" alt=""><br>一些随机矩阵值</p><p><code>jit.conway</code> 在前四次迭代中生成以下矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter17d.png" alt=""><br>在上面的数据集上 Game of Life 的前四代</p><p>使用随机矩阵 seeding 反馈循环后，可以打开 <code>metro</code> 并观察算法运行。Game of Life 的设计方式使得矩阵最终将稳定到一组自振荡 (self-oscillating) 细胞单元或空矩阵（a dead world）。在任何一种情况下，都可以 bang 一组新的数字重新开始。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用 <code>jit.matrix</code> 的 name 属性在 Jitter 中创建反馈循环。在对象链的任一端使用两个同名 <code>jit.matrix</code>，可以创建输出将被写入与输入来源相同的矩阵的链条。<code>jit.noise</code> 产生的任意随机数 type/dim/planecount 的矩阵。<code>jit.conway</code> 对输入矩阵做简单的元胞自动处理，在反馈回路中效果最好。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译18 - 使用已命名的矩阵</title>
    <link href="http://uegeek.com/180917-jitter-18.html"/>
    <id>http://uegeek.com/180917-jitter-18.html</id>
    <published>2018-09-17T10:21:32.000Z</published>
    <updated>2018-09-25T07:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-9.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li><li><a href="https://www.uegeek.com/180915-jitter-17.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 17 - 图像旋转</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter16" target="_blank" rel="noopener">Tutorial 16: Using Named Jitter Matrices</a></p></blockquote><p>本教程将学习如何使用 <code>jit.matrix</code> 的 name 属性将来自多个源的矩阵数据写入同一矩阵。我们还将研究如何在复制时缩放矩阵的大小，以及如何用 Max 低优先级队列来降低事件的优先级，以支持更耗时的任务。</p><p>教程 patch 分为五个彩色区域。中间（浅蓝色）区域包含两个 <code>jit.movi​e</code> 对象。<code>loadbang</code> 对象在 patch 打开时读取两个视频（rain.mov 和 traffic.mov）到 <code>jit.movi​e</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16a.png" alt=""></p><p>与之前的教程不同，这里的 <code>jit.movi​e</code> 使用 <code>send</code> 和 <code>receive</code> 对象与 patch 的其余部分通信。名为 m1 和 m2 的 <code>receive</code> 对象将消息转发给两个 <code>jit.movi​e</code>  对象。然后发送它们的输出矩阵（使用 <code>send</code>）到 patch 其他位置名为 movie1 和 movie2 的 <code>receive</code> 对象。</p><p> patch 顶部的黄色区域包含驱动 patch 中 Jitter 进程的 <code>metro​</code>：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16b.png" alt=""></p><center><code>metro</code> 驱动两个消息框中的一个</center><p>点击开关启动 <code>metro</code> 。 patch 中的三个 <code>jit.pwindow</code> 开始显示图像。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p><code>metro</code> 经过 <code>Ggate</code> 和 <code>jit.qball</code> 到达 <code>gate</code>。 <code>metro</code> 发送的 bang 由 <code>gate</code> 分流到两个消息框之一。最终输出矩阵（在 patch 底部的 <code>jit.pwindow</code> 中）将根据哪个消息框被触发而改变。</p><p>单击连接到 <code>gate</code> 左入口的两个消息框（1 和 2）。注意底部的 <code>jit.pwindow</code> 如何变化：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16c.png" alt=""></p><center>最终输出矩阵根据 patch 的消息顺序而变化</center><p>两个消息框都将 bang 发送到三个命名相同的 <code>receive</code> 对象（m1，m2 和 output）。两者的区别在于发送消息的顺序。左侧消息框（由 <code>metro</code> 驱动，当 <code>gate</code> 设置为 1 时）将第一个 bang 发送到 <code>jit.movie</code> （rain movie）。最后，patch 底部的 <code>jit.matrix</code> 收到 bang，最终矩阵被发送出去。右侧消息框（由 <code>metro</code> 驱动，当 <code>gate</code> 被设置为 2 时）调换驱动 <code>jit.movie</code> 的两个 bang 的顺序（左 <code>jit.movie</code> 先输出矩阵，然后是右边的 <code>jit.movie</code>）。</p><p>当查看两个 <code>jit.movie</code> 和最终的 <code>jit.pwindow</code> 之间发生了什么时，这些消息发送的顺序才有意义。</p><blockquote><p>要点：如果不确定 Max patch 中发生事件的顺序，可以查看 patch 的 trace 的执行方式。在接线中设置断点就可以使用 “Auto Step” 命令逐步执行 patch ，查看它如何运行。但是这对于 <code>metro</code> 效果不好，因为 bang 将持续重启。先在  <code>metro</code> 位置添加按钮用于调试。</p></blockquote><h2 id="名字里面有什么？"><a href="#名字里面有什么？" class="headerlink" title="名字里面有什么？"></a>名字里面有什么？</h2><p>一旦 <code>jit.movie</code> 接收到 bang，就会向下面的 <code>send</code> 对象输出一个矩阵，然后传递给名为 movie1 和 movie2 的 <code>receive</code> 对象。<code>receive</code>（在 patch 右侧两个相同的区域）连接到 <code>jit.pwindow</code> 以及两个已命名的 <code>jit.matrix</code> 对象：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16d.png" alt=""></p><center>已命名的 <code>jit.matrix</code> </center><p> patch 右侧的两个 <code>jit.matrix</code>（以及 patch 底部 <code>jit.pwindow</code> 上方的 <code>jit.matrix</code>）都有名称。这三个对象的名称是 composite。它们共享包含在名为 composite 的矩阵中的数据。</p><p>理解了两个 <code>jit.movie</code> 将数据写入相同的矩阵（名称相同的两个独立的 <code>jit.matrix</code>），就明白为什么 bang 的顺序很重要。如果左边的 <code>jit.movi​e</code> 首先发出矩阵，它会将数据写入 composite 矩阵，然后是右边的 <code>jit.movi​e</code>，它将数据写入同一个矩阵。如果两个矩阵写入任何共同的单元格（见下文），那么最后到达的矩阵将覆盖之前单元格中的数据。</p><h2 id="目的地维度"><a href="#目的地维度" class="headerlink" title="目的地维度"></a>目的地维度</h2><p>教程 patch 右侧的两个 <code>jit.matrix</code> 对象将 <code>usedstdim</code> 属性设置为 1。这样可以缩放由 <code>jit.movie</code> 发送的矩阵，以便它们只写入 composite 矩阵的某个区域。</p><p>调整标记为 <code>x origin</code> <code>y origin</code> 的数字框，缩放它所连接的两个子 patch <code>p coords</code>。请注意 composite 矩阵如何移动和调整 <code>jit.movie</code> 中两个图像的大小。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16e.png" alt=""></p><center>图片内的图片</center><p><code>p coords</code> 包含相同的辅助 patch ，用于格式化 <code>jit.matrix</code> 对象的 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性。这些属性分别指定将数据复制到 composite 矩阵时的左上角和右下角坐标。<code>usedstdim</code> 属性告诉 <code>jit.matrix</code> 复制数据时使用这些属性。当 <code>usedstdim</code> 为 0 时，缩放输入矩阵以填充 <code>jit.matrix</code> 引用的整个矩阵。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16f.png" alt=""></p><center>写入共享矩阵之前先缩放输入矩阵</center><p>发送到子 patch 的三个数字由内部对象格式化，生成要填充的输出矩阵的左上和右下区域坐标列表。消息在输出前，用 $ 暂时替代列表中对应的数字参数。</p><p>在两个矩阵写入 composite 矩阵之后，最后一件事是发送 bang 到名为output 的 <code>receive</code> 对象：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter16g.png" alt=""></p><center>最后的结果</center><p>教程 patch 底部的区域是第三个名为 <code>jit.matrix</code> 的对象。由 <code>metro</code> 发送的 bang 经过一个 <code>trigger</code> 对象发送 bang 到 <code>jit.matrix</code>（让它输出矩阵到 <code>jit.pwindow</code>），紧接一个 <code>clear</code> 消息（0），清除所有名为 composite 矩阵中的单元格。如果不清空矩阵，改变任何<code>jit.matrix</code> 的 <code>dstdimstart</code> 和<code>dstdimend</code> 属性，可能导致残留之前输出位置的图像。</p><h2 id="队列优先级"><a href="#队列优先级" class="headerlink" title="队列优先级"></a>队列优先级</h2><p>当 Max 运算跟不上速度时， patch 顶部的 <code>jit.qball</code> 对象就有了用武之地。<code>metro​</code> （每隔 50 毫秒发出 bang）正在触发三个独立的操作（从 <code>jit.movi​e</code> 对象写入数据到两个已命名的矩阵，显示数据，清空矩阵以便重新开始）。<code>jit.matrix</code> 写入数据到内部矩阵（这个例子中是 composite 矩阵）并允许后续消息来插队。运行任务时，它允许其他优先级更高的 Max 事件发生。这样可以在前一操作完成之前显示矩阵（或将更多数据写入），从而引起闪烁和其他意外结果。</p><p><code>jit.qball</code> 对象把消息放到 Max 低优先级队列的最后， 在那里其他消息可以被优先处理。如果 <code>jit.qball</code> 在所有当前任务完成之前从 <code>metro​</code> 得到 bang，它将等到队列中其他所有任务都完成后，再发出 bang。同样，如果另一个 bang 在发出第一个 bang 之前就出现了（即如果 patch 的剩余时间需要超过 50 毫秒才能完成所有事情），第一个 bang 将被抢先（抛弃）而只发出第二个 bang。这让我们可以放心地在 Max patch 中设置极值，而不必担心事件累积过快 Max 处理不过来。</p><p>单击标记为 <code>jit.qball bypass switch</code> 的 <code>Ggate</code> 对象，让 <code>metro​</code> 的输出绕过 <code>jit.qball</code> 。底部 <code>jit.pwindow</code> 中的合成图像开始闪烁，表示消息乱序到达。</p><p>通常，发送 bang 到 Jitter 对象将插到已经挂起的事件（例如已经到达但尚未被处理的 bang）前面。不过 <code>jit.qball</code> 提供了对多个 Jitter 对象链的控制，自动调度事件（dropframing）保证消息以正确的顺序到达。</p><blockquote><p>注：在大多数应用中 <code>Qball</code>已被 <code>qmetro​​</code> 取代。 <code>qmetro​​</code> 是内置 <code>qball</code> 机制的 <code>metro​​</code> 对象。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>命名多个 <code>jit.matrix</code> 为同一个名称，可以在 patch 的不同部分中写入和读取矩阵数据。使用 dstdimstart 和 dstdimend 属性，或者设定 usedstdim 属性为 1，可以在将其复制到 <code>jit.matrix</code> 内部时缩放矩阵。<code>jit.qball</code> 对象把 Max 事件放到低优先队列中来降低优先级，如果没有足够资源来执行，则优先处理其他事件。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p><center>👇👇👇</center></p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译17 - 图像旋转</title>
    <link href="http://uegeek.com/180915-jitter-17.html"/>
    <id>http://uegeek.com/180915-jitter-17.html</id>
    <published>2018-09-15T12:09:37.000Z</published>
    <updated>2018-09-25T07:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-8.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li><li><a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 16 - 矩阵定位</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter15" target="_blank" rel="noopener">Tutorial 15: Image Rotation</a></p></blockquote><h2 id="使用-jit-rota-旋转和缩放"><a href="#使用-jit-rota-旋转和缩放" class="headerlink" title="使用 jit.rota 旋转和缩放"></a>使用 jit.rota 旋转和缩放</h2><p>Jitter 提供 <code>jit.rota</code> 对象来旋转和/或缩放图像。旋转和缩放是常见的视频效果，以不同方式组合它们还可以实现万花筒效果。<code>jit.rota</code> 在入口处获取视频数据矩阵（或其他类型的图像），根据对象属性的设置发送已缩放、旋转和以其他方式失真的版本。</p><p>打开教程 patch 。loadbang 触发 QuickTime 视频 dishes.mov 读入 <code>jit.movi​​e</code>。单击 “Display” 开关启动 <code>metro</code> 开始播放视频。</p><p>视频是一个对着餐盘拍摄的三秒从左到右平移镜头。<code>jit.movi​​e</code> 的循环属性初始化为 2，因此视频来回循环产生了来回平移的效果。</p><blockquote><p>注意：Jitter 对象的许多属性使用参数 1 和 0 表示 “on” 和 “off”，因此可以合理地假设 <code>jit.movi​​e</code> 的 loop 属性也是这样。loop 0 关闭循环，loop 1 打开，loop 2 让视频向前播放，到达 loopend 点时向后播放，而不是跳回到视频起点。</p></blockquote><p><code>jit.rota</code> 的 theta 属性指定围绕中心锚点的旋转角度。</p><p>拖动 “Rotation Angle” 数字框旋转视频。正（或增加）值是逆时针旋转，负（或减小）值是顺时针旋转。旋转角度 - 也就是角度（θ） - 以弧度表示。0 或 2π 的任何倍数（如 6.283185）是正常的直立位置。π 值（3.141593）或 π 的任何奇数倍是颠倒的位置。随意尝试，直到了解 theta 值与 <code>jit.rota</code> 行为之间的关系。</p><blockquote><p>技术细节：<code>jit.rota</code> 用三角法进行大量内部计算，以确定如何旋转图像。如果不是三角学迷，你可能不习惯用弧度来思考角度。平时我们更常使用度数，即一个完整的旋转是 360°。在三角学中更常使用弧度，完整旋转是 2π 弧度。这是因为半径为 1 的圆的周长恰好为 2π，可以用与单位圆相交的点来表示角度。（例如，从单位圆上的一个点开始并绕圆周移动 π/2 的距离，会得到 90° 角度 - 即 π/2 弧度的角度 - 从开始的地方以圆心为中心）</p><p>另外，在三角学中，角度的正变化是围绕单位圆逆时针旋转，而在日常生活中，把顺时针运动看做 “正” 或 “增加” 更符合惯例（如钟表时针的转动）。</p><p>因此，如果把度为单位的顺时针旋转，转换为以弧度表示，需要将度角乘以 2π，然后除以 -360。</p></blockquote><h2 id="自动旋转"><a href="#自动旋转" class="headerlink" title="自动旋转"></a>自动旋转</h2><p>除了手动旋转图像外，还可以编写自动化程序提供不断变化的旋转角度。在<a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">上一章</a>中，我们编写了一个名为 rotate 的子 patch，它使用 <code>line</code> 对象将色调旋转角度从 0° 增加到 360°。现在做类似的事情，但使用 bang 视频的 <code>metro</code> 来增加旋转角度。为了使用上的友好，用 ° 表示旋转角度，而不是弧度（在子 patch 中转换度弧度单位），另外也显示转速为 “每秒转数”。</p><p>在标有 Degrees per bang 的数字框中输入数字 6。这让旋转角度在 <code>metro</code> 每次 bang 时增加 6°。由于 <code>metro</code> 每秒发出 20 次 bang（每 50 毫秒一次），我们可以通过公式 <code>d * 20 / 360</code> 计算每秒的转数（即 d / 18，d 是每次 bang 增加的角度）。现在单击标记为 On / Off 的开关开始自动旋转。</p><p>双击 <code>rotate</code> 查看子 patch</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter15a.png" alt=""><br>[rotate]子 patch 中的自动旋转</p><p>用度数 * 2π / -360，将用户指定的每次旋转角度转换为弧度量。当一个 bang 进入左入口时，如果正在旋转，bang 让旋转角度增加并添加到 <code>accum</code> 对象中。请注意，每次增加负的角度也 ok，这让图像逆时针旋转。当总旋转角度超过 2π（或 -2π）时，<code>split</code> 将值发送到使用模运算的 <code>expr</code>，并在发送到出口前将其恢复到范围内（重置 <code>accum</code> 中的值）。如过旋转关闭，我们 用 <code>sel 0</code> 检测到该事件，将 theta 角度重置为 0。</p><p>关闭子 patch 窗口。单击 On/Off 开关停止自动旋转。</p><h2 id="放大或缩小"><a href="#放大或缩小" class="headerlink" title="放大或缩小"></a>放大或缩小</h2><p><code>jit.rota</code> 的另一个主要功能是缩放。缩放量由 <code>zoom_x</code> 和 <code>zoom_y</code> 属性决定。这样可以单独放大或缩小水平和垂直尺寸；或者一次更改两个属性来同时缩放。</p><p>拖动标有 <code>Zoom</code> 的数字框来放大和缩小。大于 1 的值会放大图像，小于 1 的值会缩小图像。直接在 x 和 y 数字框中输入值分别更改 x 和 y 的缩放尺寸（负缩放值会翻转图像并调整其大小）。</p><p>当放大图像（如值为 2）时，图像质量仍然不错，因为我们已经用 <code>interp 1</code> 消息打开 <code>jit.rota</code> 的插值属性。如果关闭 interp，会在放大时产生像素化。当缩小时 interp 没有明显的效果，它几乎浪费了计算资源。（有关像素化和插值，请参阅 <a href="https://www.uegeek.com/180909-jitter-16.html" target="_blank" rel="noopener">Jitter 教程16</a>）不过插值确实可以改善旋转图像的现实，即便图像缩小。</p><h2 id="超越边缘"><a href="#超越边缘" class="headerlink" title="超越边缘"></a>超越边缘</h2><p>将缩放的两个尺寸设置为较小的值例如 0.25。</p><p>当图像由于收缩或旋转而未填满整个显示区域时，<code>jit.rota</code> 必须决定如何处理位于图像区域外的矩阵的其余部分。现在 <code>jit.rota</code> 将图像区域外的所有单元格值设置为 0，使它们为黑色。<code>boundmode</code>属性决定 <code>jit.rota</code> 如何处理位于图像边界之外的单元格。不同的可用 <code>boundmode</code> 设置显示在 patch 右上角标记为 <code>Space outside the image</code> 的弹出菜单中。将 <code>boundmode</code> 的值初始化为 1，让 <code>jit.rota</code> 清除所有外围单元格。以下是每个 <code>boundmode</code>设置的含义：</p><blockquote><p>0 Ignor：保持所有外围单元格不变。</p><p>1 Clear：将所有外围单元格值设置为0。</p><p>2 Wrap：根据需要重复图像以填充矩阵。</p><p>3 Clip：对于所有外围单元格，继续使用图像边界单元格的值。</p><p>4 Fold：重复图像，向相反方向翻转。</p></blockquote><ul><li>对于缩小图像时的特殊效果，尝试将 <code>boundmode</code> 属性设置为 2（Wrap）以获得 “Warhol” 复制图像效果，或设置为 4（Fold）得到万花筒效果。</li><li>现在试着重新打开自动旋转，组合旋转和缩放，并修改参数（每次 bang 的度数、缩放、Space outside the image）。</li><li>尝试完以后，关闭自动旋转并将缩放属性（ <code>zoom_x</code>和 <code>zoom_y</code>）调整回 1。</li></ul><h2 id="调整锚点和偏移"><a href="#调整锚点和偏移" class="headerlink" title="调整锚点和偏移"></a>调整锚点和偏移</h2><p>目前为止，我们一直使用图像的中心作为旋转锚点。其实可以选择任意一点。用 <code>anchor_x</code> 和 <code>anchor_y</code> 属性设置旋转中心。现在是 160 和 120（图像尺寸的一半），可以在标记为 Anchor 的数字框中更改。</p><p>尝试不同的锚点，然后在 Rotation Angle 数字框上拖动查看效果。可以尝试 0,0 或 40,30 或 160，-120 或 320,240。将 <code>boundmode</code>属性设置为 1 可以更清楚地看到不同旋转的效果。请注意，<code>anchor_x</code> 和 <code>anchor_y</code> 值是相对于矩阵的左上角指定的，但它们可以超出矩阵维度的边界。</p><p>此外可以用 <code>offset_x</code> 和 <code>offset_y</code> 属性在缩放和旋转后，将图像移动到输出矩阵中的其他位置。</p><p>要最有效地查看此内容，请先单击 patch 右下角的 <code>pvar</code> 对象上方的消息框。这会将旋转角度/边界模式/缩放/锚点恢复到本章开头的设置。（已经为相关的 UI 指定了名称，以便通过 <code>pvar</code> 与它们通信）现在将缩放数字框设置为 0~1 的某个值来缩小图像。</p><p>使用 Location offset 数字框，更改 <code>offset_x</code>和 <code>offset_y</code> 值来移动图像。同时设置 <code>boundmode 4</code>，在 “kaleidoscope” 模式下查看效果。</p><p>完成后，将位置偏移值重置为 0。</p><h2 id="鼠标控制旋转"><a href="#鼠标控制旋转" class="headerlink" title="鼠标控制旋转"></a>鼠标控制旋转</h2><p>我们为你设计了另一种旋转图像的方法。</p><p>单击 <code>jit.pwindow</code> 显示对象，按住鼠标，围绕对象中心以小圆周运动拖动。</p><p><code>jit.pwindow</code> 跟踪鼠标移动，当鼠标按下时，它会以鼠标消息的形式将坐标信息（和其他鼠标信息）发送到右输出口。鼠标消息的前两个参数是相对于 <code>jit.pwindow</code> 左上角的 x 和 y 坐标。使用这些坐标来计算鼠标相对于 <code>jit.pwindow</code> 中心的角度并发送到 <code>jit.rota</code> 作为theta 属性的参数。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter15b.png" alt=""><br>用 <code>jit.pwindow</code> 中的鼠标位置作为控制信息</p><h3 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h3><p>想知道这是如何计算的吗？</p><p>如果将 <code>jit.pwindow</code> 的中心点视为原点 0,0，把当前鼠标位置看做是位于该点圆周上的点，那么可以基于这两点得到一个直角三角形。获取鼠标坐标 y / x 的反正切值，得到鼠标相对于 <code>jit.pwindow</code> 中心的角度。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter15c.png" alt=""></p><p>接收到传入的 x 和 y 坐标要做的第一件事是做转换，使它们以 <code>jit.pwindow</code> 为中心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr<span class="number">-1.0</span>*atan(($i1<span class="number">-160.</span>)/(<span class="number">-1.</span>*$i2+<span class="number">119.5</span>))+($i2&gt;=<span class="number">120</span>)*<span class="number">-3.141593</span></span><br></pre></td></tr></table></figure><p>用 x 坐标减去 160 （x 值现在在 -160~160）并将 y 坐标乘以 -1（这样上移时值正向增大）然后加上 119.5。（如果正好添加120，那么每次从 <code>jit.pwindow</code> 得到 120 的 y 坐标时都会尝试在 expr 中除以0，这是一个未定义的数学运算）转换了 x 和 y 坐标，用 <code>atan(y / x)</code> 来获得弧度，然后乘以 -1 使鼠标顺时针旋转，从而使图像顺时针旋转。</p><p>此方法仅在 180° 范围内有效，因为反正切函数无法区分鼠标位置与圆上相对点之间的差异（这两个点 y / x 的值相同）。因此每当鼠标的 y 坐标进入 <code>jit.pwindow</code> 的下半部分时，我们在 θ 角度上添加 -π 的偏移量来区分那些来自另外一边的位置。（表达式中的最后一部分）</p><p>请注意，此表达式仅适用于 <code>jit.pwindow</code> 中的点 160,120。如果想创建一个适用于任何大小 <code>jit.pwindow</code> 中心点的表达式，要使用 <code>getsize</code> 消息获取 <code>jit.pwindow</code> 的维度，并用 size 值作为表达式中的变量。正如书上所说，“我们把这个练习留给读者”。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.rota</code> 对象用 theta 属性指定旋转角度，以弧度表示旋转图像。它还提供了使用 <code>zoom_x</code>和 <code>zoom_y</code> 属性放大和缩小图像的简便方法。用 <code>anchor_x</code>和 <code>anchor_y</code> 属性更改旋转的中心点，用 <code>offset_x</code> 和 <code>offset_y</code> 属性在输出矩阵中移动生成的图像。可以用 <code>boundmode</code> 属性更改 <code>jit.rota</code> 处理位于结果图像之外的矩阵单元格的方式。结合这些功能，除了缩放和旋转之外，你还可以获得重复图像和万花筒效果。</p><p>缩放和旋转涉及 <code>jit.rota</code> 相当密集的内部计算，这些操作对计算机的处理器提出了很高的要求。本教程中未提及的其他属性，可以调整旋转公式中的几乎每个系数，提供更多扭曲和旋转图像的可能性。请查看 <code>jit.rota</code> 文档说明。</p><p>要同时管理对如此多属性，可以设计自动流程以生成属性值，和/或交互式控件来更改值。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译16 - 矩阵定位</title>
    <link href="http://uegeek.com/180909-jitter-16.html"/>
    <id>http://uegeek.com/180909-jitter-16.html</id>
    <published>2018-09-09T11:02:52.000Z</published>
    <updated>2018-09-25T07:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-7.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li><li><a href="https://www.uegeek.com/180908-jitter-15.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 15 - 剪刀和胶水</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter14" target="_blank" rel="noopener">Max 7 - Tutorial 14: Matrix Positioning</a></p></blockquote><h2 id="在矩阵中数据定位"><a href="#在矩阵中数据定位" class="headerlink" title="在矩阵中数据定位"></a>在矩阵中数据定位</h2><p>本教程将讨论如何获取矩阵的一部分数据，放到另一个矩阵中不同位置。要重新定位数据的原因可能有很多。这里讨论的技巧主要为了生成各种视觉效果，但对于其他目的也适用。</p><p>我们将展示如何分离矩阵的一个区域，将其放到另一个矩阵中的指定位置，调整大小（对于拉伸、像素化和模糊等视觉效果非常有用）并动态移动它。</p><h2 id="jit-window"><a href="#jit-window" class="headerlink" title="jit.window"></a>jit.window</h2><p>打开 Window_options 子 patch</p><p>在 patch​ 左下角有一个<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">教程 3</a> 介绍过的 <code>jit.window</code> 对象。它创建一个单独的窗口来显示矩阵内容。在大多数其他教程章节中都使用 <code>jit.pwindow​</code>。</p><p><code>jit.window</code> 和 <code>jit.pwindow​</code> 非常相似 - 除了一个是打开单独的窗口而另一个使用 Patch 中的矩形区域 - 它们有许多相同的属性和消息。但也有一些差异，这将使用 <code>jit.window</code> 来展示一些特性。</p><p>你可能看不到 <code>jit.window</code> 打开的 Display 窗口，因为它隐藏在 Patch 窗口后面。我们可以让 Display 窗口浮动 - 一直在浮动在 Max 每个窗口之上，同时仍然与 Patch 窗口交互。为此要用 <code>floating 1</code> 消息打开 <code>jit.window</code> 的浮动属性（默认为 0）。</p><p>打开 Window_options 子 patch​ ，单击标记为 <code>Display as floating window</code> 开关，将 <code>floating 1</code> 消息发送到 <code>jit.window</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14a.png" alt=""><br>使窗口“浮动”在其他窗口前面</p><p>输入到 <code>jit.window</code> 的屏幕坐标 - <code>450 60 770 300</code> - 指定了 320 像素宽，240 像素高的显示区域。（如何为 <code>jit.window</code> 指定屏幕坐标，请参阅本章后面的说明和/或<a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">教程 3</a>）</p><h2 id="从一个-jit-matrix-到另一个"><a href="#从一个-jit-matrix-到另一个" class="headerlink" title="从一个 jit.matrix 到另一个"></a>从一个 jit.matrix 到另一个</h2><p>现在加载图片并尝试修改。</p><p>单击消息框 <code>importmovie sunset.jpg</code> 将图片加载到 patch 顶部的 <code>jit.matrix</code> 中。打开标有 <code>Display On/Off</code> 的 <code>metro</code>，开始向 <code>jit.matrix</code> 发送 bang。</p><p>用 <code>jit.window</code> 显示图像之前，bang 将矩阵（通过 <code>jit.hue</code>）发送到第二个 <code>jit.matrix</code>。在那里能够修改属性以指定显示矩阵的哪个部分。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14b.png" alt=""><br>发送矩阵给另一个 <code>jit.matrix</code>，然后到 <code>jit.window</code> </p><p>我们已经在 patch​ 中间的 <code>preset</code> 中为 UI 对象保存了几个配置。</p><p>选择 <code>preset</code> 中的配置 1 会发送 <code>dim 16 12</code> 消息将下方的 <code>jit.matrix</code> 的尺寸更改为 16x12。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14c.png" alt=""><br>dim 消息改变<code>jit.matrix</code>的维度</p><p>输入矩阵的尺寸是 320x240，但是接收 <code>jit.matrix</code> 的尺寸仅为 16x12，它尽可能显示接收的矩阵，但必须丢弃大部分信息。这会导致图像像素化（指用低分辨率 - 较小的像素 - 来显示图像时产生的马赛克效果）。即使 <code>jit.window</code> 能够显示全分辨率 320x240 的图像，它接收的矩阵现在只有 16x12。出于显示目的，它按需复制像素，将 16x12 矩阵「扩展」为 320x240。</p><p>拖动标有 “Change actual matrix dimensions” 的两个数字框，查看不同的像素化效果。</p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>现在将数字框设置回 16 和 12，然后单击标记为 <code>Interpolate in window to smooth pixelation</code> 的开关将 <code>interp 1</code> 消息发送到 <code>jit.window</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14d.png" alt=""><br>在 <code>jit.window</code> 中打开插值</p><p>现在由 <code>jit.window</code> 在输入矩阵和扩展到 320x240 之间插值，而不是复制 16x12 像素来制作一堆 20x20 像素块。也就是说，当它扩展图像时，在每个单元格值与其输入矩阵中的相邻值之间，创建平滑的颜色渐变，因此 320x240 矩阵中从一个单元到另一个单元的所有变化都尽可能渐进发生。插值会产生极大的模糊，因为输入和输出矩阵的大小差异很大。</p><p>再次点击开关，发送 <code>interp 0</code> 消息给 <code>jit.window</code> 设置 interp 的属性为 0（关闭）。在标记为 <code>Change actual matrix dimesions</code> 的数字框中输入新的矩阵尺寸，减少图像像素化：例如，80 和 60（现在像素化块每个只有 4x4）。点开关重新开启插值。请注意，在这种情况下模糊减轻了，因为插值只发生在 4 个像素上。再次关闭插值。</p><p>现在点击标记为 <code>Interpolate in matrix to smooth pixelation</code> 的开关，打开 <code>jit.matrix</code>（而不是 <code>jit.window</code>）的插值。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14e.png" alt=""><br>减小矩阵的大小时，插值就不明显</p><p>这没有太大变化。因为 <code>jit.matrix</code> 仍然只能发送 80x60 矩阵。在这种情况下的插值（缩小而不是放大矩阵时）可以忽略不计。</p><p>再次点开关关闭 <code>jit.matrix</code> 的插值。</p><h2 id="隔离矩阵的一部分"><a href="#隔离矩阵的一部分" class="headerlink" title="隔离矩阵的一部分"></a>隔离矩阵的一部分</h2><p>在 <code>preset</code> 中，选择配置 2。现在只能看到图片的一小部分。</p><p>这个配置将 <code>jit.matrix</code> 的尺寸恢复为 320x240。但是仍然可以使用一些属性来隔离矩阵的特定部分而不改变整个矩阵的实际尺寸： <code>srcdimstart​</code> ，<code>srcdimend​</code> 和 <code>usesrcdim</code>。</p><p>向 <code>jit.matrix</code> 发送三条新消息来设置这三个属性：<code>dimstart 40 150</code>，<code>dimend 119 209</code> 和 <code>usesrcdim 1</code>。这些消息指定输入矩阵的子集，并将这些值作为全尺寸（在本例中为 320x240）矩阵发送出去。输入矩阵的这个子集在 <code>jit.matrix</code> 「扩展」（按需复制单元格），以填充输出矩阵的大小。<code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性被忽略。</p><p>设置 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性的消息中，单词紧跟的是描述每个维度内起点和终点的单元索引。<code>dimstart 40 150</code> 和 <code>dimend 119 209</code> 消息告诉 <code>jit.matrix</code> 在水平维度中使用来自单元格 40~119 的特定 80x60 区域，在垂直维度中使用单元格 150~209。</p><blockquote><p>本章中讨论了三种指定矩形区域的方法！关键要明确每种情况下指定的内容。</p><ul><li><p>在 <code>jit.window</code> 中输入显示区域的坐标。在计算机的操作系统中，屏幕坐标原点在左上角，是 0,0; 往右两个像素（左起第三个像素）是 2,0; 该点向下 5 个像素（向下的第六个像素) 是 2,5。输入矩形的左-上-右-下的参数坐标描述屏幕的矩形区域。</p></li><li><p><code>jit.matrix</code> dim 属性指定维度大小（单元格数量）。</p></li><li><p><code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性指定单元格索引（包含）。单元格索引从 0 到单元格数量 - 1（平面的索引也类似）。对于 320x240 矩阵，第一维中单元格索引从 0~319，第二维索引从 0~239。对于 <code>jit.matrix</code> 的维度，用 <code>srcdimstart​</code> 后跟起始单元格索引，来指定每个维度的起点，用 <code>srcdimend​</code>  后跟结束单元格索引，来指定终点。</p></li></ul></blockquote><p>输入矩阵仅有 80x60 像素，而目标矩阵为 320x240。较小矩阵扩展为较大矩阵会导致像素化。但是现在扩展发生在 <code>jit.matrix</code> 内部（即在它的“源”区域和“目标”大小之间），而不是在 <code>jit.matrix</code> 和 <code>jit.window</code> 之间（正如之前减小 <code>jit.matrix</code> 尺寸）。如果想通过插值来平滑像素化，必须在 <code>jit.matrix</code> 中完成。在 <code>jit.window</code> 中启用插值没有意义，因为它已经从 <code>jit.matrix</code> 接收到 320x240 矩阵。</p><p>要验证这一点，请打 <code>interpolate in window...</code> 开关发送 <code>interp 1</code> 到 <code>jit.window</code>。因为我们试图将 320x240 矩阵插入到 320x240 显示区域，因此不会发生任何变化。关闭开关，将 <code>jit.window</code> 差值属性设置回 0。现在用另一个开关将 <code>interp 1</code> 消息发送到 <code>jit.matrix</code>。现在得到了我们想要的平滑效果。</p><p>尝试输入新值来更改 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性的参数。这样可以将图片的任何特定区域隔离为“源”区域。为源区域选择的尺寸将决定图片在扩展到填充 320x240 输出矩阵时的失真程度。</p><h2 id="翻转图像"><a href="#翻转图像" class="headerlink" title="翻转图像"></a>翻转图像</h2><p>你可能认为 <code>srcdimend​</code> 属性的参数（源区域的终点单元索引）应该大于 <code>srcdimstart​</code>。并非如此。</p><p>选择 <code>preset</code> 的配置 3 垂直翻转图片。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14f.png" alt=""><br>顶部和底部在第二维中翻转</p><p>如果在垂直维度中指定小于起始索引的结束单元格索引，<code>jit.matrix</code> 仍将这些索引与目标矩阵的垂直维度中的起点和终点相关联，从而有效地反转值的方向。</p><p>可以在水平维度中进行翻转以水平翻转图像。如果在两个维度上翻转源区域，会得到将图像旋转 180° 的视觉效果。</p><p>选择 <code>preset</code> 的配置 4。</p><p>这个例子在两个维度上翻转了源区域，将大小减小到 160x120 ，并打开 interp 属性来平滑像素化。</p><h2 id="调整输出矩阵的大小"><a href="#调整输出矩阵的大小" class="headerlink" title="调整输出矩阵的大小"></a>调整输出矩阵的大小</h2><p>既然可以指定矩阵的源区域，那么也可以指定目标区域。这仍然不会改变输出矩阵的大小，dim 属性为 320x240。但是会更改源区域所在的区域。输入矩阵的源区域，将被放置在输出矩阵的目标区域中（按需扩展/收缩）。位于目标区域之外的输出矩阵的单元将保持不变。</p><p>选择 <code>preset</code> 的配置 5。整个输入矩阵被挤压到输出矩阵中心的 80x60 矩形中。</p><p>首先要注意的是 <code>usesrcdim</code> 属性已被关闭，因此我们再次使用整个输入矩阵作为源（现在忽略 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性）。<code>usedstdim</code> 属性已打开，输入将被放在输出矩阵的任意指定部分。<code>dstdimstart</code> 和 <code>dstdimend</code> 属性指定矩阵中间的单元为目的地：<code>dstdimstart 120 90</code> 和 <code>dstdimend 199 149</code>。我们关闭了 interp 属性，因为现在正在收缩图像。</p><p>另外，我们已打开标记为 <code>Erase previous image</code> 的开关。这将数字 1 发送到 <code>if $2 then clear</code> 对象。该语句的 if 部分现在为 true ，因此每次对象在左入口处收到消息时，将发送 <code>clear</code> 消息。这会在显示图像后立即清除 <code>jit.matrix</code> 对象的内容，为将要接收的下一个 <code>jit.matrix</code> 准备。这样可以确保目标区域外的所有单元格的值都为 0，输出矩阵的未使用区域将显示为黑色。</p><p>更改指定目标尺寸的数字框中的值，在 Display 窗口中移动（并调整尺寸）图片。</p><p>关闭标记为 Erase previous image 的开关停止 <code>clear</code> 消息。更改 <code>dstdimstart</code> 和 <code>dstdimend</code> 的参数，注意这次有什么不同。之前的目标区域仍然在 Display 窗口中绘制，因为矩阵中的那些单元格尚未清除，如果它们位于新目标区域之外，将保持不变。这样产生了前面图像的残留效果，可进一步获得特定的视觉效果。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14g.png" alt="">            </p><h2 id="在矩阵中移动图像数据"><a href="#在矩阵中移动图像数据" class="headerlink" title="在矩阵中移动图像数据"></a>在矩阵中移动图像数据</h2><p>自动设置 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性过程，我们可以在矩阵中移动数据，使图像看起来在实时移动。</p><p>选择 <code>presets</code> 的配置 6。</p><p>这将启动 <code>move_around​</code> 子 patch 内部的自动过程，持续提供新的参数给 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性。用 patch 上方的开关启动，数字框为每次移动到新目的地指定时间（以毫秒为单位）。</p><p>双击 patch <code>move_around​</code> 查看子 patch 内容。目前为止我们只使用了子 patch​ 的右半部分。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14h.png" alt=""><br>子 patch [<code>move_around​</code>] 中的目标移动过程</p><p>右入口中的 rate 值是 <code>metro</code> 的时间间隔。定期触发 4 个 <code>random</code> 对象，随机选择新的左-上-右-下索引。这些目标点与时间值一起发送到 <code>line</code> 对象，再以每 50 毫秒间隔发出，把目标区域逐步转移到这些新的随机点（显示图像的速率）。在子 patch​ 之外，这些值用作 <code>jit.matrix</code> 的 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性的参数。</p><p>这个子 patch​ 包含一些值得注意的技巧。第一个技巧我们已经实现过，它让 <code>dstdimend</code> 的参数可以超过矩阵的 320x240 范围。例如，使用 <code>random 640</code> 对象作为水平维度，然后从结果中减去 160，得到从 -160~479 的结束单元格索引。这样做是为了增大目标区域，以便图像变化时看到较大的视图，这也意味着图像将更频繁地移动到窗口边缘。值得注意的是，可以指定超出矩阵实际单元格的目标边界，<code>jit.matrix</code> 能够在该区域内完整显示图像（当超出矩阵尺寸时裁剪）。</p><p>第二个技巧比较细节：使用 <code>sel 0</code> 对象来检测 <code>metro</code> 何时关闭，用它来触发每个 <code>line</code> 对象的 <code>stop</code> 消息，以便它们在自动流程关闭后不会继续发送值。</p><p>关闭 [move_around​]子 patch​ 窗口。</p><h2 id="更改，调整大小和移动源图像"><a href="#更改，调整大小和移动源图像" class="headerlink" title="更改，调整大小和移动源图像"></a>更改，调整大小和移动源图像</h2><p>现在我们也将更改源图像自动化。</p><p>选择 <code>presets</code>的配置 7。</p><p>与设置目标区域的方式大致相同，现在需要不断改变图像的源区域。我们现在看到源矩阵的一些矩形子集的动画视图（使用 <code>srcdimstart​</code> 和 <code>srcdimend​</code>），不断调整该视图的大小并在窗口中移动它（使用 <code>dstdimstart</code> 和 <code>dstdimend</code>）。由于[<code>move_around​</code>]子 patch​ 随机选择源矩形和目标矩形，因此图像有时也会被翻转。<code>jit.matrix</code> 的插值属性已经打开，平滑源图像被拉伸时出现的像素化。</p><p>要更清楚看到变化，打开标记为 <code>Erase previous image</code> 开关。</p><h2 id="关于尺寸的更多信息"><a href="#关于尺寸的更多信息" class="headerlink" title="关于尺寸的更多信息"></a>关于尺寸的更多信息</h2><p>本教程介绍了如何更改 <code>jit.matrix</code> 的维度，以及如何在对象中指定源和目标区域。为了便于讨论和可视化，我们在二维矩阵内指定源矩形和目标矩形。这也可以用于任意维度的矩阵。（<code>srcdimstart​</code> ，<code>srcdimend​</code> ，<code>dstdimstart</code> 和 <code>dstdimend</code> 的参数个数对应于 <code>jit.matrix</code> 的维度）。 例如，如果有一个三维矩阵，这些参数可用于指定矩阵的虚拟 3D 空间中的六面体。</p><blockquote><p>注意：某些专门处理 2D 矩阵的 Jitter 对象（例如 <code>jit.movi​​e</code>），源和目标区域将始终为矩形区域。在这些对象中，源区域和目标区域在名为 srcrect 和 dstrect 的单个属性中定义，这些属性用四个参数来指定矩形的边界（左上角和右下角）单元格。</p></blockquote><h2 id="Hue-Rotation"><a href="#Hue-Rotation" class="headerlink" title="Hue Rotation"></a>Hue Rotation</h2><p>为了增添一点多样性，在两个 <code>jit.matrix</code> 中间增加 <code>jit.hue</code> 对象。（<a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">教程 9 详细介绍了 <code>jit.hue</code></a>）</p><p>选择 <code>presets</code>配置 8 并查看正在运行的 <code>jit.hue</code>。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14i.png" alt=""><br>修改色调角度</p><p>这个配置关闭 <code>usedstdim</code> 但打开 <code>usercdim</code>，并在 <code>jit.matrix</code> 中启用插值以模糊扩展的图像。rotate 子 patch 自动旋转 <code>jit.hue</code> 的色相角度。</p><p>双击打开 rotate 查看子 patch。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14j.png" alt=""><br>[rotate]子 patch​ </p><p>右入口的值指定完成 360° 色调旋转的时间（以毫秒为单位）。当 1 进入左入口时，数字 360 与该时间值组合，指示 <code>line</code> 对象在该时间内从 0 到 360，每 50 毫秒发出一个新的值。</p><p>请注意，<code>line</code> 的第一个 typed-in 参数包含一个小数点，说明 <code>line</code> 发送浮点数而不是整数以提高精度（而且 <code>jit.hue</code> 的 hue_angle 消息接收浮点数）。当<code>line</code> 到达 360，右出口发出 bang。用它将 <code>line</code> 设置回 0，然后 re-bang <code>pack</code> 对象开始下一个旋转。当左入口处接收到 0 时，<code>sel 1</code> 对象直接将其传递到 <code>line</code> 停止重置色调角度为 0。</p><p>关闭[rotate]子 patch​。</p><p>选择 <code>preset</code> 配置 9。它基本上整合了 patch​ 中所有自动化和图像处理技巧。这次 <code>jit.matrix</code> 的目标尺寸变化设置为 200 毫秒，以更快的速率产生效果。</p><h2 id="全屏显示"><a href="#全屏显示" class="headerlink" title="全屏显示"></a>全屏显示</h2><p>当你用 Max patch​ 创建了想要的图像，并想以更优雅的方式显示结果时，可以让 <code>jit.window</code> 全屏。它的 <code>fullscreen</code> 属性打开时，<code>jit.window</code> 使用整个屏幕作为显示区域。如果不勾选 inspector 中的 fsmenubar 属性，将隐藏菜单栏。</p><p>关于 <code>jit.window</code> 全屏功能，有几点需要注意。</p><p>首先，一旦全屏（特别是隐藏了菜单栏时），无法再使用鼠标退出全屏。所以需要在 Max patch​ 中设置让全屏属性恢复为 0 的方法。</p><p>其次，只有一个 <code>jit.window</code> 可以全屏。如果有多个 <code>jit.window</code> 对象争夺全屏访问权限，则最近将全屏属性设置为 1 的对象将填满屏幕。</p><p>此外，即使 <code>jit.window</code> 全屏，其分辨率也由其实际尺寸（即其 rect 属性的参数）决定。例如，如果 rect 属性指定了 320x240 的矩形，那会作为图像的分辨率，即使屏幕尺寸远大于此。</p><p>在 Window_options 子 patch​ 中，包含了使用空格键打开和关闭 <code>jit.window</code> 全屏属性的功能。<code>jit.window</code> 将 fsmenubar 设置为 0。这在全屏时隐藏顶部菜单栏（Mac）。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter14a.png" alt=""><br>使用空格键切换到全屏显示</p><p>尝试使用空格键打开和关闭全屏。</p><p>要获得更抽象的视觉效果，请将 colorswatch.pict 图像导入到 patch 顶部的 <code>jit.matrix</code> 中，然后尝试不同的配置。</p><p>本教程使用静止图像作为源素材，以便查看演示效果，当然也可以使用视频。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>隔离和重新定位矩阵中的某些数据有不同的方法。<code>jit.matrix</code> 的 dim 属性设置矩阵的实际尺寸。<strong>打开 <code>jit.matrix</code> 的 <code>usesrcdim</code> 和 <code>usedstdim</code> 属性，可以使用输入和输出矩阵的指定区域</strong>，它们被称为源（source）和目的（destination）区域。</p><p>使用 <code>srcdimstart​</code> 和 <code>srcdimend​</code> 属性指定这些区域的单元格边界（将起始和结束单元格设置为源区域的角点）和 <code>dstdimstart</code> 和 <code>dstdimend</code> 属性（用于目标区域）。</p><p>这些属性不会改变矩阵的实际大小，当 <code>usercdim</code> 和 <code>usedstdim</code> 打开时，它们指定输入矩阵的某部分将显示在输出矩阵的哪个部分。如果源区域和目标区域的形状（大小）不同，<code>jit.matrix</code> 将扩展或收缩源区域以适合目标区域。这会导致重复或丢失数据，但可以产生有趣的拉伸或像素化效果。源区域和目标区域可以使用 Max patch​ 的其他部分的数字来动态更改，以便交互式或自动修改图像的大小、形状和位置。</p><p>interp 属性打开时，如果目标区域的尺寸大于源区域，<code>jit.matrix</code>  在它们之间插值（提供中间值）。这可以平滑像素化效果，并模糊相邻单元格的变化。</p><p><code>jit.window</code> 用已经指定的 rect 属性大小的矩形区域，显示它接收的任何尺寸的矩阵。如果输入矩阵的大小与显示区域的大小不同，图像将被 <code>jit.window</code> 扩展、缩小或扭曲。这也可以用于拉伸和像素化效果。 打开 <code>jit.window</code>  interp 时，可平滑拉伸和像素化。</p><p>要使用图像填充整个屏幕，可以打开 <code>jit.window</code> 全屏属性，并用 <code>fsmenubar 0</code> 消息隐藏菜单栏。（要留下一些方法让 Patch 窗口回到前台）</p><p>我们已经演示了调整矩阵数据的大小、重新定位、翻转和插值以生成视觉效果（如拉伸，扭曲，模糊和像素化）的技巧。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-7.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="图像" scheme="http://uegeek.com/tags/%E5%9B%BE%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译15 - 剪刀和胶水</title>
    <link href="http://uegeek.com/180908-jitter-15.html"/>
    <id>http://uegeek.com/180908-jitter-15.html</id>
    <published>2018-09-08T10:12:52.000Z</published>
    <updated>2018-09-25T07:37:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-6.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li><li><a href="https://www.uegeek.com/180907-jitter-14.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 14 - 颜色查找表</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter13" target="_blank" rel="noopener">Tutorial 13: Scissors and Glue</a></p></blockquote><p>本教程学习如何使用两个简单的对象来切割和组合二维矩阵的矩形区域。</p><p>教程 patch 有两个互补的 Jitter 对象：将矩阵切割成大小相等的小矩阵的 <code>jit.scissors</code>; 将多个矩阵粘贴到一起的 <code>jit.glue</code>。还会简要介绍 <code>router</code> 对象，它可以将 Max 消息从多个源引导到多个目的地。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13a.png" alt=""><br>读取视频</p><p>patch 左上角的 <code>loadbang</code> 自动发送 <code>read traffic.mov</code> 消息给 <code>jit.movi​​e</code> 加载交通镜头的视频。</p><p>点击 patch 顶部的开关启动 <code>metro</code>。视频出现在底部较大的  <code>jit.pwindow</code> 中。有趣的是，图像被切割成四个象限，出现在分开的的 <code>jit.pwindow</code> 中。</p><h2 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h2><p><code>jit.scissors</code> 把包含视频的矩阵分割成四个小矩阵：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13b.png" alt="">        </p><p><code>jit.scissors</code> 将任意尺寸/类型/平面数的矩阵切割成更小的矩阵，然后在不同出口发送。@rows 和 @columns 属性指定每次接收到矩阵时分割成多少个小矩阵。这里 <code>jit.scissors</code> 将图像拆分为四个小矩阵（2 列 2 行）。这些单独的矩阵以<strong>列优先</strong>顺序发送到各出口（从左到右，然后从上到下）。</p><p><code>jit.scissors</code> 有两个属性非常重要：</p><p>1）出口数量在创建对象时就确定。只有在对象框中指定行和列属性，才会生成对应数量的出口。例如，<code>jit.scissors @rows 10 @columns 2</code> 将创建一个有 20 个出口的 <code>jit.scissors</code> 实例（包括用于查询属性的最右出口），如果 <code>jit.scissors</code> 没有参数，就只会生成一个出口。可以用 Max 消息更改行和列属性，但是无法添加超过对象初始化时的出口数量。</p><p>2）<code>jit.scissors</code> 发送的矩阵大小等于矩阵切片的大小，而不是整个原始矩阵。例如，教程 patch 中的四个较小的矩阵，每个都是 160x120 个单元，而不是 320x240。</p><h2 id="Routing-the-Matrices"><a href="#Routing-the-Matrices" class="headerlink" title="Routing the Matrices"></a>Routing the Matrices</h2><p>由 <code>jit.scissors</code> 输出的四个小矩阵，被发送到两个不同的地方： <code>jit.pwindow</code> 和 <code>router</code> 对象。彩色接线显示每小矩阵被发送到了哪里。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13c.png" alt=""><br><code>router</code> 对象</p><p><code>router</code> 是 <code>gate</code> 和 <code>switch</code> 的组合。它有两个参数（输入口数量和输出口数量），由左入口的消息指定。<code>router</code> 能处理的大多数消息与 MSP 对象 <code>matrix~</code> 相同。因此可以跟 <code>matrixctrl</code> 对象一起使用。</p><p><code>router</code> 右侧的四个入口从 <code>jit.scissors</code> 的四个矩阵出口获取输入。<code>receive routeit</code> 对象从 patch 的右下方控制 <code>router</code> 的 <code>s routeit</code> 获取消息。<code>router</code> 最左边四个出口连接到 <code>jit.glue</code> 对象，我们稍后会讨论。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13d.png" alt=""><br>控制路由器</p><p>发送消息 <code>patch $1</code> 后跟入口号($1)和出口号到 <code>router</code>， 会在该入口和对象的出口之间建立虚拟连接。到达该入口的任何消息会转发给相应出口。如果先前已有入口连接到该出口，patch 消息将切断该连接以支持新连接。</p><p>patch 中的 <code>radiogroup</code> 对象控制四个小矩阵（到达入口）被发送到 <code>router</code> 的哪些出口。入口和出口从 0 开始编号，所以 <code>2 1</code> 在 <code>router</code> 的 3 入口和 2 出口建立连接。</p><p>单击 <code>radiogroup</code> 控件并观察下方 <code>jit.pwindow</code> 的图像如何变化。注意 <code>router</code> 如何使剪切的矩阵，出现在底部合成图像的四个象限中。</p><h2 id="整合的胶水"><a href="#整合的胶水" class="headerlink" title="整合的胶水"></a>整合的胶水</h2><p>patch 底部的 <code>jit.glue</code> 做与 <code>jit.scissors</code> 相反的事情。行和列的属性指定入口数而不是出口数，以网格排列的输入矩阵合成一个矩阵输出。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter13e.png" alt=""><br>将相同的矩阵发送到 <code>jit.glue</code> 的四个入口</p><blockquote><p>要点：与 <code>jit.scissors</code> 一样，<code>jit.glue</code> 只能在对象初始化时创建入口和出口，对象框中的行和列属性将确定入口数。此外，由 <code>jit.glue</code> 生成的输出矩阵的大小，等于所有小矩阵的大小（例如，四个 160x120 矩阵将合成一个 320x240 矩阵）。</p></blockquote><p><code>jit.glue</code> 默认当从左入口接收到新矩阵时，只输出复合矩阵。如果断开 <code>jit.glue</code> 最左边的入口，就不能再获得任何新的输出矩阵。syncinlet 属性可让 <code>jit.glue</code> 发送输出到不同的入口。syncinlet 值为 -1 时，<code>jit.glue</code> 在任一入口收到新矩阵时都输出新的合成矩阵。虽然看似不错，但会增加大量冗余工作，降低 Jitter 的帧处理速率。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.scissors</code> 对象切割矩阵成更小的、大小相等的矩阵。<code>jit.glue</code> 对象把相同大小的矩阵合并到一起生成复合矩阵。两个对象的行和列属性分别确定出/入口的数量，以及矩阵被切割或合成的方式，这在对象创建时就要给出。<code>router</code> 以任意方式连接多个入口处的消息到多个出口，跟 MSP <code>matrix~</code> 对象类似。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译14 - 颜色查找表</title>
    <link href="http://uegeek.com/180907-jitter-14.html"/>
    <id>http://uegeek.com/180907-jitter-14.html</id>
    <published>2018-09-07T11:57:41.000Z</published>
    <updated>2018-09-25T07:38:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-5.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying 视频去背景合成</a></li><li><a href="https://www.uegeek.com/180906-jitter-13.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 13 - 列表和矩阵</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter12" target="_blank" rel="noopener">Tutorial 12: Color Lookup Tables</a></p></blockquote><p>本教程将讲解如何使用颜色查找表（lookup tables）重新映射 Jitter 矩阵内的数据。<code>jit.charmap</code> 对象是为此而设计的。我们还将研究生成查找表矩阵的不同策略，包括 <code>jit.gradient</code> 对象。</p><h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p>查找表（通常称为传递函数/transfer functions）是一个数组，以数字为表的索引。检索存储在该索引（地址或位置）的数字来替换原数字。任何函数 graph - 每个 x 值（地址）有相应的 y 值（输出）- 都可以用作查找表。Max 对象如 <code>funbuff</code>，<code>table</code> 和 MSP <code>buffer~</code> 对象是常用的查找表。本教程将以类似的方式使用 Jitter 矩阵。</p><p>打开教程 patch 读取图像</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12a.png" alt="">            </p><p>patch 左上角有一个 <code>jit.movi​​e</code> 对象，读取两个文件。初始化对象（通过 loadbang）并加载文件 colorwheel.pct。也可以点击 <code>rain.mov</code> 消息加载视频。可以随意切换两个图像源。</p><p>单击 patch 顶部的开关启动 <code>metro</code>。色轮同时出现在顶部和底部的 <code>jit.pwindow</code>。底部第三个（矩形）<code>jit.pwindow</code> 中出现渐变。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12b.png" alt=""><br><code>jit.charmap</code> 的输出和查找表矩阵</p><p>patch 底部有一个<code>jit.charmap</code> 对象，用它来重新映射图像中的单元格值。对象有两个入口，左入口连接到顶部的 <code>jit.movi​​e</code>。右入口连接到 <code>jit.matrix colortable</code>。名为 colortable 的矩阵只有一维共 256 个单元，有四个 char 型数据平面。这是<code>jit.charmap</code> 用来重新映射左边矩阵中单元格的颜色查找表。带有名字 ctable 的<code>receive</code>（一般缩写为 <code>r</code>）对象从 patch 的其他位置接收数据并发送到 <code>jit.matrix</code>。打开顶部的开关发送一个 bang 到 <code>jit.matrix colortable</code>，它将矩阵消息发送到<code>jit.pwindow</code> 和 <code>jit.charmap</code>。</p><p><code>jit.charmap</code> 用输入（左）矩阵中的值，指向（右）矩阵中对应的位置并复制那里的值，生成输出矩阵。如果发送给<code>jit.charmap</code> 的矩阵包含一个在四个平面中值为 <code>100 50 35 20</code> 的单元格。如果查找表在平面 1 第 100 个单元格的值是 73，平面 2 第 50 个单元格的值是 25 ，平面 3 的第 35 个单元格的值是 0，平面 4 第 20 个单元格的值是 203，输出单元的值是 <code>73 25 0 203</code>。</p><p><code>jit.charmap</code> 查找表是有 256 个单元格的一维矩阵，其平面数量与要重新映射的矩阵相同。因为 char 矩阵的值范围是 0~255，因此需要 256 个数字来覆盖查找表。</p><h2 id="生成查找表"><a href="#生成查找表" class="headerlink" title="生成查找表"></a>生成查找表</h2><p>patch 的右上侧包含三个 <code>multislider</code>，可以设计 colortable 查找表矩阵 1-3 平面的传递函数：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12c.png" alt=""><br>用 multislider 的值填充查找表矩阵</p><p><code>multislider</code>（有 256个 整数 slider，范围为 0~255）把列表发送到下面的 <code>jit.fill</code>对象。它用 <code>multislider</code> 的值替换 colortable 矩阵当前存储在平面1-3（即红，绿和蓝）的值。当矩阵采用新值时，<code>jit.fill</code>发出 bang 到 patch 左边连接到 <code>jit.charmap</code> 右入口的 <code>jit.matrix</code>。这里忽略了平面 0，因为只有将 4 平面矩阵视为视频时，它才包含 Alpha 值。</p><p>patch 中的 <code>jit.matrix</code> 和 <code>jit.fill</code> 的名称相同（colortable）。这样两个对象从同一矩阵读取和写入，一个对象（<code>jit.fill</code>）生成另一个对象（<code>jit.matrix</code>）可读取的数据，而不必在两个矩阵之间复制数据。这跟许多 MSP 对象（例如 <code>peek~</code>，<code>play~</code>，<code>groove~</code>）可以共享存储在单个 <code>buffer~</code> 中的样本数据类似。关于命名矩阵请参见<a href="https://www.uegeek.com/180905-jitter-13.html" target="_blank" rel="noopener">教程 13</a>，18 和 19。</p><p>在 <code>multislider</code> 中随意绘制一些形状，看它如何影响查找表（较小的<code>jit.pwindow</code>）和 <code>jit.movi​​e</code> 的输出图像。可以来回切换两个图像源。</p><p>如果想重置任一平面为 <code>y = “x”</code> 传递函数（使所有值保持不变的固定斜率直线），可以单击相应 multislider 上的按钮。名为 <code>p clear</code> 的子 patch 用 <code>uzi</code> 初始化了 <code>multislider</code>。</p><blockquote><p>要点：与许多 Max 对象一样，Jitter 对象会保留存储在一个入口中的矩阵，即使另一个入口接收到了新矩阵。所以这个 patch 的 <code>metro</code> 只需要触发 <code>jit.movi​​e</code>。包含查找表<code>jit.charmap</code> 的<code>jit.matrix</code> 只需要在所存储的数据发生变化时输出值。</p></blockquote><p>以下是一些查找表及其结果：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12d.png" alt=""><br>三组 <code>multislider</code>及其生成的颜色查找表和输出颜色轮</p><p>例 1 中，红色和蓝色查找表调换而绿色正常。结果是输入图像中较大的红色和蓝色值在输出时变小，反之亦然。所以色轮的白色背景现在看起来是绿色的（单元格值 0 255 255 255 映射为 0 0 255 0）。</p><p>例 2 设置绿色平面为 0（查找表在整个输入值范围内设置为 0）。红色和蓝色平面如果超过阈值也设置为 0，这时值会突然上升（红色比蓝色上升得更明显）。结果是色轮大部分都是黑色的（特别是在绿色区域）。红色平面仅在非常高的值（即色轮背景中的品红色）中可见。</p><p>例 3 正常映射红色平面。绿色平面是抛物线形状，极值映射为高，中间阴影映射为低。蓝色平面除了中间调中被归零的范围，其余正常。这种非线性表现为贯穿彩色轮顶部和右侧的红色“断层线”。</p><p>有无数组合可以重新映射矩阵单元格的值。接下来研究另一个以更精确方式重新映射颜色值的对象。</p><h2 id="jit-gradient-对象"><a href="#jit-gradient-对象" class="headerlink" title="jit.gradient 对象"></a>jit.gradient 对象</h2><p>打开 Duotone 子 patch，它显示了使用 <code>jit.gradient</code> 生成查找表的方法：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12e.png" alt=""><br>使用 <code>jit.gradient</code> 对象</p><p><code>jit.gradient</code> 生成两个单元格的值之间平滑渐变的单维 char 矩阵。<code>start</code> 和 <code>stop</code> 属性是指定这些单元格的值列表。例如，start 属性 <code>0 0 0 0</code> 和 end 属性 <code>0 0.5 1.0 0.5</code> 将生成从黑色（矩阵中的单元格 0）到浅绿色（矩阵中最后一个单元格）的渐变。</p><p>我们已经用参数指定 <code>jit.gradient</code> 为 256 单元宽，这样当它改变时可以存储在 <code>jit.matrix colortable</code> 中。请注意， <code>jit.gradient</code> 在属性列表中使用浮点数来指定 char 值（即属性中用值 1.0 指定 char 值为 255）。</p><p>用 <code>swatch</code> 对象输出的 RGB 列表转换为 ARGB 浮点数来获得格式化属性。将属性发送到 <code>jit.gradient</code> 对象后，它接收触发对象发出的 bang，将矩阵输出到 patch 左侧的<code>jit.matrix</code>。</p><p>尝试在 <code>swatch</code> 中选择颜色。start 和 end 属性指定查找表的边界，所以输入图像的值表现为在两种颜色之间变化的双色调外观。patch 顶部的 <code>multislider</code> 将反映 <code>jit.gradient</code> 所生成的查找表。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12f.png" alt=""><br>使用颜色渐变作为查找表</p><p>例 1 是翻转的图像。查找表的 start 是白色（<code>start 0 1.0 1.0 1.0</code>），end 是黑色（<code>end 0. 0. 0. 0</code>）。结果是输入值 0 映射到 255，反之亦然（<code>y = 255 - x</code>）。</p><p>例 2 和 3 是双色调渐变，将色轮的光谱重新映射到红色和橙色（例 2）以及橄榄色和青色（例 3）之间。请注意，根据色轮中不同点的原始颜色，渐变曲线变得更陡峭或更和缓。</p><p><code>jit.gradient</code> 的另一个属性是 cheby，它指定在矩阵开始和结束值之间的变形曲线。cheby 属性的参数列表是浮点数。这些参数是 Chebyshev polynomials（见下文的切比雪夫多项式）不同阶数的振幅。使用查找表时，这些特殊功能曲线会产生不同的效果。patch 中设置 cheby 属性的 <code>multislider</code>，可以指定前 8 个 Chebyshev polynomials 曲线的相对振幅，形状如下（如果将它们视为从黑色到白色的过渡）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12g.png" alt=""><br>用 Chebyshev orders 1-4（顶行）和 5-8（底行）生成的梯度</p><blockquote><p>技术说明：切比雪夫多项式通常用作数字合成算法中波形整形音频信号的查找表（它们的特殊属性可以将正弦波形扭曲成等效于不同阶数幅度的谐波频谱）。MSP <code>lookup~</code> 对象可以与加载到 <code>buffer~</code> 中的函数一起来完成音频信号处理（跟本教程中的图像处理类似）。更多内容请参阅 MSP 手册中的教程 12：综合波形整形。</p></blockquote><p>复位 gradient 中开始和结束点（单击上面的消息框），缓慢调整 <code>multislider</code>控制的 cheby 属性。观察颜色轮在颜色消失并在不同区域重新出现时如何变化。</p><p>在 <code>jit.gradient</code> 中使用 cheby 属性时，即使将渐变起点和终点保留为黑色和白色，也可以得到一些非常有趣的颜色变形效果。以下是视频剪辑 rain.mov 的一些例子：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter12h.png" alt=""><br>不同梯度曲线对雨水彩色频谱的影响</p><p>左边图像显示 rain.mov 中未处理的静止图像。中间图像显示了当使用二阶切比雪夫多项式（图像中最暗的区域现在位于色谱的中间）生成梯度时色谱的变化。右侧图像显示更复杂的梯度，色谱显示多个峰和谷。</p><p>patch 顶部的 <code>multislider</code>反映查找表的当前状态（由 <code>jit.gradient</code> 生成的矩阵被发送到 <code>p showit</code> 子 patch 中的 <code>jit.iter</code>，在那里数字被组合以设定 <code>multislider</code> 的状态）。尝试生成渐变，然后调整 multislider 手动修改查找表。这样 <code>jit.gradient</code> 就作为更复杂的查找表的起始点。</p><p><img src="http://img.viz.mobi/jitterchapter12i.png" alt=""></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>使用 <code>jit.charmap</code> 映射 char 矩阵中单元格的值。<code>jit.charmap</code> 的右入口接收 256 单元矩阵来定义要用于输入矩阵数据的查找表（或传递函数）。可以使用多种方法定义查找表，包括<strong>使用 <code>jit.fill</code>从 Max 列表生成矩阵，或使用 <code>jit.gradient</code> 对象根据 cheby 指定的曲线形状，在开始和结束单元格值之间生成颜色渐变属性。</strong></p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="颜色" scheme="http://uegeek.com/tags/%E9%A2%9C%E8%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译13 - 列表和矩阵</title>
    <link href="http://uegeek.com/180906-jitter-13.html"/>
    <id>http://uegeek.com/180906-jitter-13.html</id>
    <published>2018-09-06T10:54:22.000Z</published>
    <updated>2018-09-25T07:38:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-4.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li><li><a href="https://www.uegeek.com/180904-jitter-12.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 12 - Chromakeying</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter11" target="_blank" rel="noopener">Tutorial 11: Lists and Matrices</a></p></blockquote><p>本教程讲解如何用 Max 列表和 <code>jit.fill</code> 对象来填充（部分）矩阵，以及如何用 <code>jit.spill</code> 检索（部分）矩阵内容作为列表。还将演示通过矩阵名称远程访问矩阵内容。</p><h2 id="矩阵名称"><a href="#矩阵名称" class="headerlink" title="矩阵名称"></a>矩阵名称</h2><p>patch 左侧有一个蓝色的 <code>jit.matrix</code>。第一个参数是矩阵的名称 smallbox。其他参数表示矩阵有 1 个 char 平面，包含一维 12 个单元格。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11a.png" alt=""><br>矩阵唯一名称：smallbox</p><p><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 介绍过，每个矩阵都有一个名称。如果没有另外指定，Jitter 将自动命名（类似 “u040000114” 奇怪的唯一名称）。名称表示存储矩阵的内存位置。为什么要另外给矩阵命名呢？这样可以告诉其他对象如何找到矩阵的内容。引用矩阵的名称，对象之间可以共享数据，无需接收 jit_matrix 消息就可以远程访问矩阵的内容。</p><blockquote><p>Jitter 使用矩阵名称来指代内存位置，这跟 Max 的 <code>value</code> 对象类似。名称相同的对象可以有多个，只在其中一个中存储数值，其他对象就可以检索这个值。该名称实际上只有一个内存位置，它们共享相同的数据。同样，可以有多个名称相同的 <code>jit.matrix</code> 对象，它们共享相同的数据。其他对象（例如 <code>jit.fill</code>）只需知道名称即可访问矩阵内容。</p></blockquote><h2 id="jit-fill"><a href="#jit-fill" class="headerlink" title="jit.fill"></a>jit.fill</h2><p><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 展示了在矩阵特定位置指定数值的 <code>setcell</code>消息，以及检索位置内容的 <code>getcell</code> 消息。现在来看看如何使用 <code>jit.fill</code> 对象将一个值列表存入矩阵中。（本章后面还将展示如何从矩阵中一次检索多个值）</p><p>在 patch 的左上角有一个包含  12 个数值列表的消息框。它连接到 <code>jit.fill smallbox</code> 对象。矩阵名字是 smallBox。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11b.png" alt=""><br> <code>jit.fill</code> 在命名矩阵中存储一个值列表</p><p>单击消息框将列表发送到 <code>jit.fill smallbox</code>。对象在名为 “smallBox” 的矩阵存储这些值。单击 <code>jit.matrix smallbox</code> 上方的按钮显示 smallbox 矩阵的内容来验证。这些值由 <code>jit.print</code> 打印在 Max Console 中，并在狭长的 <code>jit.pwindow</code> 中显示为灰阶。</p><p>这个例子的列表长度恰好可以填充整个矩阵。这不是必须的。可以在 1D 或 2D 矩阵的任意连续部分中放置任何长度的列表。</p><h2 id="偏移属性"><a href="#偏移属性" class="headerlink" title="偏移属性"></a>偏移属性</h2><p>双击打开 <code>random_lists</code> 子 patch。</p><p>默认情况下，<code>jit.fill</code> 将值列表放在矩阵最开头。也可以设置 <code>jit.fill</code> 的 <code>offset</code> 属性将列表指定到矩阵中的任何位置。这里演示如何使用 offset。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11c.png" alt=""><br>首先指定偏移量，后跟列表</p><p>上面的例子随机选择单元格索引作为 <code>jit.fill</code> offset 消息的参数，然后向 randbox 矩阵中的该索引处，发送要存储的 16 个元素的列表。</p><p>点击开关启动 <code>metro</code>。每隔半秒，16 个元素的列表被写入 randbox 矩阵中的新位置。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11d.png" alt=""></p><p>用 <code>clear</code> 消息清除 randbox 矩阵的内容，然后观察 <code>metro</code> 将列表写入新的随机位置。<code>metro</code> 也正在触发 <code>jit.matrix randbox</code> 将其内容发送到 <code>jit.pwindow</code> 显示。</p><h2 id="使用-multislider"><a href="#使用-multislider" class="headerlink" title="使用 multislider"></a>使用 multislider</h2><p>打开 draw_list 子 patch。</p><p>现在我们知道如何将预先定义的值列表存到矩阵中。如果要在 Max 中交互式生成列表并实时放置在矩阵中，需要用构建列表的对象比如  <code>multislider</code> 和 <code>zl</code>。</p><p><code>multislider</code> 对象包含一组 <code>slider</code>，并一次发送所有 slider 的值作为列表（slider 可以小到一个像素宽，这样它看起来更像一个图形而不是一组单独的控件）。在窗口中移动任何 slider 时会发送整个列表，释放鼠标按钮时再次发送列表。在 draw_list 子 patch，有一个包含 256 个滑块的 <code>multislider</code>，可发送从 0~255 的值，它恰好将 256 个 char 值发送给 <code>jit.fill graybox</code>  对象。</p><p>拖动鼠标在 <code>multislider</code> 中设置 256 个滑块。释放鼠标按钮时，256 个值的列表将发送到 <code>jit.fill graybox</code>。注意矩阵单元的亮度如何与滑块的高度相对应。</p><p>一旦 <code>jit.fill</code> 在入口处收到列表，就会写入指定的矩阵（offset 属性指定的）位置。完成时 <code>jit.fill</code> 会发出 bang。可以用它来触发另一个动作，例如显示矩阵。</p><blockquote><p>前两个例子故意不使用 <code>jit.fill</code>左侧出口的 bang，以便清楚看到，<code>jit.fill</code> 远程写入到指定命名的矩阵，而不是通过物理连接。当然 <code>jit.fill</code> 左侧出口的 bang 很方便，只要填充完就会触发矩阵的输出。</p></blockquote><h2 id="使用-zl"><a href="#使用-zl" class="headerlink" title="使用 zl"></a>使用 zl</h2><p>打开 collect_values 子 patch</p><p>某些情况下你可能想用矩阵来存储 patch 某处的数字消息：MIDI消息、来自 UI 对象的数字等。可以向 <code>jit.matrix</code> 发送 <code>setcell</code> 和 <code>getcell</code> 消息，也可以将消息收集到列表中，然后用 <code>jit.fill</code> 将它们一次性存到矩阵中。</p><p><code>zl</code> 是多功能的列表处理对象，由第一个参数指定模式和行为。当第一个参数是 group 时，它会收集左入口的消息直到一定数量，然后将这些数字作为单个列表发送出去（这些值按接收顺序分组）。在 collect_values 子 patch 中有一个 <code>zl group 256</code> 对象，每当它从左入口收集够 256 个值，就把这个列表发送到左出口（并清除内存）。</p><p>向上和向下移动 slider 为 <code>zl</code> 对象生成 256 个输入值。当 <code>zl</code> 收到 256 个数字时，它把这个列表发送到 <code>jit.fill midibox</code>，由它写入 midibox 矩阵，然后 bang <code>jit.matrix midibox 1 char 256</code> 对象以显示矩阵。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11e.png" alt=""><br><code>zl</code> 将包含 256 个元素的列表发送到 midibox 矩阵，然后 bang <code>jit.matrix</code> 来显示结果</p><p>如果电脑连接了 MIDI 键盘，可以使用 MIDI 键盘的 modulation wheel 移动 slider。（MIDI 和 Jitter 的交互将在后面的教程中详细探讨）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11f.png" alt=""><br>值*2 获得 0~254 范围</p><p>可以用<code>list length</code>数字框向右入口发送新的值来更改 <code>zl</code>数据集的列表长度。用 <code>loacation</code> 数字框发送 <code>offset</code> 消息给 <code>jit.fill</code> 告诉它想要存储列表的位置。改变列表长度和位置，可以将任意数量的值放入矩阵的任何连续区域。</p><p>更改 <code>zl</code> 的 list length （如 100），设置 <code>jit.fill</code> 的 offset 属性（如 50），然后移动 slider 把值的列表存到矩阵中的指定位置。</p><h2 id="jit-fill-和多平面矩阵"><a href="#jit-fill-和多平面矩阵" class="headerlink" title="jit.fill 和多平面矩阵"></a>jit.fill 和多平面矩阵</h2><p>打开 <code>fill_separate_panes</code> 子 patch</p><p><code>jit.fill</code> 可用于多平面矩阵，但它一次只能填充一个平面。<code>jit.fill</code> 要处理哪个平面由 <code>@plane</code> 属性指定。在<code>fill_separate_panes</code> 子 patch 中创建了另一个名为 colorbox 的矩阵，这次有四个char 数据平面。设置了三个 <code>multislider</code> 和三个 <code>jit.fill</code> 对象，每个对象都对应 colorbox 框矩阵的不同颜色平面。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11g.png" alt=""><br>各自填充每个平面</p><p>拖动三个彩色 <code>multislider</code> 填充三个颜色平面。</p><p>这样可以快捷生成矩阵中 RGB 平面不同强度的曲线。显示矩阵的 <code>jit.pwindow</code> 宽为 256 像素，所以矩阵 64 个单元格都显示为 4 像素宽的条带。如果打开 <code>jit.pwindow</code> 的 <code>interp</code> 属性，相邻频段之间的差值会被插值平滑。</p><p>单击 <code>interp $1</code> 消息框上方的开关，将消息发送到 <code>jit.pwindow</code>。（注意，这也会发送 bang 到 <code>jit.matrix</code> 重新显示内容）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11h.png" alt=""><br>与前一个示例相同，但打开了 <code>jit.pwindow</code> 的插值</p><h2 id="jit-fill-和二维矩阵"><a href="#jit-fill-和二维矩阵" class="headerlink" title="jit.fill 和二维矩阵"></a>jit.fill 和二维矩阵</h2><p>目前为止所有的例子都是一维矩阵。用列表（一维数组）通过 <code>jit.fill</code> 填充二维矩阵时会发生什么？<code>jit.fill</code> 对象在第一个维度里尽可能排列列表（尽量排满指定的行）然后绕到下一行继续排列。下面演示排列的过程。</p><p>单击标有 2D 的按钮，把 <code>jit.matrix colorbox</code> 对象变成 8x8 二维矩阵，<code>jit.pwindow</code> 也会调整为更合适的形状。无论何时更改矩阵尺寸，它都会清除之前的数据，所以需要再次单击三个 multislider 重新填充矩阵。仍向每个 <code>jit.fill</code> 对象发送 64 个元素的列表，并用 8 个元素填充矩阵的 8 行。</p><blockquote><p>要点：这里没有演示如何使用带有 offset 属性的 2D 矩阵，当 <code>jit.fill</code> 的 name 属性命名 2D 矩阵时，offset 属性需要两个参数： x 偏移量和 y 偏移量。</p><p><code>jit.fill</code>  仅适用于 1D 和 2D 矩阵。</p></blockquote><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11i.png" alt=""><br>相同的例子，列表填充 8x8 矩阵（未插值）</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11j.png" alt=""><br>开启插值</p><h2 id="jit-spill"><a href="#jit-spill" class="headerlink" title="jit.spill"></a>jit.spill</h2><p><code>jit.spill</code> 是 <code>jit.fill</code> 的补充。它在入口处接收 <code>jit_matrix</code> 消息，将矩阵值作为列表发送到左出口。当使用红色 <code>multislider</code> ，下面的 <code>jit.spill</code> 发送平面 1（红色）的值到左出口并在消息框显示内容。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11k.png" alt=""><br>用列表显示 colorbox 矩阵的平面 1 的内容</p><blockquote><p><code>jit.spill</code> 也有 list length 和 offset 属性</p></blockquote><p>如果需要发送一系列单个数字消息而不是单个列表消息，<code>iter</code> 对象了解一下。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11l.png" alt=""><br>从矩阵中获取一些值并分成不同的消息</p><h2 id="jit-iter"><a href="#jit-iter" class="headerlink" title="jit.iter"></a>jit.iter</h2><p>打开 individual_values 子 patch。</p><p><code>jit.iter</code> 对象可以检索矩阵中的每个值。当它收到 <code>jit_matrix</code> 消息时，会按矩阵中单元格的顺序发出消息序列：单元格索引（中间出口），然后是该单元格的值（左出口）。如果是一个大矩阵，会有一大堆消息试图在（Max’s scheduler）单个 tick 中发送出去，所以当它完成所有发送后，<code>jit.iter</code> 会向右出口发送一条完成的消息。</p><p>在 individual_values 子 patch 中有一个 <code>jit.iter</code> 对象，它接收来自 <code>jit.matrix readbox 1 char 256</code> 的矩阵信息。我们使用 <code>swap</code> 对象切换单元格索引的顺序（来自 <code>jit.iter</code> 中间出口）和单元格值（来自 <code>jit.iter</code> 左出口）。然后用该单元格的值作为想要存储在表对象中的 y 值，用单元格索引作为 x 轴索引。</p><p>点击 <code>multislider</code> 发送内容给 <code>jit.fill</code>（然后 bang  <code>jit.matrix</code> 并传达其内容给 <code>jit.iter</code>）。双击 <code>tabel</code> 对象打开图形窗口，看到它包含与 readbox 矩阵相同的值。</p><p>请注意，使用 <code>jit.iter</code> 填充表格的技巧适用于中等大小的一维单平面矩阵，因为表格是一维数组。但是像<code>jit.movi​​e</code> 对象的 2D 矩阵有四个平面，<code>jit.iter</code> 的中间（单元索引）出口输出双元素列表，左出口的值列表是四元素列表。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter11m.png" alt="">            </p><p>对于一维或小的 2D 矩阵，或者在较大矩阵中搜索特定值或模式， 用 <code>jit.iter</code> 扫描整个矩阵是很方便的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>发送 <code>setcell</code> 和 <code>getcell</code> 消息给 <code>jit.matrix</code>，可以<strong>存储或检索矩阵中的单个值</strong>（如<a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">教程 4</a> 所示）。<strong>如果要存储或检索列表，就要用 <code>jit.fill</code> 和 <code>jit.spill</code>。</strong>它们可以检索 1D 或 2D 矩阵的任何平面，在任意起始单元位置存储任何长度的列表。</p><p><code>multislider</code> 和 <code>zl</code> 对象用于实时生成列表消息。用鼠标拖动 <code>multislider</code> 可以绘制列表。使用 <code>zl group</code> 收集多个单独的数值到一个列表中，然后一次性发送到 <code>jit.fill</code>。</p><p>可以设置 <code>jit.fill</code>（或 <code>jit.spill</code>）的 offset 属性来指定矩阵中的起始单元格位置。<code>jit.fill</code> 对象要设置名称属性（或者发送<code>name</code> 消息或输入[name]参数），指定它将填补的矩阵名称。它用这个名称访问矩阵，并且在列表写入矩阵完成时发出 bang。可以用它来触发其他操作。</p><p>发送矩阵给 <code>jit.iter</code>，可以输出整个矩阵中所有值。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="列表" scheme="http://uegeek.com/tags/%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译12 - Chromakeying 视频去背景合成</title>
    <link href="http://uegeek.com/180904-jitter-12.html"/>
    <id>http://uegeek.com/180904-jitter-12.html</id>
    <published>2018-09-04T11:16:04.000Z</published>
    <updated>2018-09-25T07:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-3.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180903-jitter-11.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 11 - 矩阵混合</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter10" target="_blank" rel="noopener">Tutorial 10: Chromakeying</a></p></blockquote><p>本教程介绍如何使用 <code>jit.chromakey</code> 对两个源视频Chromakeying（去背景合成，chroma-纯色，key-抽离颜色）。还将学习如何使用 <code>suckah</code> 对象获取屏幕上任意像素的颜色。</p><p>打开教程 patch，由 <code>loadbang</code> 发送 <code>read</code> 消息到两个 <code>jit.movi​​e</code> 对象，自动读取两个视频（oh.mov 和 traffic.mov）：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10a.png" alt=""><br>通过 <code>loadbang</code> 初始化 patch</p><p>其他参数也由连接到右侧消息框的 <code>loadbang</code> 初始化。消息框发送消息到 patch 中其他名为 <code>receive</code> 的对象完成初始化。（参见<a href="https://docs.cycling74.com/max7/tutorials/basicchapter16" target="_blank" rel="noopener">教程 18：Remote Messaging</a>）。</p><p>点击开关启动 <code>metro</code>。三个 <code>jit.pwindow</code> 对象中出现了图像。开关不仅可以启动和停止 <code>metro</code>，还可以启动和停止两个 <code>jit.movi​​e</code> 视频播放。</p><p>教程 patch 的下半部分（三个 <code>jit.pwindow</code> 中的两个）是这样的：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10b.png" alt=""><br><code>jit.chromakey</code> 对象</p><p>点击左侧 <code>jit.pwindow</code> 对象的蓝色区域（即视频中男性头部后面的区域）。</p><p>第三个 <code>jit.pwindow</code>（在 patch 右下角）将显示：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10c.png" alt="">            </p><blockquote><p>历史说明：蓝屏合成（在蓝色哑光背景下拍摄现场镜头的过程）在 20 世纪 30 年代就出现了，目的是为了后期用其他图像替换蓝色。蓝屏合成涉及平版印刷分色，起初是非常昂贵的电影工艺，它（现在更常见的是绿屏合成）已经演变成影视制作中最常见的特效。通过数字叠加完成 Chromakeying（蓝屏处理的术语）让它更普及。Chromakeying 在电视行业中常被称为 CSO（色彩分离叠加），由 1960 年代开发它的 BBC 团队命名。蓝屏发明者 Petro Vlahos 在 1994 年被授予了电影艺术与科学学院终身成就奖，以表彰这项无可替代的技术。</p></blockquote><h2 id="jit-chromakey-对象"><a href="#jit-chromakey-对象" class="headerlink" title="jit.chromakey 对象"></a>jit.chromakey 对象</h2><p>去背景合成 - 将一个图像叠加在另一个上面，选择性替换颜色的过程 - 由 <code>jit.chromakey</code> 对象实现。<strong>通过指定颜色和其他参数， <code>jit.chromakey</code> 在第一个（左侧）矩阵中检测包含该颜色的单元，并在生成输出矩阵时，用第二个（右侧）矩阵中的对应单元替换它们。</strong>这样，来自第一个矩阵的单元叠加到第二个矩阵上。</p><p>可以选择任何颜色为要去除的背景，请尝试点击左侧 <code>jit.pwindow</code> 中的其他区域。不同的颜色会从男人的脸上移除，而显示出第二个视频中的图像。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10d.png" alt=""><br>消失的面孔（第一部分）</p><p><code>jit.chromakey</code> 用 <code>color</code> 属性（称为参考颜色）来定义中心色。这个属性是一个值列表，应用于等待抠图的矩阵中的所有平面。<code>tol</code> 属性定义中心色的<strong>容差范围</strong>。此范围内的颜色也会被去除。</p><p>将 <code>jit.chromakey</code> 与 char 矩阵一起使用时，属性值的范围在 0.0~1.0，然后映射到 char 数据所需的 0~255。所以可以将属性设置为 <code>color 0 0 1.0 0</code>，而不是 <code>0 0 255 0</code>。<code>tol</code> 为 0.5 时会去除距离参考色一半色阶的所有颜色（key all values within half of the chromatic distance from the reference color）。<code>tol</code> 为 0 时只会用精确的参考色来完成抠图。</p><p>再次点击左侧视频中的蓝色区域，然后调整 <code>tol</code> 属性查看输出的变化。在低容差时，左图中的一些蓝屏将保留。容差值非常高时，男人脸部的部分可能会消失。</p><p>在教程 patch 中，我们通过点击不可见的对象来设置 <code>jit.chromakey</code> 的颜色属性。解锁 patch，会看到左侧 <code>jit.pwindow</code> 上面的同心红色方块区域：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10e.png" alt=""><br><code>suckah</code> 对象</p><p>该区域是名为 <code>suckah</code> 的 Max UI 对象，可以在 interface 工具栏找到它：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10f.png" alt=""><br>对象面板中的 suckah 对象</p><p><code>suckah</code> 对象获取它所覆盖的屏幕像素的 RGB 值。当单击对象时（patch 处于锁定状态），它会获取 0.0~1.0 范围内的浮点数值。例如，单击视频中的纯蓝色区域，<code>suckah</code> 会发送 <code>0 0 1.0</code> 列表（suckah 的初始版本使用 0~255 范围。如果需要，可以在 inspector 中选择这个设置）</p><p><code>suckah</code> 对象获取 RGB 颜色列表后，用 <code>prepend 0</code> 在前面加上 0（增加 alpha 值到列表最前面）来设置 <code>jit.chromakey</code> 的颜色属性。然后再 <code>prepend color</code> 并发送给 <code>jit.chromakey</code>。</p><h2 id="Chromakey-选项"><a href="#Chromakey-选项" class="headerlink" title="Chromakey 选项"></a>Chromakey 选项</h2><p><code>jit.chromakey</code> 对象有附加属性：minkey，maxkey 和 fade。当矩阵从左入口进入，<code>jit.chromakey</code> 基于该矩阵在内部创建一个灰度（单平面）遮罩。输入矩阵中，在容差（tol）范围内颜色值的单元格，将设置为遮罩中的 maxkey 属性值（默认为 1）。容差范围之外的区域乘以 minkey 属性（默认为 0）。如果 minkey 和 maxkey 为 0 和 1，生成的图像在去背景的位置应该看起来是白色，而在要保留原始图像的位置看起来是黑色。</p><p>将得到的遮罩及其负片，分别乘以右矩阵和左矩阵。然后添加乘法的结果以形成合成图像。下图说明了这个过程：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10g.png" alt=""><br>遮罩（minkey 为 0，maxkey 为 1）和合成效果</p><p>maxkey 属性设置右边输出矩阵的强度，minkey 属性设置左边矩阵的强度。如果要反转 minkey 和 maxkey 属性，chromakey 将被反转：</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter10h.png" alt=""><br>minkey 为 1，maxkey 为 0（反向色度键）的合成效果</p><p>fade 属性在被去除和保留的区域之间生成插值，可以生成柔化边缘。左边矩阵中的颜色略微超出了容差范围，但是在参考颜色的 tol + fade 的范围内，在原始颜色和右侧矩阵对应单元格中的颜色之间插值。插值取决于 fade 值的大小，以及颜色距离容差边界有多远。</p><p>尝试不同的 tol，fade，minkey，maxkey 和 color 值。观察五个属性如何影响不同的抠图效果，以及 minkey 和 maxkey 值如何相互补充。</p><p>完全去除背景很困难。选取合适的 tol 和 fade 属性值，才能确保第一个图像中的区域对第二个图像起作用。包含很多细节的图像，通常会在抠图和保留区域之间颜色变化的区域，出现轻微的斑点。此外，单一颜色（例如蓝色）基本上满足不了去背景的需要，必须使用一系列值。但是你会发现，希望去除的颜色会出现在想要保留的区域中！平衡所有因素以获得满意的效果，是使用 <code>jit.chromakey</code> 对象最困难的部分。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>jit.chromakey</code> 对象实现两个 Jitter 对象的 chromakeying。可以使用 color 和 tol 属性设置抠图的颜色范围，并用 fade，minkey 和 maxkey 值来定义两个矩阵在合成时的工作方式。<code>suckah</code> 对象放置在 <code>jit.pwindow</code> 上方，点击即可以获取所在位置的颜色。</p><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Chromakeying" scheme="http://uegeek.com/tags/Chromakeying/"/>
    
      <category term="抠图" scheme="http://uegeek.com/tags/%E6%8A%A0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译11 - 矩阵混合</title>
    <link href="http://uegeek.com/180903-jitter-11.html"/>
    <id>http://uegeek.com/180903-jitter-11.html</id>
    <published>2018-09-03T10:23:32.000Z</published>
    <updated>2018-09-25T07:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-2.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li><li><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 10 - 简单混合</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter09" target="_blank" rel="noopener">Tutorial 9: More Mixing</a></p></blockquote><p>本教程探讨用 <code>jit.scalebias</code> 和 <code>jit.op</code> 实现交叉渐变的技巧。它比 <code>jit.xfade</code> 方法复杂一些，但更灵活。</p><h2 id="混合和交叉淡化"><a href="#混合和交叉淡化" class="headerlink" title="混合和交叉淡化"></a>混合和交叉淡化</h2><p><a href="https://www.uegeek.com/180902-jitter-10.html" target="_blank" rel="noopener">上一章</a>讲解了 <code>jit.xfade</code> 用缩放（乘法）和加法以不同的比例混合两个矩阵。本教程将使用 <code>jit.scalebias</code> 和 <code>jit.op</code> 对象来自动执行这些数学运算。</p><p>这样做有一些好处。首先能清楚地演示混合和交叉渐变的数学过程。其次能看到 <code>jit.op</code> 如何对两个输入矩阵做数学运算。（在<a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">教程 5 </a>中展示了 <code>jit.op</code> 和标量值如何作用于单个矩阵）。第三，它可以分别指定两个矩阵的缩放因子，比 <code>jit.xfade</code> 更灵活。最后，<code>jit.op</code> 可以实现许多不同类型的数学运算，我们可以尝试其他组合矩阵的方法来得到不同的视觉效果。</p><h2 id="再说-Mixing"><a href="#再说-Mixing" class="headerlink" title="再说 Mixing"></a>再说 Mixing</h2><p>打开教程 patch</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter09a.png" alt=""><br>用乘法和加法混合/交叉渐变矩阵</p><p>缩放因子设置为 0~1 之间的 <code>jit.scalebias</code> 将两个视频 scaled down（变暗）。下面会看到用 <code>jit.op</code> 的不同：两个入口的输入都是矩阵。这时 <code>jit.op</code> 分别对每个值执行指定的数学运算，<strong>将左矩阵中的每个值与右矩阵中的对应值配对</strong>。这样我们可以把两个矩阵的所有值相加来混合图像。</p><p>这些乘法和加法的结果与 <code>jit.xfade</code> 对象做内部运算的结果一样。可以试试用 patch 右上角的控件来交叉渐变视频（与上一章几乎完全相同）。</p><p>启动 <code>metro</code> 并使用 <code>Mixer slider</code> 执行从视频 A 到 B 的交叉渐变。</p><p>请注意，渐变值直接作为视频 B 的缩放因子，同时 <code>!- 1</code> 对象用 1 减去该值，得到视频 A 的缩放因子。这样，两个缩放因子的和总是等于 1，就像在 <code>jit.xfade</code> 中一样。</p><h2 id="使用其他运算符组合矩阵"><a href="#使用其他运算符组合矩阵" class="headerlink" title="使用其他运算符组合矩阵"></a>使用其他运算符组合矩阵</h2><p>加法是两个矩阵最常见的运算。更改 <code>jit.op</code> 的 op 属性，可以尝试许多其他运算并查看其视觉效果。</p><p>在 <code>Transition Time</code> 数字框中设置一个非常长的交叉渐变时间（例如 10000 ms）。在 <code>Operator</code> 弹出菜单中选择 + 以外的运算符。现在点击 <code>Go To switch</code> 开始渐变，可以看到两个视频矩阵的运算如何进行。</p><p>弹出菜单包含 <code>jit.op</code> 各种运算符中的一部分。以下是菜单中选项的简要说明。</p><ul><li><code>+</code> 把 B 值加到 A</li><li><code>-m</code> 从 A 中减去 B，然后取模将结果折算回所需的数值范围</li><li><code>max</code> 使用 A B 中较大的值</li><li><code>absdiff</code>从 A 中减去 B，然后取差值的绝对值</li><li><code>|</code> “按位或”; 二进制操作，A 或 B 为 1，结果为 1</li><li><code>^</code> “按位独占或”; 二进制操作，A 和 B 值不相同，结果为 1，否则为 0</li><li><code>&gt;</code> 如果 A 大于 B，结果为 1（或 char 255），否则为 0</li><li><code>&lt;</code> 如果 A 小于 B，结果为 1（或 char 255），否则为 0</li><li><code>&gt;p</code> 如果 A 大于 B，结果为 A，否则为 0</li><li><code>&lt;p</code> 如果 A 小于 B，结果为 A，否则为 0</li></ul><p>其他运算符请查看 <code>jit.op</code> 对象参考文档。</p><p>你也可以直接拖动 <code>jit.scalebias</code> 上方的数字框，单独设置混合比例。还可以尝试超过 0~1 范围的值。</p><h2 id="jit-scalebias-vs-jit-op-op"><a href="#jit-scalebias-vs-jit-op-op" class="headerlink" title="jit.scalebias vs. jit.op @op *"></a>jit.scalebias vs. jit.op @op *</h2><p>这个 patch 用 <code>jit.scalebias</code> 来做缩放乘法，而没有用 <code>jit.op</code> 与 * 运算符。为什么呢？</p><p>当 <code>jit.op</code> 操作 char 数据时，val 属性范围是 0.0~1.0（浮点数）或 0~255（整数）。如果想将 char 数据乘以 0~1 的某个值，用 <code>jit.op</code> 就可以。如果想乘以其他范围的值，就要用 <code>jit.scalebias</code>，它允许 scale 的值超过 0~1 范围。 <code>jit.scalebias</code> 仅用于处理 4 平面 char 矩阵，在这个例子中没问题。所以在这个 patch 中，因为是在 4 平面 char 矩阵上做运算，并且想使用超过 0~1 范围的缩放因子，所以使用了 <code>jit.scalebias</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你可以用 <code>jit.op</code> 对两个不同矩阵中的值执行各种数学运算。 <strong><code>jit.op</code> 对每个值执行指定的数学运算，将左矩阵中的每个值与右矩阵中的对应值配对。当两个矩阵的 dim，planecount 和 type 属性不同时，<code>jit.op</code> 使用左入口矩阵的属性</strong>。在混合两个视频图像时，不同的数学运算符可以生成各种视觉效果。</p><hr><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li></ul><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Math" scheme="http://uegeek.com/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Max/MSP/Jitter 官方教程翻译10 - 交叉渐变</title>
    <link href="http://uegeek.com/180902-jitter-10.html"/>
    <id>http://uegeek.com/180902-jitter-10.html</id>
    <published>2018-09-02T10:29:21.000Z</published>
    <updated>2018-09-25T07:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img.viz.mobi/Max-title-1.jpg" alt=""></p><a id="more"></a><ul><li><a href="https://www.uegeek.com/180821-jitter-01.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 01 - 什么是矩阵？</a></li><li><a href="https://www.uegeek.com/180822-jitter-02.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 02 - Jitter 对象的属性</a></li><li><a href="https://www.uegeek.com/180825-jitter-03.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 03 - 播放 QuickTime 视频</a></li><li><a href="https://www.uegeek.com/180826-jitter-04.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 04 - 创建矩阵</a></li><li><a href="https://www.uegeek.com/180828-jitter-05.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 05 - 矩阵的数学运算</a></li><li><a href="https://www.uegeek.com/180829-jitter-06.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 06 - 控制视频播放</a></li><li><a href="https://www.uegeek.com/180830-jitter-07.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 07 - ARGB 颜色</a></li><li><a href="https://www.uegeek.com/180831-jitter-08.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 08 - 调整颜色</a></li><li><a href="https://www.uegeek.com/180901-jitter-09.html" target="_blank" rel="noopener">Max/MSP/Jitter 教程 09 - 调整图像颜色</a></li></ul><blockquote><p>00 翻译自 Cycling74 的 Max/MSP/Jitter 官方文档：<a href="https://docs.cycling74.com/max7/tutorials/jitterchapter08" target="_blank" rel="noopener">Tutorial 8: Simple Mixing</a></p></blockquote><p>本教程介绍如何使用 <code>jit.xfade</code> 对象混合和淡入淡出两个图像。</p><h2 id="混合两个视频源"><a href="#混合两个视频源" class="headerlink" title="混合两个视频源"></a>混合两个视频源</h2><p>混合两个图像是视频处理中最常见和最有用的技巧之一。</p><p>最简单的视频混合是将两个图像叠加起来，可以调整任一图像的强度。逐渐淡出一个图像，同时淡入另一个图像，可以创建图像之间的平滑过渡淡入淡出效果。</p><p>Jitter 处理混合和过渡渐变的对象是 <code>jit.xfade</code>。</p><blockquote><p>技术细节：这种类型的混合，将一个矩阵中的每个值，加到另一个矩阵各单元和各平面的相应值上，并输出所有总和的矩阵。但这样让输出图像的值都大于任何一个输入图像，会比原始图像更亮（如果矩阵包含 char 数据，某些值甚至会在 255 处裁剪）。所以在它们相加之前应该减小一个或两个图像的强度。例如，为了按相同比例混合两个图像，在相加之前将它们缩小相等的量（例如，0.5 倍）。</p></blockquote><h2 id="jit-xfade"><a href="#jit-xfade" class="headerlink" title="jit.xfade"></a>jit.xfade</h2><p><strong><code>jit.xfade</code> 对象接收两个输入口的矩阵，缩放两个矩阵中的值，然后把两个矩阵相加并输出混合后的矩阵</strong>。两个输入矩阵缩放因子由 xfade 属性决定。xfade 是 1~0 之间单个（浮点） 数值，是右输入口矩阵的缩放因子。左输入口的矩阵按 1-xfade 的比例缩放。如果逐渐将 xfade 值从 0 增加到 1，输出矩阵将从左输入到右输入淡入淡出。</p><p>打开教程 patch。<code>loadbang</code> 对象自动读取两个源视频。开启<code>metro</code>。开始只会看到左侧视频。拖动滑块更改 xfade 值来控制左右矩阵的混合。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter08a.png" alt=""><br>值为 0.5 时左右矩阵以相同比例混合</p><h2 id="自动交叉渐变"><a href="#自动交叉渐变" class="headerlink" title="自动交叉渐变"></a>自动交叉渐变</h2><p>交叉渐变是最常见的图像转换方式之一。它可以非常缓慢 - 持续几秒 - 或者非常快速，只持续几分之一秒，只比突然跳帧略微平滑。</p><p>在 patch 左上角，有一个从视频 A 到 B （B 到 A）的自动渐变控制器。交叉渐变可以持续用数字框指定的任意过渡时间。</p><p><img src="https://docs.cycling74.com/max7/tutorials/images/jitterchapter08b.png" alt=""><br>自动发送不断变化的 xfade 值</p><p>用数字框设置一个比较长的渐变时间（例如 5000 ms），可以看到交叉渐变器的效果。单击 Go To 右侧的开关淡入视频 B。</p><p>Go To 开关实际上是一个范围为 2 的 <code>slider</code>和一个 <code>* 100</code>乘法器，所以只会发送 0 和 100 两个值。单击开关右侧发出值 100，<code>pack</code> 发出消息 <code>100 5000</code>，<code>line</code> 对象在五秒内发出 0~100 的连续值（每 50 毫秒一个新值）。然后将这些值乘以 0.01，得到平滑变化的从 0~1 的 xfade 值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>叠加两个矩阵是最简单的混合视频图像的方法。想要控制两个图像的混合比例，首先要按某个因子缩放每个矩阵。想从一个图像渐变到另一个图像，将一个图像的缩放因子从 1 减小到 0，另一个从 0 增加到 1。</p><p><code>jit.xfade</code> 对象专门混合和/或交叉渐变两个矩阵。xfade 属性指定两个矩阵之间的混合比例。<strong>将 xfade 值从 0 连续增大到 1 可实现平滑的交叉渐变。</strong>可以使用 <code>line</code> 或其他 Max 计时对象来自动化交叉渐变。</p><hr><blockquote><p>友情提示：独自折腾 Max 易患上癔症……不妨入群互助 </p></blockquote><p>👇👇👇</p><p><img src="http://img.viz.mobi/maxgroup0825.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img.viz.mobi/Max-title-1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://uegeek.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="ArtxCode" scheme="http://uegeek.com/tags/ArtxCode/"/>
    
      <category term="Max/MSP" scheme="http://uegeek.com/tags/Max-MSP/"/>
    
      <category term="Jitter" scheme="http://uegeek.com/tags/Jitter/"/>
    
      <category term="矩阵" scheme="http://uegeek.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
      <category term="Creative Coding" scheme="http://uegeek.com/tags/Creative-Coding/"/>
    
      <category term="教程" scheme="http://uegeek.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="视频" scheme="http://uegeek.com/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
</feed>
